# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all modules.
#
# CDP version: v0.0.1438564
# CDP domain: Target

from __future__ import annotations

import enum
from collections.abc import Generator
from dataclasses import dataclass
from typing import Any

import streamlink.webbrowser.cdp.devtools.browser as browser
import streamlink.webbrowser.cdp.devtools.page as page
from streamlink.webbrowser.cdp.devtools.util import T_JSON_DICT, event_class
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


class TargetID(str):
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> TargetID:
        return cls(json)

    def __repr__(self):
        return f"TargetID({super().__repr__()})"


class SessionID(str):
    """
    Unique identifier of attached debugging session.
    """
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> SessionID:
        return cls(json)

    def __repr__(self):
        return f"SessionID({super().__repr__()})"


@dataclass
class TargetInfo:
    target_id: TargetID

    #: List of types: https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/devtools_agent_host_impl.cc?ss=chromium&q=f:devtools%20-f:out%20%22::kTypeTab%5B%5D%22
    type_: str

    title: str

    url: str

    #: Whether the target has an attached client.
    attached: bool

    #: Whether the target has access to the originating window.
    can_access_opener: bool

    #: Opener target Id
    opener_id: TargetID | None = None

    #: Frame id of originating window (is only set if target has an opener).
    opener_frame_id: page.FrameId | None = None

    browser_context_id: browser.BrowserContextID | None = None

    #: Provides additional details for specific target types. For example, for
    #: the type of "page", this may be set to "prerender".
    subtype: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["targetId"] = self.target_id.to_json()
        json["type"] = self.type_
        json["title"] = self.title
        json["url"] = self.url
        json["attached"] = self.attached
        json["canAccessOpener"] = self.can_access_opener
        if self.opener_id is not None:
            json["openerId"] = self.opener_id.to_json()
        if self.opener_frame_id is not None:
            json["openerFrameId"] = self.opener_frame_id.to_json()
        if self.browser_context_id is not None:
            json["browserContextId"] = self.browser_context_id.to_json()
        if self.subtype is not None:
            json["subtype"] = self.subtype
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> TargetInfo:
        return cls(
            target_id=TargetID.from_json(json["targetId"]),
            type_=str(json["type"]),
            title=str(json["title"]),
            url=str(json["url"]),
            attached=bool(json["attached"]),
            can_access_opener=bool(json["canAccessOpener"]),
            opener_id=TargetID.from_json(json["openerId"]) if "openerId" in json else None,
            opener_frame_id=page.FrameId.from_json(json["openerFrameId"]) if "openerFrameId" in json else None,
            browser_context_id=browser.BrowserContextID.from_json(json["browserContextId"]) if "browserContextId" in json else None,
            subtype=str(json["subtype"]) if "subtype" in json else None,
        )


@dataclass
class FilterEntry:
    """
    A filter used by target query/discovery/auto-attach operations.
    """
    #: If set, causes exclusion of matching targets from the list.
    exclude: bool | None = None

    #: If not present, matches any type.
    type_: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.exclude is not None:
            json["exclude"] = self.exclude
        if self.type_ is not None:
            json["type"] = self.type_
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FilterEntry:
        return cls(
            exclude=bool(json["exclude"]) if "exclude" in json else None,
            type_=str(json["type"]) if "type" in json else None,
        )


class TargetFilter(list):
    """
    The entries in TargetFilter are matched sequentially against targets and
    the first entry that matches determines if the target is included or not,
    depending on the value of ``exclude`` field in the entry.
    If filter is not specified, the one assumed is
    [{type: "browser", exclude: true}, {type: "tab", exclude: true}, {}]
    (i.e. include everything but ``browser`` and ``tab``).
    """
    def to_json(self) -> list[FilterEntry]:
        return self

    @classmethod
    def from_json(cls, json: list[FilterEntry]) -> TargetFilter:
        return cls(json)

    def __repr__(self):
        return f"TargetFilter({super().__repr__()})"


@dataclass
class RemoteLocation:
    host: str

    port: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["host"] = self.host
        json["port"] = self.port
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> RemoteLocation:
        return cls(
            host=str(json["host"]),
            port=int(json["port"]),
        )


class WindowState(enum.Enum):
    """
    The state of the target window.
    """
    NORMAL = "normal"
    MINIMIZED = "minimized"
    MAXIMIZED = "maximized"
    FULLSCREEN = "fullscreen"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> WindowState:
        return cls(json)


def x_activate_target__mutmut_orig(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.activateTarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_1(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = None
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.activateTarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_2(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.activateTarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_3(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["XXtargetIdXX"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.activateTarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_4(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetid"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.activateTarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_5(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["TARGETID"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.activateTarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_6(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["Targetid"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.activateTarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_7(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_activate_target__mutmut_8(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.activateTarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_9(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.activateTarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_10(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.activateTarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_11(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.activateTargetXX",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_12(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "target.activatetarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_13(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.ACTIVATETARGET",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_14(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.activatetarget",
        "params": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_15(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.activateTarget",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_16(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.activateTarget",
        "PARAMS": params,
    }
    yield cmd_dict


def x_activate_target__mutmut_17(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates (focuses) the target.

    :param target_id:
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.activateTarget",
        "Params": params,
    }
    yield cmd_dict

x_activate_target__mutmut_mutants : ClassVar[MutantDict] = {
'x_activate_target__mutmut_1': x_activate_target__mutmut_1, 
    'x_activate_target__mutmut_2': x_activate_target__mutmut_2, 
    'x_activate_target__mutmut_3': x_activate_target__mutmut_3, 
    'x_activate_target__mutmut_4': x_activate_target__mutmut_4, 
    'x_activate_target__mutmut_5': x_activate_target__mutmut_5, 
    'x_activate_target__mutmut_6': x_activate_target__mutmut_6, 
    'x_activate_target__mutmut_7': x_activate_target__mutmut_7, 
    'x_activate_target__mutmut_8': x_activate_target__mutmut_8, 
    'x_activate_target__mutmut_9': x_activate_target__mutmut_9, 
    'x_activate_target__mutmut_10': x_activate_target__mutmut_10, 
    'x_activate_target__mutmut_11': x_activate_target__mutmut_11, 
    'x_activate_target__mutmut_12': x_activate_target__mutmut_12, 
    'x_activate_target__mutmut_13': x_activate_target__mutmut_13, 
    'x_activate_target__mutmut_14': x_activate_target__mutmut_14, 
    'x_activate_target__mutmut_15': x_activate_target__mutmut_15, 
    'x_activate_target__mutmut_16': x_activate_target__mutmut_16, 
    'x_activate_target__mutmut_17': x_activate_target__mutmut_17
}

def activate_target(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_activate_target__mutmut_orig, x_activate_target__mutmut_mutants, args, kwargs)
    return result 

activate_target.__signature__ = _mutmut_signature(x_activate_target__mutmut_orig)
x_activate_target__mutmut_orig.__name__ = 'x_activate_target'


def x_attach_to_target__mutmut_orig(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_1(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = None
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_2(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = None
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_3(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["XXtargetIdXX"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_4(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetid"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_5(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["TARGETID"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_6(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["Targetid"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_7(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_8(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_9(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["XXflattenXX"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_10(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["FLATTEN"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_11(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["Flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_12(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_13(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_14(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_15(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_16(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.attachToTargetXX",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_17(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "target.attachtotarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_18(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.ATTACHTOTARGET",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_19(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachtotarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_20(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_21(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_22(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "Params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_23(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = None
    return SessionID.from_json(json["sessionId"])


def x_attach_to_target__mutmut_24(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(None)


def x_attach_to_target__mutmut_25(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["XXsessionIdXX"])


def x_attach_to_target__mutmut_26(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionid"])


def x_attach_to_target__mutmut_27(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["SESSIONID"])


def x_attach_to_target__mutmut_28(
    target_id: TargetID,
    flatten: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the target with given id.

    :param target_id:
    :param flatten: *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :returns: Id assigned to the session.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if flatten is not None:
        params["flatten"] = flatten
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToTarget",
        "params": params,
    }
    json = yield cmd_dict
    return SessionID.from_json(json["Sessionid"])

x_attach_to_target__mutmut_mutants : ClassVar[MutantDict] = {
'x_attach_to_target__mutmut_1': x_attach_to_target__mutmut_1, 
    'x_attach_to_target__mutmut_2': x_attach_to_target__mutmut_2, 
    'x_attach_to_target__mutmut_3': x_attach_to_target__mutmut_3, 
    'x_attach_to_target__mutmut_4': x_attach_to_target__mutmut_4, 
    'x_attach_to_target__mutmut_5': x_attach_to_target__mutmut_5, 
    'x_attach_to_target__mutmut_6': x_attach_to_target__mutmut_6, 
    'x_attach_to_target__mutmut_7': x_attach_to_target__mutmut_7, 
    'x_attach_to_target__mutmut_8': x_attach_to_target__mutmut_8, 
    'x_attach_to_target__mutmut_9': x_attach_to_target__mutmut_9, 
    'x_attach_to_target__mutmut_10': x_attach_to_target__mutmut_10, 
    'x_attach_to_target__mutmut_11': x_attach_to_target__mutmut_11, 
    'x_attach_to_target__mutmut_12': x_attach_to_target__mutmut_12, 
    'x_attach_to_target__mutmut_13': x_attach_to_target__mutmut_13, 
    'x_attach_to_target__mutmut_14': x_attach_to_target__mutmut_14, 
    'x_attach_to_target__mutmut_15': x_attach_to_target__mutmut_15, 
    'x_attach_to_target__mutmut_16': x_attach_to_target__mutmut_16, 
    'x_attach_to_target__mutmut_17': x_attach_to_target__mutmut_17, 
    'x_attach_to_target__mutmut_18': x_attach_to_target__mutmut_18, 
    'x_attach_to_target__mutmut_19': x_attach_to_target__mutmut_19, 
    'x_attach_to_target__mutmut_20': x_attach_to_target__mutmut_20, 
    'x_attach_to_target__mutmut_21': x_attach_to_target__mutmut_21, 
    'x_attach_to_target__mutmut_22': x_attach_to_target__mutmut_22, 
    'x_attach_to_target__mutmut_23': x_attach_to_target__mutmut_23, 
    'x_attach_to_target__mutmut_24': x_attach_to_target__mutmut_24, 
    'x_attach_to_target__mutmut_25': x_attach_to_target__mutmut_25, 
    'x_attach_to_target__mutmut_26': x_attach_to_target__mutmut_26, 
    'x_attach_to_target__mutmut_27': x_attach_to_target__mutmut_27, 
    'x_attach_to_target__mutmut_28': x_attach_to_target__mutmut_28
}

def attach_to_target(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_attach_to_target__mutmut_orig, x_attach_to_target__mutmut_mutants, args, kwargs)
    return result 

attach_to_target.__signature__ = _mutmut_signature(x_attach_to_target__mutmut_orig)
x_attach_to_target__mutmut_orig.__name__ = 'x_attach_to_target'


def x_attach_to_browser_target__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToBrowserTarget",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_browser_target__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_browser_target__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.attachToBrowserTarget",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_browser_target__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.attachToBrowserTarget",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_browser_target__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.attachToBrowserTarget",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_browser_target__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.attachToBrowserTargetXX",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_browser_target__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "target.attachtobrowsertarget",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_browser_target__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.ATTACHTOBROWSERTARGET",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_browser_target__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachtobrowsertarget",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionId"])


def x_attach_to_browser_target__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToBrowserTarget",
    }
    json = None
    return SessionID.from_json(json["sessionId"])


def x_attach_to_browser_target__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToBrowserTarget",
    }
    json = yield cmd_dict
    return SessionID.from_json(None)


def x_attach_to_browser_target__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToBrowserTarget",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["XXsessionIdXX"])


def x_attach_to_browser_target__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToBrowserTarget",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["sessionid"])


def x_attach_to_browser_target__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToBrowserTarget",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["SESSIONID"])


def x_attach_to_browser_target__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, SessionID]:
    """
    Attaches to the browser target, only uses flat sessionId mode.

    **EXPERIMENTAL**

    :returns: Id assigned to the session.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.attachToBrowserTarget",
    }
    json = yield cmd_dict
    return SessionID.from_json(json["Sessionid"])

x_attach_to_browser_target__mutmut_mutants : ClassVar[MutantDict] = {
'x_attach_to_browser_target__mutmut_1': x_attach_to_browser_target__mutmut_1, 
    'x_attach_to_browser_target__mutmut_2': x_attach_to_browser_target__mutmut_2, 
    'x_attach_to_browser_target__mutmut_3': x_attach_to_browser_target__mutmut_3, 
    'x_attach_to_browser_target__mutmut_4': x_attach_to_browser_target__mutmut_4, 
    'x_attach_to_browser_target__mutmut_5': x_attach_to_browser_target__mutmut_5, 
    'x_attach_to_browser_target__mutmut_6': x_attach_to_browser_target__mutmut_6, 
    'x_attach_to_browser_target__mutmut_7': x_attach_to_browser_target__mutmut_7, 
    'x_attach_to_browser_target__mutmut_8': x_attach_to_browser_target__mutmut_8, 
    'x_attach_to_browser_target__mutmut_9': x_attach_to_browser_target__mutmut_9, 
    'x_attach_to_browser_target__mutmut_10': x_attach_to_browser_target__mutmut_10, 
    'x_attach_to_browser_target__mutmut_11': x_attach_to_browser_target__mutmut_11, 
    'x_attach_to_browser_target__mutmut_12': x_attach_to_browser_target__mutmut_12, 
    'x_attach_to_browser_target__mutmut_13': x_attach_to_browser_target__mutmut_13, 
    'x_attach_to_browser_target__mutmut_14': x_attach_to_browser_target__mutmut_14
}

def attach_to_browser_target(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_attach_to_browser_target__mutmut_orig, x_attach_to_browser_target__mutmut_mutants, args, kwargs)
    return result 

attach_to_browser_target.__signature__ = _mutmut_signature(x_attach_to_browser_target__mutmut_orig)
x_attach_to_browser_target__mutmut_orig.__name__ = 'x_attach_to_browser_target'


def x_close_target__mutmut_orig(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_1(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = None
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_2(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_3(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["XXtargetIdXX"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_4(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetid"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_5(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["TARGETID"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_6(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["Targetid"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_7(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_8(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_9(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_10(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_11(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.closeTargetXX",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_12(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "target.closetarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_13(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.CLOSETARGET",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_14(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closetarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_15(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_16(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_17(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "Params": params,
    }
    json = yield cmd_dict
    return bool(json["success"])


def x_close_target__mutmut_18(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = None
    return bool(json["success"])


def x_close_target__mutmut_19(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(None)


def x_close_target__mutmut_20(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["XXsuccessXX"])


def x_close_target__mutmut_21(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["SUCCESS"])


def x_close_target__mutmut_22(
    target_id: TargetID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, bool]:
    """
    Closes the target. If the target is a page that gets closed too.

    :param target_id:
    :returns: Always set to true. If an error occurs, the response indicates protocol error.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.closeTarget",
        "params": params,
    }
    json = yield cmd_dict
    return bool(json["Success"])

x_close_target__mutmut_mutants : ClassVar[MutantDict] = {
'x_close_target__mutmut_1': x_close_target__mutmut_1, 
    'x_close_target__mutmut_2': x_close_target__mutmut_2, 
    'x_close_target__mutmut_3': x_close_target__mutmut_3, 
    'x_close_target__mutmut_4': x_close_target__mutmut_4, 
    'x_close_target__mutmut_5': x_close_target__mutmut_5, 
    'x_close_target__mutmut_6': x_close_target__mutmut_6, 
    'x_close_target__mutmut_7': x_close_target__mutmut_7, 
    'x_close_target__mutmut_8': x_close_target__mutmut_8, 
    'x_close_target__mutmut_9': x_close_target__mutmut_9, 
    'x_close_target__mutmut_10': x_close_target__mutmut_10, 
    'x_close_target__mutmut_11': x_close_target__mutmut_11, 
    'x_close_target__mutmut_12': x_close_target__mutmut_12, 
    'x_close_target__mutmut_13': x_close_target__mutmut_13, 
    'x_close_target__mutmut_14': x_close_target__mutmut_14, 
    'x_close_target__mutmut_15': x_close_target__mutmut_15, 
    'x_close_target__mutmut_16': x_close_target__mutmut_16, 
    'x_close_target__mutmut_17': x_close_target__mutmut_17, 
    'x_close_target__mutmut_18': x_close_target__mutmut_18, 
    'x_close_target__mutmut_19': x_close_target__mutmut_19, 
    'x_close_target__mutmut_20': x_close_target__mutmut_20, 
    'x_close_target__mutmut_21': x_close_target__mutmut_21, 
    'x_close_target__mutmut_22': x_close_target__mutmut_22
}

def close_target(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_close_target__mutmut_orig, x_close_target__mutmut_mutants, args, kwargs)
    return result 

close_target.__signature__ = _mutmut_signature(x_close_target__mutmut_orig)
x_close_target__mutmut_orig.__name__ = 'x_close_target'


def x_expose_dev_tools_protocol__mutmut_orig(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_1(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = None
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_2(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = None
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_3(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["XXtargetIdXX"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_4(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetid"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_5(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["TARGETID"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_6(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["Targetid"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_7(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_8(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = None
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_9(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["XXbindingNameXX"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_10(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingname"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_11(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["BINDINGNAME"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_12(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["Bindingname"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_13(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_14(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_15(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["XXinheritPermissionsXX"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_16(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritpermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_17(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["INHERITPERMISSIONS"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_18(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["Inheritpermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_19(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_20(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_21(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_22(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.exposeDevToolsProtocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_23(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.exposeDevToolsProtocolXX",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_24(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "target.exposedevtoolsprotocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_25(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.EXPOSEDEVTOOLSPROTOCOL",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_26(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposedevtoolsprotocol",
        "params": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_27(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_28(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "PARAMS": params,
    }
    yield cmd_dict


def x_expose_dev_tools_protocol__mutmut_29(
    target_id: TargetID,
    binding_name: str | None = None,
    inherit_permissions: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as ``window[bindingName]``.

    The object has the following API:
    - ``binding.send(json)`` - a method to send messages over the remote debugging protocol
    - ``binding.onmessage = json => handleMessage(json)`` - a callback that will be called for the protocol notifications and command responses.

    **EXPERIMENTAL**

    :param target_id:
    :param binding_name: *(Optional)* Binding name, 'cdp' if not specified.
    :param inherit_permissions: *(Optional)* If true, inherits the current root session's permissions (default: false).
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    if binding_name is not None:
        params["bindingName"] = binding_name
    if inherit_permissions is not None:
        params["inheritPermissions"] = inherit_permissions
    cmd_dict: T_JSON_DICT = {
        "method": "Target.exposeDevToolsProtocol",
        "Params": params,
    }
    yield cmd_dict

x_expose_dev_tools_protocol__mutmut_mutants : ClassVar[MutantDict] = {
'x_expose_dev_tools_protocol__mutmut_1': x_expose_dev_tools_protocol__mutmut_1, 
    'x_expose_dev_tools_protocol__mutmut_2': x_expose_dev_tools_protocol__mutmut_2, 
    'x_expose_dev_tools_protocol__mutmut_3': x_expose_dev_tools_protocol__mutmut_3, 
    'x_expose_dev_tools_protocol__mutmut_4': x_expose_dev_tools_protocol__mutmut_4, 
    'x_expose_dev_tools_protocol__mutmut_5': x_expose_dev_tools_protocol__mutmut_5, 
    'x_expose_dev_tools_protocol__mutmut_6': x_expose_dev_tools_protocol__mutmut_6, 
    'x_expose_dev_tools_protocol__mutmut_7': x_expose_dev_tools_protocol__mutmut_7, 
    'x_expose_dev_tools_protocol__mutmut_8': x_expose_dev_tools_protocol__mutmut_8, 
    'x_expose_dev_tools_protocol__mutmut_9': x_expose_dev_tools_protocol__mutmut_9, 
    'x_expose_dev_tools_protocol__mutmut_10': x_expose_dev_tools_protocol__mutmut_10, 
    'x_expose_dev_tools_protocol__mutmut_11': x_expose_dev_tools_protocol__mutmut_11, 
    'x_expose_dev_tools_protocol__mutmut_12': x_expose_dev_tools_protocol__mutmut_12, 
    'x_expose_dev_tools_protocol__mutmut_13': x_expose_dev_tools_protocol__mutmut_13, 
    'x_expose_dev_tools_protocol__mutmut_14': x_expose_dev_tools_protocol__mutmut_14, 
    'x_expose_dev_tools_protocol__mutmut_15': x_expose_dev_tools_protocol__mutmut_15, 
    'x_expose_dev_tools_protocol__mutmut_16': x_expose_dev_tools_protocol__mutmut_16, 
    'x_expose_dev_tools_protocol__mutmut_17': x_expose_dev_tools_protocol__mutmut_17, 
    'x_expose_dev_tools_protocol__mutmut_18': x_expose_dev_tools_protocol__mutmut_18, 
    'x_expose_dev_tools_protocol__mutmut_19': x_expose_dev_tools_protocol__mutmut_19, 
    'x_expose_dev_tools_protocol__mutmut_20': x_expose_dev_tools_protocol__mutmut_20, 
    'x_expose_dev_tools_protocol__mutmut_21': x_expose_dev_tools_protocol__mutmut_21, 
    'x_expose_dev_tools_protocol__mutmut_22': x_expose_dev_tools_protocol__mutmut_22, 
    'x_expose_dev_tools_protocol__mutmut_23': x_expose_dev_tools_protocol__mutmut_23, 
    'x_expose_dev_tools_protocol__mutmut_24': x_expose_dev_tools_protocol__mutmut_24, 
    'x_expose_dev_tools_protocol__mutmut_25': x_expose_dev_tools_protocol__mutmut_25, 
    'x_expose_dev_tools_protocol__mutmut_26': x_expose_dev_tools_protocol__mutmut_26, 
    'x_expose_dev_tools_protocol__mutmut_27': x_expose_dev_tools_protocol__mutmut_27, 
    'x_expose_dev_tools_protocol__mutmut_28': x_expose_dev_tools_protocol__mutmut_28, 
    'x_expose_dev_tools_protocol__mutmut_29': x_expose_dev_tools_protocol__mutmut_29
}

def expose_dev_tools_protocol(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_expose_dev_tools_protocol__mutmut_orig, x_expose_dev_tools_protocol__mutmut_mutants, args, kwargs)
    return result 

expose_dev_tools_protocol.__signature__ = _mutmut_signature(x_expose_dev_tools_protocol__mutmut_orig)
x_expose_dev_tools_protocol__mutmut_orig.__name__ = 'x_expose_dev_tools_protocol'


def x_create_browser_context__mutmut_orig(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_1(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = None
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_2(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_3(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = None
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_4(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["XXdisposeOnDetachXX"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_5(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeondetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_6(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["DISPOSEONDETACH"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_7(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["Disposeondetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_8(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_9(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = None
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_10(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["XXproxyServerXX"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_11(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyserver"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_12(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["PROXYSERVER"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_13(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["Proxyserver"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_14(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_15(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = None
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_16(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["XXproxyBypassListXX"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_17(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxybypasslist"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_18(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["PROXYBYPASSLIST"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_19(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["Proxybypasslist"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_20(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_21(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_22(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["XXoriginsWithUniversalNetworkAccessXX"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_23(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originswithuniversalnetworkaccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_24(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["ORIGINSWITHUNIVERSALNETWORKACCESS"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_25(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["Originswithuniversalnetworkaccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_26(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(None)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_27(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_28(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_29(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_30(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_31(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.createBrowserContextXX",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_32(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "target.createbrowsercontext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_33(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.CREATEBROWSERCONTEXT",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_34(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createbrowsercontext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_35(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_36(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_37(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "Params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_38(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = None
    return browser.BrowserContextID.from_json(json["browserContextId"])


def x_create_browser_context__mutmut_39(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(None)


def x_create_browser_context__mutmut_40(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["XXbrowserContextIdXX"])


def x_create_browser_context__mutmut_41(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["browsercontextid"])


def x_create_browser_context__mutmut_42(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["BROWSERCONTEXTID"])


def x_create_browser_context__mutmut_43(
    dispose_on_detach: bool | None = None,
    proxy_server: str | None = None,
    proxy_bypass_list: str | None = None,
    origins_with_universal_network_access: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, browser.BrowserContextID]:
    """
    Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one.

    :param dispose_on_detach: **(EXPERIMENTAL)** *(Optional)* If specified, disposes this context when debugging session disconnects.
    :param proxy_server: **(EXPERIMENTAL)** *(Optional)* Proxy server, similar to the one passed to --proxy-server
    :param proxy_bypass_list: **(EXPERIMENTAL)** *(Optional)* Proxy bypass list, similar to the one passed to --proxy-bypass-list
    :param origins_with_universal_network_access: **(EXPERIMENTAL)** *(Optional)* An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
    :returns: The id of the context created.
    """
    params: T_JSON_DICT = {}
    if dispose_on_detach is not None:
        params["disposeOnDetach"] = dispose_on_detach
    if proxy_server is not None:
        params["proxyServer"] = proxy_server
    if proxy_bypass_list is not None:
        params["proxyBypassList"] = proxy_bypass_list
    if origins_with_universal_network_access is not None:
        params["originsWithUniversalNetworkAccess"] = list(origins_with_universal_network_access)
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createBrowserContext",
        "params": params,
    }
    json = yield cmd_dict
    return browser.BrowserContextID.from_json(json["Browsercontextid"])

x_create_browser_context__mutmut_mutants : ClassVar[MutantDict] = {
'x_create_browser_context__mutmut_1': x_create_browser_context__mutmut_1, 
    'x_create_browser_context__mutmut_2': x_create_browser_context__mutmut_2, 
    'x_create_browser_context__mutmut_3': x_create_browser_context__mutmut_3, 
    'x_create_browser_context__mutmut_4': x_create_browser_context__mutmut_4, 
    'x_create_browser_context__mutmut_5': x_create_browser_context__mutmut_5, 
    'x_create_browser_context__mutmut_6': x_create_browser_context__mutmut_6, 
    'x_create_browser_context__mutmut_7': x_create_browser_context__mutmut_7, 
    'x_create_browser_context__mutmut_8': x_create_browser_context__mutmut_8, 
    'x_create_browser_context__mutmut_9': x_create_browser_context__mutmut_9, 
    'x_create_browser_context__mutmut_10': x_create_browser_context__mutmut_10, 
    'x_create_browser_context__mutmut_11': x_create_browser_context__mutmut_11, 
    'x_create_browser_context__mutmut_12': x_create_browser_context__mutmut_12, 
    'x_create_browser_context__mutmut_13': x_create_browser_context__mutmut_13, 
    'x_create_browser_context__mutmut_14': x_create_browser_context__mutmut_14, 
    'x_create_browser_context__mutmut_15': x_create_browser_context__mutmut_15, 
    'x_create_browser_context__mutmut_16': x_create_browser_context__mutmut_16, 
    'x_create_browser_context__mutmut_17': x_create_browser_context__mutmut_17, 
    'x_create_browser_context__mutmut_18': x_create_browser_context__mutmut_18, 
    'x_create_browser_context__mutmut_19': x_create_browser_context__mutmut_19, 
    'x_create_browser_context__mutmut_20': x_create_browser_context__mutmut_20, 
    'x_create_browser_context__mutmut_21': x_create_browser_context__mutmut_21, 
    'x_create_browser_context__mutmut_22': x_create_browser_context__mutmut_22, 
    'x_create_browser_context__mutmut_23': x_create_browser_context__mutmut_23, 
    'x_create_browser_context__mutmut_24': x_create_browser_context__mutmut_24, 
    'x_create_browser_context__mutmut_25': x_create_browser_context__mutmut_25, 
    'x_create_browser_context__mutmut_26': x_create_browser_context__mutmut_26, 
    'x_create_browser_context__mutmut_27': x_create_browser_context__mutmut_27, 
    'x_create_browser_context__mutmut_28': x_create_browser_context__mutmut_28, 
    'x_create_browser_context__mutmut_29': x_create_browser_context__mutmut_29, 
    'x_create_browser_context__mutmut_30': x_create_browser_context__mutmut_30, 
    'x_create_browser_context__mutmut_31': x_create_browser_context__mutmut_31, 
    'x_create_browser_context__mutmut_32': x_create_browser_context__mutmut_32, 
    'x_create_browser_context__mutmut_33': x_create_browser_context__mutmut_33, 
    'x_create_browser_context__mutmut_34': x_create_browser_context__mutmut_34, 
    'x_create_browser_context__mutmut_35': x_create_browser_context__mutmut_35, 
    'x_create_browser_context__mutmut_36': x_create_browser_context__mutmut_36, 
    'x_create_browser_context__mutmut_37': x_create_browser_context__mutmut_37, 
    'x_create_browser_context__mutmut_38': x_create_browser_context__mutmut_38, 
    'x_create_browser_context__mutmut_39': x_create_browser_context__mutmut_39, 
    'x_create_browser_context__mutmut_40': x_create_browser_context__mutmut_40, 
    'x_create_browser_context__mutmut_41': x_create_browser_context__mutmut_41, 
    'x_create_browser_context__mutmut_42': x_create_browser_context__mutmut_42, 
    'x_create_browser_context__mutmut_43': x_create_browser_context__mutmut_43
}

def create_browser_context(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_create_browser_context__mutmut_orig, x_create_browser_context__mutmut_mutants, args, kwargs)
    return result 

create_browser_context.__signature__ = _mutmut_signature(x_create_browser_context__mutmut_orig)
x_create_browser_context__mutmut_orig.__name__ = 'x_create_browser_context'


def x_get_browser_contexts__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getBrowserContexts",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["browserContextIds"]]


def x_get_browser_contexts__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["browserContextIds"]]


def x_get_browser_contexts__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.getBrowserContexts",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["browserContextIds"]]


def x_get_browser_contexts__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.getBrowserContexts",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["browserContextIds"]]


def x_get_browser_contexts__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.getBrowserContexts",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["browserContextIds"]]


def x_get_browser_contexts__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.getBrowserContextsXX",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["browserContextIds"]]


def x_get_browser_contexts__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "target.getbrowsercontexts",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["browserContextIds"]]


def x_get_browser_contexts__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.GETBROWSERCONTEXTS",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["browserContextIds"]]


def x_get_browser_contexts__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getbrowsercontexts",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["browserContextIds"]]


def x_get_browser_contexts__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getBrowserContexts",
    }
    json = None
    return [browser.BrowserContextID.from_json(i) for i in json["browserContextIds"]]


def x_get_browser_contexts__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getBrowserContexts",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(None) for i in json["browserContextIds"]]


def x_get_browser_contexts__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getBrowserContexts",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["XXbrowserContextIdsXX"]]


def x_get_browser_contexts__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getBrowserContexts",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["browsercontextids"]]


def x_get_browser_contexts__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getBrowserContexts",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["BROWSERCONTEXTIDS"]]


def x_get_browser_contexts__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, list[browser.BrowserContextID]]:
    """
    Returns all browser contexts created with ``Target.createBrowserContext`` method.

    :returns: An array of browser context ids.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getBrowserContexts",
    }
    json = yield cmd_dict
    return [browser.BrowserContextID.from_json(i) for i in json["Browsercontextids"]]

x_get_browser_contexts__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_browser_contexts__mutmut_1': x_get_browser_contexts__mutmut_1, 
    'x_get_browser_contexts__mutmut_2': x_get_browser_contexts__mutmut_2, 
    'x_get_browser_contexts__mutmut_3': x_get_browser_contexts__mutmut_3, 
    'x_get_browser_contexts__mutmut_4': x_get_browser_contexts__mutmut_4, 
    'x_get_browser_contexts__mutmut_5': x_get_browser_contexts__mutmut_5, 
    'x_get_browser_contexts__mutmut_6': x_get_browser_contexts__mutmut_6, 
    'x_get_browser_contexts__mutmut_7': x_get_browser_contexts__mutmut_7, 
    'x_get_browser_contexts__mutmut_8': x_get_browser_contexts__mutmut_8, 
    'x_get_browser_contexts__mutmut_9': x_get_browser_contexts__mutmut_9, 
    'x_get_browser_contexts__mutmut_10': x_get_browser_contexts__mutmut_10, 
    'x_get_browser_contexts__mutmut_11': x_get_browser_contexts__mutmut_11, 
    'x_get_browser_contexts__mutmut_12': x_get_browser_contexts__mutmut_12, 
    'x_get_browser_contexts__mutmut_13': x_get_browser_contexts__mutmut_13, 
    'x_get_browser_contexts__mutmut_14': x_get_browser_contexts__mutmut_14
}

def get_browser_contexts(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_browser_contexts__mutmut_orig, x_get_browser_contexts__mutmut_mutants, args, kwargs)
    return result 

get_browser_contexts.__signature__ = _mutmut_signature(x_get_browser_contexts__mutmut_orig)
x_get_browser_contexts__mutmut_orig.__name__ = 'x_get_browser_contexts'


def x_create_target__mutmut_orig(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_1(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = None
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_2(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = None
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_3(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["XXurlXX"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_4(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["URL"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_5(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["Url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_6(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_7(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = None
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_8(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["XXleftXX"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_9(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["LEFT"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_10(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["Left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_11(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_12(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = None
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_13(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["XXtopXX"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_14(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["TOP"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_15(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["Top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_16(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_17(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = None
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_18(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["XXwidthXX"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_19(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["WIDTH"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_20(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["Width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_21(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_22(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = None
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_23(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["XXheightXX"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_24(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["HEIGHT"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_25(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["Height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_26(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_27(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = None
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_28(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["XXwindowStateXX"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_29(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowstate"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_30(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["WINDOWSTATE"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_31(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["Windowstate"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_32(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_33(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = None
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_34(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["XXbrowserContextIdXX"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_35(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browsercontextid"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_36(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["BROWSERCONTEXTID"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_37(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["Browsercontextid"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_38(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_39(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = None
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_40(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["XXenableBeginFrameControlXX"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_41(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enablebeginframecontrol"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_42(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["ENABLEBEGINFRAMECONTROL"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_43(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["Enablebeginframecontrol"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_44(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_45(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = None
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_46(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["XXnewWindowXX"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_47(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newwindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_48(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["NEWWINDOW"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_49(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["Newwindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_50(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_51(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = None
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_52(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["XXbackgroundXX"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_53(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["BACKGROUND"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_54(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["Background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_55(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_56(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_57(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["XXforTabXX"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_58(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["fortab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_59(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["FORTAB"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_60(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["Fortab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_61(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_62(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_63(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_64(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_65(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.createTargetXX",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_66(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "target.createtarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_67(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.CREATETARGET",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_68(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createtarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_69(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_70(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_71(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "Params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_72(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = None
    return TargetID.from_json(json["targetId"])


def x_create_target__mutmut_73(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(None)


def x_create_target__mutmut_74(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["XXtargetIdXX"])


def x_create_target__mutmut_75(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["targetid"])


def x_create_target__mutmut_76(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["TARGETID"])


def x_create_target__mutmut_77(
    url: str,
    left: int | None = None,
    top: int | None = None,
    width: int | None = None,
    height: int | None = None,
    window_state: WindowState | None = None,
    browser_context_id: browser.BrowserContextID | None = None,
    enable_begin_frame_control: bool | None = None,
    new_window: bool | None = None,
    background: bool | None = None,
    for_tab: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetID]:
    """
    Creates a new page.

    :param url: The initial URL the page will be navigated to. An empty string indicates about:blank.
    :param left: **(EXPERIMENTAL)** *(Optional)* Frame left origin in DIP (requires newWindow to be true or headless shell).
    :param top: **(EXPERIMENTAL)** *(Optional)* Frame top origin in DIP (requires newWindow to be true or headless shell).
    :param width: *(Optional)* Frame width in DIP (requires newWindow to be true or headless shell).
    :param height: *(Optional)* Frame height in DIP (requires newWindow to be true or headless shell).
    :param window_state: *(Optional)* Frame window state (requires newWindow to be true or headless shell). Default is normal.
    :param browser_context_id: **(EXPERIMENTAL)** *(Optional)* The browser context to create the page in.
    :param enable_begin_frame_control: **(EXPERIMENTAL)** *(Optional)* Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
    :param new_window: *(Optional)* Whether to create a new Window or Tab (false by default, not supported by headless shell).
    :param background: *(Optional)* Whether to create the target in background or foreground (false by default, not supported by headless shell).
    :param for_tab: **(EXPERIMENTAL)** *(Optional)* Whether to create the target of type "tab".
    :returns: The id of the page opened.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if left is not None:
        params["left"] = left
    if top is not None:
        params["top"] = top
    if width is not None:
        params["width"] = width
    if height is not None:
        params["height"] = height
    if window_state is not None:
        params["windowState"] = window_state.to_json()
    if browser_context_id is not None:
        params["browserContextId"] = browser_context_id.to_json()
    if enable_begin_frame_control is not None:
        params["enableBeginFrameControl"] = enable_begin_frame_control
    if new_window is not None:
        params["newWindow"] = new_window
    if background is not None:
        params["background"] = background
    if for_tab is not None:
        params["forTab"] = for_tab
    cmd_dict: T_JSON_DICT = {
        "method": "Target.createTarget",
        "params": params,
    }
    json = yield cmd_dict
    return TargetID.from_json(json["Targetid"])

x_create_target__mutmut_mutants : ClassVar[MutantDict] = {
'x_create_target__mutmut_1': x_create_target__mutmut_1, 
    'x_create_target__mutmut_2': x_create_target__mutmut_2, 
    'x_create_target__mutmut_3': x_create_target__mutmut_3, 
    'x_create_target__mutmut_4': x_create_target__mutmut_4, 
    'x_create_target__mutmut_5': x_create_target__mutmut_5, 
    'x_create_target__mutmut_6': x_create_target__mutmut_6, 
    'x_create_target__mutmut_7': x_create_target__mutmut_7, 
    'x_create_target__mutmut_8': x_create_target__mutmut_8, 
    'x_create_target__mutmut_9': x_create_target__mutmut_9, 
    'x_create_target__mutmut_10': x_create_target__mutmut_10, 
    'x_create_target__mutmut_11': x_create_target__mutmut_11, 
    'x_create_target__mutmut_12': x_create_target__mutmut_12, 
    'x_create_target__mutmut_13': x_create_target__mutmut_13, 
    'x_create_target__mutmut_14': x_create_target__mutmut_14, 
    'x_create_target__mutmut_15': x_create_target__mutmut_15, 
    'x_create_target__mutmut_16': x_create_target__mutmut_16, 
    'x_create_target__mutmut_17': x_create_target__mutmut_17, 
    'x_create_target__mutmut_18': x_create_target__mutmut_18, 
    'x_create_target__mutmut_19': x_create_target__mutmut_19, 
    'x_create_target__mutmut_20': x_create_target__mutmut_20, 
    'x_create_target__mutmut_21': x_create_target__mutmut_21, 
    'x_create_target__mutmut_22': x_create_target__mutmut_22, 
    'x_create_target__mutmut_23': x_create_target__mutmut_23, 
    'x_create_target__mutmut_24': x_create_target__mutmut_24, 
    'x_create_target__mutmut_25': x_create_target__mutmut_25, 
    'x_create_target__mutmut_26': x_create_target__mutmut_26, 
    'x_create_target__mutmut_27': x_create_target__mutmut_27, 
    'x_create_target__mutmut_28': x_create_target__mutmut_28, 
    'x_create_target__mutmut_29': x_create_target__mutmut_29, 
    'x_create_target__mutmut_30': x_create_target__mutmut_30, 
    'x_create_target__mutmut_31': x_create_target__mutmut_31, 
    'x_create_target__mutmut_32': x_create_target__mutmut_32, 
    'x_create_target__mutmut_33': x_create_target__mutmut_33, 
    'x_create_target__mutmut_34': x_create_target__mutmut_34, 
    'x_create_target__mutmut_35': x_create_target__mutmut_35, 
    'x_create_target__mutmut_36': x_create_target__mutmut_36, 
    'x_create_target__mutmut_37': x_create_target__mutmut_37, 
    'x_create_target__mutmut_38': x_create_target__mutmut_38, 
    'x_create_target__mutmut_39': x_create_target__mutmut_39, 
    'x_create_target__mutmut_40': x_create_target__mutmut_40, 
    'x_create_target__mutmut_41': x_create_target__mutmut_41, 
    'x_create_target__mutmut_42': x_create_target__mutmut_42, 
    'x_create_target__mutmut_43': x_create_target__mutmut_43, 
    'x_create_target__mutmut_44': x_create_target__mutmut_44, 
    'x_create_target__mutmut_45': x_create_target__mutmut_45, 
    'x_create_target__mutmut_46': x_create_target__mutmut_46, 
    'x_create_target__mutmut_47': x_create_target__mutmut_47, 
    'x_create_target__mutmut_48': x_create_target__mutmut_48, 
    'x_create_target__mutmut_49': x_create_target__mutmut_49, 
    'x_create_target__mutmut_50': x_create_target__mutmut_50, 
    'x_create_target__mutmut_51': x_create_target__mutmut_51, 
    'x_create_target__mutmut_52': x_create_target__mutmut_52, 
    'x_create_target__mutmut_53': x_create_target__mutmut_53, 
    'x_create_target__mutmut_54': x_create_target__mutmut_54, 
    'x_create_target__mutmut_55': x_create_target__mutmut_55, 
    'x_create_target__mutmut_56': x_create_target__mutmut_56, 
    'x_create_target__mutmut_57': x_create_target__mutmut_57, 
    'x_create_target__mutmut_58': x_create_target__mutmut_58, 
    'x_create_target__mutmut_59': x_create_target__mutmut_59, 
    'x_create_target__mutmut_60': x_create_target__mutmut_60, 
    'x_create_target__mutmut_61': x_create_target__mutmut_61, 
    'x_create_target__mutmut_62': x_create_target__mutmut_62, 
    'x_create_target__mutmut_63': x_create_target__mutmut_63, 
    'x_create_target__mutmut_64': x_create_target__mutmut_64, 
    'x_create_target__mutmut_65': x_create_target__mutmut_65, 
    'x_create_target__mutmut_66': x_create_target__mutmut_66, 
    'x_create_target__mutmut_67': x_create_target__mutmut_67, 
    'x_create_target__mutmut_68': x_create_target__mutmut_68, 
    'x_create_target__mutmut_69': x_create_target__mutmut_69, 
    'x_create_target__mutmut_70': x_create_target__mutmut_70, 
    'x_create_target__mutmut_71': x_create_target__mutmut_71, 
    'x_create_target__mutmut_72': x_create_target__mutmut_72, 
    'x_create_target__mutmut_73': x_create_target__mutmut_73, 
    'x_create_target__mutmut_74': x_create_target__mutmut_74, 
    'x_create_target__mutmut_75': x_create_target__mutmut_75, 
    'x_create_target__mutmut_76': x_create_target__mutmut_76, 
    'x_create_target__mutmut_77': x_create_target__mutmut_77
}

def create_target(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_create_target__mutmut_orig, x_create_target__mutmut_mutants, args, kwargs)
    return result 

create_target.__signature__ = _mutmut_signature(x_create_target__mutmut_orig)
x_create_target__mutmut_orig.__name__ = 'x_create_target'


def x_detach_from_target__mutmut_orig(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_1(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = None
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_2(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_3(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = None
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_4(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["XXsessionIdXX"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_5(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionid"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_6(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["SESSIONID"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_7(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["Sessionid"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_8(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_9(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_10(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["XXtargetIdXX"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_11(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetid"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_12(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["TARGETID"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_13(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["Targetid"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_14(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_detach_from_target__mutmut_15(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_16(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_17(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.detachFromTarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_18(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.detachFromTargetXX",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_19(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "target.detachfromtarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_20(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.DETACHFROMTARGET",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_21(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachfromtarget",
        "params": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_22(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_23(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "PARAMS": params,
    }
    yield cmd_dict


def x_detach_from_target__mutmut_24(
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Detaches session with given id.

    :param session_id: *(Optional)* Session to detach.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.detachFromTarget",
        "Params": params,
    }
    yield cmd_dict

x_detach_from_target__mutmut_mutants : ClassVar[MutantDict] = {
'x_detach_from_target__mutmut_1': x_detach_from_target__mutmut_1, 
    'x_detach_from_target__mutmut_2': x_detach_from_target__mutmut_2, 
    'x_detach_from_target__mutmut_3': x_detach_from_target__mutmut_3, 
    'x_detach_from_target__mutmut_4': x_detach_from_target__mutmut_4, 
    'x_detach_from_target__mutmut_5': x_detach_from_target__mutmut_5, 
    'x_detach_from_target__mutmut_6': x_detach_from_target__mutmut_6, 
    'x_detach_from_target__mutmut_7': x_detach_from_target__mutmut_7, 
    'x_detach_from_target__mutmut_8': x_detach_from_target__mutmut_8, 
    'x_detach_from_target__mutmut_9': x_detach_from_target__mutmut_9, 
    'x_detach_from_target__mutmut_10': x_detach_from_target__mutmut_10, 
    'x_detach_from_target__mutmut_11': x_detach_from_target__mutmut_11, 
    'x_detach_from_target__mutmut_12': x_detach_from_target__mutmut_12, 
    'x_detach_from_target__mutmut_13': x_detach_from_target__mutmut_13, 
    'x_detach_from_target__mutmut_14': x_detach_from_target__mutmut_14, 
    'x_detach_from_target__mutmut_15': x_detach_from_target__mutmut_15, 
    'x_detach_from_target__mutmut_16': x_detach_from_target__mutmut_16, 
    'x_detach_from_target__mutmut_17': x_detach_from_target__mutmut_17, 
    'x_detach_from_target__mutmut_18': x_detach_from_target__mutmut_18, 
    'x_detach_from_target__mutmut_19': x_detach_from_target__mutmut_19, 
    'x_detach_from_target__mutmut_20': x_detach_from_target__mutmut_20, 
    'x_detach_from_target__mutmut_21': x_detach_from_target__mutmut_21, 
    'x_detach_from_target__mutmut_22': x_detach_from_target__mutmut_22, 
    'x_detach_from_target__mutmut_23': x_detach_from_target__mutmut_23, 
    'x_detach_from_target__mutmut_24': x_detach_from_target__mutmut_24
}

def detach_from_target(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_detach_from_target__mutmut_orig, x_detach_from_target__mutmut_mutants, args, kwargs)
    return result 

detach_from_target.__signature__ = _mutmut_signature(x_detach_from_target__mutmut_orig)
x_detach_from_target__mutmut_orig.__name__ = 'x_detach_from_target'


def x_dispose_browser_context__mutmut_orig(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.disposeBrowserContext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_1(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = None
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.disposeBrowserContext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_2(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.disposeBrowserContext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_3(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["XXbrowserContextIdXX"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.disposeBrowserContext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_4(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browsercontextid"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.disposeBrowserContext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_5(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["BROWSERCONTEXTID"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.disposeBrowserContext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_6(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["Browsercontextid"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.disposeBrowserContext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_7(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_dispose_browser_context__mutmut_8(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.disposeBrowserContext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_9(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.disposeBrowserContext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_10(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.disposeBrowserContext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_11(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.disposeBrowserContextXX",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_12(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "target.disposebrowsercontext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_13(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.DISPOSEBROWSERCONTEXT",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_14(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.disposebrowsercontext",
        "params": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_15(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.disposeBrowserContext",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_16(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.disposeBrowserContext",
        "PARAMS": params,
    }
    yield cmd_dict


def x_dispose_browser_context__mutmut_17(
    browser_context_id: browser.BrowserContextID,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks.

    :param browser_context_id:
    """
    params: T_JSON_DICT = {}
    params["browserContextId"] = browser_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.disposeBrowserContext",
        "Params": params,
    }
    yield cmd_dict

x_dispose_browser_context__mutmut_mutants : ClassVar[MutantDict] = {
'x_dispose_browser_context__mutmut_1': x_dispose_browser_context__mutmut_1, 
    'x_dispose_browser_context__mutmut_2': x_dispose_browser_context__mutmut_2, 
    'x_dispose_browser_context__mutmut_3': x_dispose_browser_context__mutmut_3, 
    'x_dispose_browser_context__mutmut_4': x_dispose_browser_context__mutmut_4, 
    'x_dispose_browser_context__mutmut_5': x_dispose_browser_context__mutmut_5, 
    'x_dispose_browser_context__mutmut_6': x_dispose_browser_context__mutmut_6, 
    'x_dispose_browser_context__mutmut_7': x_dispose_browser_context__mutmut_7, 
    'x_dispose_browser_context__mutmut_8': x_dispose_browser_context__mutmut_8, 
    'x_dispose_browser_context__mutmut_9': x_dispose_browser_context__mutmut_9, 
    'x_dispose_browser_context__mutmut_10': x_dispose_browser_context__mutmut_10, 
    'x_dispose_browser_context__mutmut_11': x_dispose_browser_context__mutmut_11, 
    'x_dispose_browser_context__mutmut_12': x_dispose_browser_context__mutmut_12, 
    'x_dispose_browser_context__mutmut_13': x_dispose_browser_context__mutmut_13, 
    'x_dispose_browser_context__mutmut_14': x_dispose_browser_context__mutmut_14, 
    'x_dispose_browser_context__mutmut_15': x_dispose_browser_context__mutmut_15, 
    'x_dispose_browser_context__mutmut_16': x_dispose_browser_context__mutmut_16, 
    'x_dispose_browser_context__mutmut_17': x_dispose_browser_context__mutmut_17
}

def dispose_browser_context(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_dispose_browser_context__mutmut_orig, x_dispose_browser_context__mutmut_mutants, args, kwargs)
    return result 

dispose_browser_context.__signature__ = _mutmut_signature(x_dispose_browser_context__mutmut_orig)
x_dispose_browser_context__mutmut_orig.__name__ = 'x_dispose_browser_context'


def x_get_target_info__mutmut_orig(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_1(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = None
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_2(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_3(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_4(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["XXtargetIdXX"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_5(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetid"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_6(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["TARGETID"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_7(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["Targetid"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_8(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_9(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_10(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_11(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_12(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.getTargetInfoXX",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_13(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "target.gettargetinfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_14(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.GETTARGETINFO",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_15(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.gettargetinfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_16(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_17(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_18(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "Params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_19(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = None
    return TargetInfo.from_json(json["targetInfo"])


def x_get_target_info__mutmut_20(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(None)


def x_get_target_info__mutmut_21(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["XXtargetInfoXX"])


def x_get_target_info__mutmut_22(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["targetinfo"])


def x_get_target_info__mutmut_23(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["TARGETINFO"])


def x_get_target_info__mutmut_24(
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, TargetInfo]:
    """
    Returns information about a target.

    **EXPERIMENTAL**

    :param target_id: *(Optional)*
    :returns:
    """
    params: T_JSON_DICT = {}
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargetInfo",
        "params": params,
    }
    json = yield cmd_dict
    return TargetInfo.from_json(json["Targetinfo"])

x_get_target_info__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_target_info__mutmut_1': x_get_target_info__mutmut_1, 
    'x_get_target_info__mutmut_2': x_get_target_info__mutmut_2, 
    'x_get_target_info__mutmut_3': x_get_target_info__mutmut_3, 
    'x_get_target_info__mutmut_4': x_get_target_info__mutmut_4, 
    'x_get_target_info__mutmut_5': x_get_target_info__mutmut_5, 
    'x_get_target_info__mutmut_6': x_get_target_info__mutmut_6, 
    'x_get_target_info__mutmut_7': x_get_target_info__mutmut_7, 
    'x_get_target_info__mutmut_8': x_get_target_info__mutmut_8, 
    'x_get_target_info__mutmut_9': x_get_target_info__mutmut_9, 
    'x_get_target_info__mutmut_10': x_get_target_info__mutmut_10, 
    'x_get_target_info__mutmut_11': x_get_target_info__mutmut_11, 
    'x_get_target_info__mutmut_12': x_get_target_info__mutmut_12, 
    'x_get_target_info__mutmut_13': x_get_target_info__mutmut_13, 
    'x_get_target_info__mutmut_14': x_get_target_info__mutmut_14, 
    'x_get_target_info__mutmut_15': x_get_target_info__mutmut_15, 
    'x_get_target_info__mutmut_16': x_get_target_info__mutmut_16, 
    'x_get_target_info__mutmut_17': x_get_target_info__mutmut_17, 
    'x_get_target_info__mutmut_18': x_get_target_info__mutmut_18, 
    'x_get_target_info__mutmut_19': x_get_target_info__mutmut_19, 
    'x_get_target_info__mutmut_20': x_get_target_info__mutmut_20, 
    'x_get_target_info__mutmut_21': x_get_target_info__mutmut_21, 
    'x_get_target_info__mutmut_22': x_get_target_info__mutmut_22, 
    'x_get_target_info__mutmut_23': x_get_target_info__mutmut_23, 
    'x_get_target_info__mutmut_24': x_get_target_info__mutmut_24
}

def get_target_info(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_target_info__mutmut_orig, x_get_target_info__mutmut_mutants, args, kwargs)
    return result 

get_target_info.__signature__ = _mutmut_signature(x_get_target_info__mutmut_orig)
x_get_target_info__mutmut_orig.__name__ = 'x_get_target_info'


def x_get_targets__mutmut_orig(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_1(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = None
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_2(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_3(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_4(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["XXfilterXX"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_5(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["FILTER"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_6(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["Filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_7(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_8(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_9(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_10(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_11(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.getTargetsXX",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_12(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "target.gettargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_13(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.GETTARGETS",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_14(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.gettargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_15(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_16(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_17(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "Params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_18(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = None
    return [TargetInfo.from_json(i) for i in json["targetInfos"]]


def x_get_targets__mutmut_19(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(None) for i in json["targetInfos"]]


def x_get_targets__mutmut_20(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["XXtargetInfosXX"]]


def x_get_targets__mutmut_21(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["targetinfos"]]


def x_get_targets__mutmut_22(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["TARGETINFOS"]]


def x_get_targets__mutmut_23(
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[TargetInfo]]:
    """
    Retrieves a list of available targets.

    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
    :returns: The list of targets.
    """
    params: T_JSON_DICT = {}
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.getTargets",
        "params": params,
    }
    json = yield cmd_dict
    return [TargetInfo.from_json(i) for i in json["Targetinfos"]]

x_get_targets__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_targets__mutmut_1': x_get_targets__mutmut_1, 
    'x_get_targets__mutmut_2': x_get_targets__mutmut_2, 
    'x_get_targets__mutmut_3': x_get_targets__mutmut_3, 
    'x_get_targets__mutmut_4': x_get_targets__mutmut_4, 
    'x_get_targets__mutmut_5': x_get_targets__mutmut_5, 
    'x_get_targets__mutmut_6': x_get_targets__mutmut_6, 
    'x_get_targets__mutmut_7': x_get_targets__mutmut_7, 
    'x_get_targets__mutmut_8': x_get_targets__mutmut_8, 
    'x_get_targets__mutmut_9': x_get_targets__mutmut_9, 
    'x_get_targets__mutmut_10': x_get_targets__mutmut_10, 
    'x_get_targets__mutmut_11': x_get_targets__mutmut_11, 
    'x_get_targets__mutmut_12': x_get_targets__mutmut_12, 
    'x_get_targets__mutmut_13': x_get_targets__mutmut_13, 
    'x_get_targets__mutmut_14': x_get_targets__mutmut_14, 
    'x_get_targets__mutmut_15': x_get_targets__mutmut_15, 
    'x_get_targets__mutmut_16': x_get_targets__mutmut_16, 
    'x_get_targets__mutmut_17': x_get_targets__mutmut_17, 
    'x_get_targets__mutmut_18': x_get_targets__mutmut_18, 
    'x_get_targets__mutmut_19': x_get_targets__mutmut_19, 
    'x_get_targets__mutmut_20': x_get_targets__mutmut_20, 
    'x_get_targets__mutmut_21': x_get_targets__mutmut_21, 
    'x_get_targets__mutmut_22': x_get_targets__mutmut_22, 
    'x_get_targets__mutmut_23': x_get_targets__mutmut_23
}

def get_targets(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_targets__mutmut_orig, x_get_targets__mutmut_mutants, args, kwargs)
    return result 

get_targets.__signature__ = _mutmut_signature(x_get_targets__mutmut_orig)
x_get_targets__mutmut_orig.__name__ = 'x_get_targets'


def x_send_message_to_target__mutmut_orig(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_1(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = None
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_2(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = None
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_3(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["XXmessageXX"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_4(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["MESSAGE"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_5(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["Message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_6(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_7(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = None
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_8(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["XXsessionIdXX"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_9(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionid"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_10(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["SESSIONID"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_11(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["Sessionid"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_12(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_13(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_14(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["XXtargetIdXX"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_15(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetid"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_16(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["TARGETID"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_17(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["Targetid"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_18(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_send_message_to_target__mutmut_19(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_20(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_21(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.sendMessageToTarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_22(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.sendMessageToTargetXX",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_23(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "target.sendmessagetotarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_24(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.SENDMESSAGETOTARGET",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_25(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendmessagetotarget",
        "params": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_26(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_27(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "PARAMS": params,
    }
    yield cmd_dict


def x_send_message_to_target__mutmut_28(
    message: str,
    session_id: SessionID | None = None,
    target_id: TargetID | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325.

    :param message:
    :param session_id: *(Optional)* Identifier of the session.
    :param target_id: *(Optional)* Deprecated.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if session_id is not None:
        params["sessionId"] = session_id.to_json()
    if target_id is not None:
        params["targetId"] = target_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.sendMessageToTarget",
        "Params": params,
    }
    yield cmd_dict

x_send_message_to_target__mutmut_mutants : ClassVar[MutantDict] = {
'x_send_message_to_target__mutmut_1': x_send_message_to_target__mutmut_1, 
    'x_send_message_to_target__mutmut_2': x_send_message_to_target__mutmut_2, 
    'x_send_message_to_target__mutmut_3': x_send_message_to_target__mutmut_3, 
    'x_send_message_to_target__mutmut_4': x_send_message_to_target__mutmut_4, 
    'x_send_message_to_target__mutmut_5': x_send_message_to_target__mutmut_5, 
    'x_send_message_to_target__mutmut_6': x_send_message_to_target__mutmut_6, 
    'x_send_message_to_target__mutmut_7': x_send_message_to_target__mutmut_7, 
    'x_send_message_to_target__mutmut_8': x_send_message_to_target__mutmut_8, 
    'x_send_message_to_target__mutmut_9': x_send_message_to_target__mutmut_9, 
    'x_send_message_to_target__mutmut_10': x_send_message_to_target__mutmut_10, 
    'x_send_message_to_target__mutmut_11': x_send_message_to_target__mutmut_11, 
    'x_send_message_to_target__mutmut_12': x_send_message_to_target__mutmut_12, 
    'x_send_message_to_target__mutmut_13': x_send_message_to_target__mutmut_13, 
    'x_send_message_to_target__mutmut_14': x_send_message_to_target__mutmut_14, 
    'x_send_message_to_target__mutmut_15': x_send_message_to_target__mutmut_15, 
    'x_send_message_to_target__mutmut_16': x_send_message_to_target__mutmut_16, 
    'x_send_message_to_target__mutmut_17': x_send_message_to_target__mutmut_17, 
    'x_send_message_to_target__mutmut_18': x_send_message_to_target__mutmut_18, 
    'x_send_message_to_target__mutmut_19': x_send_message_to_target__mutmut_19, 
    'x_send_message_to_target__mutmut_20': x_send_message_to_target__mutmut_20, 
    'x_send_message_to_target__mutmut_21': x_send_message_to_target__mutmut_21, 
    'x_send_message_to_target__mutmut_22': x_send_message_to_target__mutmut_22, 
    'x_send_message_to_target__mutmut_23': x_send_message_to_target__mutmut_23, 
    'x_send_message_to_target__mutmut_24': x_send_message_to_target__mutmut_24, 
    'x_send_message_to_target__mutmut_25': x_send_message_to_target__mutmut_25, 
    'x_send_message_to_target__mutmut_26': x_send_message_to_target__mutmut_26, 
    'x_send_message_to_target__mutmut_27': x_send_message_to_target__mutmut_27, 
    'x_send_message_to_target__mutmut_28': x_send_message_to_target__mutmut_28
}

def send_message_to_target(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_send_message_to_target__mutmut_orig, x_send_message_to_target__mutmut_mutants, args, kwargs)
    return result 

send_message_to_target.__signature__ = _mutmut_signature(x_send_message_to_target__mutmut_orig)
x_send_message_to_target__mutmut_orig.__name__ = 'x_send_message_to_target'


def x_set_auto_attach__mutmut_orig(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_1(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = None
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_2(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = None
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_3(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["XXautoAttachXX"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_4(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoattach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_5(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["AUTOATTACH"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_6(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["Autoattach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_7(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = None
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_8(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["XXwaitForDebuggerOnStartXX"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_9(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitfordebuggeronstart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_10(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["WAITFORDEBUGGERONSTART"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_11(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["Waitfordebuggeronstart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_12(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_13(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = None
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_14(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["XXflattenXX"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_15(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["FLATTEN"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_16(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["Flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_17(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_18(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_19(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["XXfilterXX"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_20(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["FILTER"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_21(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["Filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_22(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_auto_attach__mutmut_23(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_24(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_25(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.setAutoAttach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_26(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.setAutoAttachXX",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_27(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "target.setautoattach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_28(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.SETAUTOATTACH",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_29(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setautoattach",
        "params": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_30(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_31(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_auto_attach__mutmut_32(
    auto_attach: bool,
    wait_for_debugger_on_start: bool,
    flatten: bool | None = None,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to automatically attach to new targets which are considered to be related to
    this one. When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by ``autoAttachRelated`` from the list of targets to watch
    for creation of related targets.

    :param auto_attach: Whether to auto-attach to related targets.
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param flatten: **(EXPERIMENTAL)** *(Optional)* Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["autoAttach"] = auto_attach
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if flatten is not None:
        params["flatten"] = flatten
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setAutoAttach",
        "Params": params,
    }
    yield cmd_dict

x_set_auto_attach__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_auto_attach__mutmut_1': x_set_auto_attach__mutmut_1, 
    'x_set_auto_attach__mutmut_2': x_set_auto_attach__mutmut_2, 
    'x_set_auto_attach__mutmut_3': x_set_auto_attach__mutmut_3, 
    'x_set_auto_attach__mutmut_4': x_set_auto_attach__mutmut_4, 
    'x_set_auto_attach__mutmut_5': x_set_auto_attach__mutmut_5, 
    'x_set_auto_attach__mutmut_6': x_set_auto_attach__mutmut_6, 
    'x_set_auto_attach__mutmut_7': x_set_auto_attach__mutmut_7, 
    'x_set_auto_attach__mutmut_8': x_set_auto_attach__mutmut_8, 
    'x_set_auto_attach__mutmut_9': x_set_auto_attach__mutmut_9, 
    'x_set_auto_attach__mutmut_10': x_set_auto_attach__mutmut_10, 
    'x_set_auto_attach__mutmut_11': x_set_auto_attach__mutmut_11, 
    'x_set_auto_attach__mutmut_12': x_set_auto_attach__mutmut_12, 
    'x_set_auto_attach__mutmut_13': x_set_auto_attach__mutmut_13, 
    'x_set_auto_attach__mutmut_14': x_set_auto_attach__mutmut_14, 
    'x_set_auto_attach__mutmut_15': x_set_auto_attach__mutmut_15, 
    'x_set_auto_attach__mutmut_16': x_set_auto_attach__mutmut_16, 
    'x_set_auto_attach__mutmut_17': x_set_auto_attach__mutmut_17, 
    'x_set_auto_attach__mutmut_18': x_set_auto_attach__mutmut_18, 
    'x_set_auto_attach__mutmut_19': x_set_auto_attach__mutmut_19, 
    'x_set_auto_attach__mutmut_20': x_set_auto_attach__mutmut_20, 
    'x_set_auto_attach__mutmut_21': x_set_auto_attach__mutmut_21, 
    'x_set_auto_attach__mutmut_22': x_set_auto_attach__mutmut_22, 
    'x_set_auto_attach__mutmut_23': x_set_auto_attach__mutmut_23, 
    'x_set_auto_attach__mutmut_24': x_set_auto_attach__mutmut_24, 
    'x_set_auto_attach__mutmut_25': x_set_auto_attach__mutmut_25, 
    'x_set_auto_attach__mutmut_26': x_set_auto_attach__mutmut_26, 
    'x_set_auto_attach__mutmut_27': x_set_auto_attach__mutmut_27, 
    'x_set_auto_attach__mutmut_28': x_set_auto_attach__mutmut_28, 
    'x_set_auto_attach__mutmut_29': x_set_auto_attach__mutmut_29, 
    'x_set_auto_attach__mutmut_30': x_set_auto_attach__mutmut_30, 
    'x_set_auto_attach__mutmut_31': x_set_auto_attach__mutmut_31, 
    'x_set_auto_attach__mutmut_32': x_set_auto_attach__mutmut_32
}

def set_auto_attach(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_auto_attach__mutmut_orig, x_set_auto_attach__mutmut_mutants, args, kwargs)
    return result 

set_auto_attach.__signature__ = _mutmut_signature(x_set_auto_attach__mutmut_orig)
x_set_auto_attach__mutmut_orig.__name__ = 'x_set_auto_attach'


def x_auto_attach_related__mutmut_orig(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_1(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = None
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_2(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = None
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_3(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["XXtargetIdXX"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_4(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetid"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_5(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["TARGETID"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_6(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["Targetid"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_7(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = None
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_8(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["XXwaitForDebuggerOnStartXX"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_9(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitfordebuggeronstart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_10(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["WAITFORDEBUGGERONSTART"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_11(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["Waitfordebuggeronstart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_12(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_13(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_14(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["XXfilterXX"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_15(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["FILTER"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_16(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["Filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_17(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_auto_attach_related__mutmut_18(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_19(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_20(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.autoAttachRelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_21(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.autoAttachRelatedXX",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_22(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "target.autoattachrelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_23(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.AUTOATTACHRELATED",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_24(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoattachrelated",
        "params": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_25(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_26(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "PARAMS": params,
    }
    yield cmd_dict


def x_auto_attach_related__mutmut_27(
    target_id: TargetID,
    wait_for_debugger_on_start: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through ``attachedToTarget``. The specified target is also auto-attached.
    This cancels the effect of any previous ``setAutoAttach`` and is also cancelled by subsequent
    ``setAutoAttach``. Only available at the Browser target.

    **EXPERIMENTAL**

    :param target_id:
    :param wait_for_debugger_on_start: Whether to pause new targets when attaching to them. Use ```Runtime.runIfWaitingForDebugger``` to run paused targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached.
    """
    params: T_JSON_DICT = {}
    params["targetId"] = target_id.to_json()
    params["waitForDebuggerOnStart"] = wait_for_debugger_on_start
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.autoAttachRelated",
        "Params": params,
    }
    yield cmd_dict

x_auto_attach_related__mutmut_mutants : ClassVar[MutantDict] = {
'x_auto_attach_related__mutmut_1': x_auto_attach_related__mutmut_1, 
    'x_auto_attach_related__mutmut_2': x_auto_attach_related__mutmut_2, 
    'x_auto_attach_related__mutmut_3': x_auto_attach_related__mutmut_3, 
    'x_auto_attach_related__mutmut_4': x_auto_attach_related__mutmut_4, 
    'x_auto_attach_related__mutmut_5': x_auto_attach_related__mutmut_5, 
    'x_auto_attach_related__mutmut_6': x_auto_attach_related__mutmut_6, 
    'x_auto_attach_related__mutmut_7': x_auto_attach_related__mutmut_7, 
    'x_auto_attach_related__mutmut_8': x_auto_attach_related__mutmut_8, 
    'x_auto_attach_related__mutmut_9': x_auto_attach_related__mutmut_9, 
    'x_auto_attach_related__mutmut_10': x_auto_attach_related__mutmut_10, 
    'x_auto_attach_related__mutmut_11': x_auto_attach_related__mutmut_11, 
    'x_auto_attach_related__mutmut_12': x_auto_attach_related__mutmut_12, 
    'x_auto_attach_related__mutmut_13': x_auto_attach_related__mutmut_13, 
    'x_auto_attach_related__mutmut_14': x_auto_attach_related__mutmut_14, 
    'x_auto_attach_related__mutmut_15': x_auto_attach_related__mutmut_15, 
    'x_auto_attach_related__mutmut_16': x_auto_attach_related__mutmut_16, 
    'x_auto_attach_related__mutmut_17': x_auto_attach_related__mutmut_17, 
    'x_auto_attach_related__mutmut_18': x_auto_attach_related__mutmut_18, 
    'x_auto_attach_related__mutmut_19': x_auto_attach_related__mutmut_19, 
    'x_auto_attach_related__mutmut_20': x_auto_attach_related__mutmut_20, 
    'x_auto_attach_related__mutmut_21': x_auto_attach_related__mutmut_21, 
    'x_auto_attach_related__mutmut_22': x_auto_attach_related__mutmut_22, 
    'x_auto_attach_related__mutmut_23': x_auto_attach_related__mutmut_23, 
    'x_auto_attach_related__mutmut_24': x_auto_attach_related__mutmut_24, 
    'x_auto_attach_related__mutmut_25': x_auto_attach_related__mutmut_25, 
    'x_auto_attach_related__mutmut_26': x_auto_attach_related__mutmut_26, 
    'x_auto_attach_related__mutmut_27': x_auto_attach_related__mutmut_27
}

def auto_attach_related(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_auto_attach_related__mutmut_orig, x_auto_attach_related__mutmut_mutants, args, kwargs)
    return result 

auto_attach_related.__signature__ = _mutmut_signature(x_auto_attach_related__mutmut_orig)
x_auto_attach_related__mutmut_orig.__name__ = 'x_auto_attach_related'


def x_set_discover_targets__mutmut_orig(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_1(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = None
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_2(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = None
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_3(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["XXdiscoverXX"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_4(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["DISCOVER"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_5(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["Discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_6(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_7(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_8(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["XXfilterXX"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_9(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["FILTER"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_10(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["Filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_11(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_discover_targets__mutmut_12(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_13(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_14(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.setDiscoverTargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_15(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.setDiscoverTargetsXX",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_16(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "target.setdiscovertargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_17(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.SETDISCOVERTARGETS",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_18(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setdiscovertargets",
        "params": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_19(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_20(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_discover_targets__mutmut_21(
    discover: bool,
    filter_: TargetFilter | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether to discover available targets and notify via
    ``targetCreated/targetInfoChanged/targetDestroyed`` events.

    :param discover: Whether to discover available targets.
    :param filter_: **(EXPERIMENTAL)** *(Optional)* Only targets matching filter will be attached. If ```discover```` is false, ````filter``` must be omitted or empty.
    """
    params: T_JSON_DICT = {}
    params["discover"] = discover
    if filter_ is not None:
        params["filter"] = filter_.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setDiscoverTargets",
        "Params": params,
    }
    yield cmd_dict

x_set_discover_targets__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_discover_targets__mutmut_1': x_set_discover_targets__mutmut_1, 
    'x_set_discover_targets__mutmut_2': x_set_discover_targets__mutmut_2, 
    'x_set_discover_targets__mutmut_3': x_set_discover_targets__mutmut_3, 
    'x_set_discover_targets__mutmut_4': x_set_discover_targets__mutmut_4, 
    'x_set_discover_targets__mutmut_5': x_set_discover_targets__mutmut_5, 
    'x_set_discover_targets__mutmut_6': x_set_discover_targets__mutmut_6, 
    'x_set_discover_targets__mutmut_7': x_set_discover_targets__mutmut_7, 
    'x_set_discover_targets__mutmut_8': x_set_discover_targets__mutmut_8, 
    'x_set_discover_targets__mutmut_9': x_set_discover_targets__mutmut_9, 
    'x_set_discover_targets__mutmut_10': x_set_discover_targets__mutmut_10, 
    'x_set_discover_targets__mutmut_11': x_set_discover_targets__mutmut_11, 
    'x_set_discover_targets__mutmut_12': x_set_discover_targets__mutmut_12, 
    'x_set_discover_targets__mutmut_13': x_set_discover_targets__mutmut_13, 
    'x_set_discover_targets__mutmut_14': x_set_discover_targets__mutmut_14, 
    'x_set_discover_targets__mutmut_15': x_set_discover_targets__mutmut_15, 
    'x_set_discover_targets__mutmut_16': x_set_discover_targets__mutmut_16, 
    'x_set_discover_targets__mutmut_17': x_set_discover_targets__mutmut_17, 
    'x_set_discover_targets__mutmut_18': x_set_discover_targets__mutmut_18, 
    'x_set_discover_targets__mutmut_19': x_set_discover_targets__mutmut_19, 
    'x_set_discover_targets__mutmut_20': x_set_discover_targets__mutmut_20, 
    'x_set_discover_targets__mutmut_21': x_set_discover_targets__mutmut_21
}

def set_discover_targets(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_discover_targets__mutmut_orig, x_set_discover_targets__mutmut_mutants, args, kwargs)
    return result 

set_discover_targets.__signature__ = _mutmut_signature(x_set_discover_targets__mutmut_orig)
x_set_discover_targets__mutmut_orig.__name__ = 'x_set_discover_targets'


def x_set_remote_locations__mutmut_orig(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setRemoteLocations",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_1(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = None
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setRemoteLocations",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_2(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setRemoteLocations",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_3(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["XXlocationsXX"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setRemoteLocations",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_4(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["LOCATIONS"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setRemoteLocations",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_5(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["Locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setRemoteLocations",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_6(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_remote_locations__mutmut_7(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Target.setRemoteLocations",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_8(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Target.setRemoteLocations",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_9(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "Method": "Target.setRemoteLocations",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_10(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "XXTarget.setRemoteLocationsXX",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_11(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "target.setremotelocations",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_12(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "TARGET.SETREMOTELOCATIONS",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_13(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setremotelocations",
        "params": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_14(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setRemoteLocations",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_15(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setRemoteLocations",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_remote_locations__mutmut_16(
    locations: list[RemoteLocation],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables target discovery for the specified locations, when ``setDiscoverTargets`` was set to
    ``true``.

    **EXPERIMENTAL**

    :param locations: List of remote locations.
    """
    params: T_JSON_DICT = {}
    params["locations"] = [i.to_json() for i in locations]
    cmd_dict: T_JSON_DICT = {
        "method": "Target.setRemoteLocations",
        "Params": params,
    }
    yield cmd_dict

x_set_remote_locations__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_remote_locations__mutmut_1': x_set_remote_locations__mutmut_1, 
    'x_set_remote_locations__mutmut_2': x_set_remote_locations__mutmut_2, 
    'x_set_remote_locations__mutmut_3': x_set_remote_locations__mutmut_3, 
    'x_set_remote_locations__mutmut_4': x_set_remote_locations__mutmut_4, 
    'x_set_remote_locations__mutmut_5': x_set_remote_locations__mutmut_5, 
    'x_set_remote_locations__mutmut_6': x_set_remote_locations__mutmut_6, 
    'x_set_remote_locations__mutmut_7': x_set_remote_locations__mutmut_7, 
    'x_set_remote_locations__mutmut_8': x_set_remote_locations__mutmut_8, 
    'x_set_remote_locations__mutmut_9': x_set_remote_locations__mutmut_9, 
    'x_set_remote_locations__mutmut_10': x_set_remote_locations__mutmut_10, 
    'x_set_remote_locations__mutmut_11': x_set_remote_locations__mutmut_11, 
    'x_set_remote_locations__mutmut_12': x_set_remote_locations__mutmut_12, 
    'x_set_remote_locations__mutmut_13': x_set_remote_locations__mutmut_13, 
    'x_set_remote_locations__mutmut_14': x_set_remote_locations__mutmut_14, 
    'x_set_remote_locations__mutmut_15': x_set_remote_locations__mutmut_15, 
    'x_set_remote_locations__mutmut_16': x_set_remote_locations__mutmut_16
}

def set_remote_locations(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_remote_locations__mutmut_orig, x_set_remote_locations__mutmut_mutants, args, kwargs)
    return result 

set_remote_locations.__signature__ = _mutmut_signature(x_set_remote_locations__mutmut_orig)
x_set_remote_locations__mutmut_orig.__name__ = 'x_set_remote_locations'


@event_class("Target.attachedToTarget")
@dataclass
class AttachedToTarget:
    """
    **EXPERIMENTAL**

    Issued when attached to target because of auto-attach or ``attachToTarget`` command.
    """
    #: Identifier assigned to the session used to send/receive messages.
    session_id: SessionID
    target_info: TargetInfo
    waiting_for_debugger: bool

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AttachedToTarget:
        return cls(
            session_id=SessionID.from_json(json["sessionId"]),
            target_info=TargetInfo.from_json(json["targetInfo"]),
            waiting_for_debugger=bool(json["waitingForDebugger"]),
        )


@event_class("Target.detachedFromTarget")
@dataclass
class DetachedFromTarget:
    """
    **EXPERIMENTAL**

    Issued when detached from target for any reason (including ``detachFromTarget`` command). Can be
    issued multiple times per target if multiple sessions have been attached to it.
    """
    #: Detached session identifier.
    session_id: SessionID
    #: Deprecated.
    target_id: TargetID | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DetachedFromTarget:
        return cls(
            session_id=SessionID.from_json(json["sessionId"]),
            target_id=TargetID.from_json(json["targetId"]) if "targetId" in json else None,
        )


@event_class("Target.receivedMessageFromTarget")
@dataclass
class ReceivedMessageFromTarget:
    """
    Notifies about a new protocol message received from the session (as reported in
    ``attachedToTarget`` event).
    """
    #: Identifier of a session which sends a message.
    session_id: SessionID
    message: str
    #: Deprecated.
    target_id: TargetID | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ReceivedMessageFromTarget:
        return cls(
            session_id=SessionID.from_json(json["sessionId"]),
            message=str(json["message"]),
            target_id=TargetID.from_json(json["targetId"]) if "targetId" in json else None,
        )


@event_class("Target.targetCreated")
@dataclass
class TargetCreated:
    """
    Issued when a possible inspection target is created.
    """
    target_info: TargetInfo

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> TargetCreated:
        return cls(
            target_info=TargetInfo.from_json(json["targetInfo"]),
        )


@event_class("Target.targetDestroyed")
@dataclass
class TargetDestroyed:
    """
    Issued when a target is destroyed.
    """
    target_id: TargetID

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> TargetDestroyed:
        return cls(
            target_id=TargetID.from_json(json["targetId"]),
        )


@event_class("Target.targetCrashed")
@dataclass
class TargetCrashed:
    """
    Issued when a target has crashed.
    """
    target_id: TargetID
    #: Termination status type.
    status: str
    #: Termination error code.
    error_code: int

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> TargetCrashed:
        return cls(
            target_id=TargetID.from_json(json["targetId"]),
            status=str(json["status"]),
            error_code=int(json["errorCode"]),
        )


@event_class("Target.targetInfoChanged")
@dataclass
class TargetInfoChanged:
    """
    Issued when some information about a target has changed. This only happens between
    ``targetCreated`` and ``targetDestroyed``.
    """
    target_info: TargetInfo

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> TargetInfoChanged:
        return cls(
            target_info=TargetInfo.from_json(json["targetInfo"]),
        )
