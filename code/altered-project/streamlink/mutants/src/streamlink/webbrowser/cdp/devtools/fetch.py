# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all modules.
#
# CDP version: v0.0.1438564
# CDP domain: Fetch

from __future__ import annotations

import enum
from collections.abc import Generator
from dataclasses import dataclass
from typing import Any

import streamlink.webbrowser.cdp.devtools.io as io
import streamlink.webbrowser.cdp.devtools.network as network
import streamlink.webbrowser.cdp.devtools.page as page
from streamlink.webbrowser.cdp.devtools.util import T_JSON_DICT, event_class
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


class RequestId(str):
    """
    Unique request identifier.
    Note that this does not identify individual HTTP requests that are part of
    a network request.
    """
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> RequestId:
        return cls(json)

    def __repr__(self):
        return f"RequestId({super().__repr__()})"


class RequestStage(enum.Enum):
    """
    Stages of the request to handle. Request will intercept before the request is
    sent. Response will intercept after the response is received (but before response
    body is received).
    """
    REQUEST = "Request"
    RESPONSE = "Response"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> RequestStage:
        return cls(json)


@dataclass
class RequestPattern:
    #: Wildcards (``'*'`` -> zero or more, ``'?'`` -> exactly one) are allowed. Escape character is
    #: backslash. Omitting is equivalent to ``"*"``.
    url_pattern: str | None = None

    #: If set, only requests for matching resource types will be intercepted.
    resource_type: network.ResourceType | None = None

    #: Stage at which to begin intercepting requests. Default is Request.
    request_stage: RequestStage | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.url_pattern is not None:
            json["urlPattern"] = self.url_pattern
        if self.resource_type is not None:
            json["resourceType"] = self.resource_type.to_json()
        if self.request_stage is not None:
            json["requestStage"] = self.request_stage.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> RequestPattern:
        return cls(
            url_pattern=str(json["urlPattern"]) if "urlPattern" in json else None,
            resource_type=network.ResourceType.from_json(json["resourceType"]) if "resourceType" in json else None,
            request_stage=RequestStage.from_json(json["requestStage"]) if "requestStage" in json else None,
        )


@dataclass
class HeaderEntry:
    """
    Response HTTP header entry
    """
    name: str

    value: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["name"] = self.name
        json["value"] = self.value
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> HeaderEntry:
        return cls(
            name=str(json["name"]),
            value=str(json["value"]),
        )


@dataclass
class AuthChallenge:
    """
    Authorization challenge for HTTP status code 401 or 407.
    """
    #: Origin of the challenger.
    origin: str

    #: The authentication scheme used, such as basic or digest
    scheme: str

    #: The realm of the challenge. May be empty.
    realm: str

    #: Source of the authentication challenge.
    source: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["origin"] = self.origin
        json["scheme"] = self.scheme
        json["realm"] = self.realm
        if self.source is not None:
            json["source"] = self.source
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AuthChallenge:
        return cls(
            origin=str(json["origin"]),
            scheme=str(json["scheme"]),
            realm=str(json["realm"]),
            source=str(json["source"]) if "source" in json else None,
        )


@dataclass
class AuthChallengeResponse:
    """
    Response to an AuthChallenge.
    """
    #: The decision on what to do in response to the authorization challenge.  Default means
    #: deferring to the default behavior of the net stack, which will likely either the Cancel
    #: authentication or display a popup dialog box.
    response: str

    #: The username to provide, possibly empty. Should only be set if response is
    #: ProvideCredentials.
    username: str | None = None

    #: The password to provide, possibly empty. Should only be set if response is
    #: ProvideCredentials.
    password: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["response"] = self.response
        if self.username is not None:
            json["username"] = self.username
        if self.password is not None:
            json["password"] = self.password
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AuthChallengeResponse:
        return cls(
            response=str(json["response"]),
            username=str(json["username"]) if "username" in json else None,
            password=str(json["password"]) if "password" in json else None,
        )


def x_disable__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables the fetch domain.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.disable",
    }
    yield cmd_dict


def x_disable__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables the fetch domain.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_disable__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables the fetch domain.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Fetch.disable",
    }
    yield cmd_dict


def x_disable__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables the fetch domain.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Fetch.disable",
    }
    yield cmd_dict


def x_disable__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables the fetch domain.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Fetch.disable",
    }
    yield cmd_dict


def x_disable__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables the fetch domain.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXFetch.disableXX",
    }
    yield cmd_dict


def x_disable__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables the fetch domain.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "fetch.disable",
    }
    yield cmd_dict


def x_disable__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables the fetch domain.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "FETCH.DISABLE",
    }
    yield cmd_dict

x_disable__mutmut_mutants : ClassVar[MutantDict] = {
'x_disable__mutmut_1': x_disable__mutmut_1, 
    'x_disable__mutmut_2': x_disable__mutmut_2, 
    'x_disable__mutmut_3': x_disable__mutmut_3, 
    'x_disable__mutmut_4': x_disable__mutmut_4, 
    'x_disable__mutmut_5': x_disable__mutmut_5, 
    'x_disable__mutmut_6': x_disable__mutmut_6, 
    'x_disable__mutmut_7': x_disable__mutmut_7
}

def disable(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_disable__mutmut_orig, x_disable__mutmut_mutants, args, kwargs)
    return result 

disable.__signature__ = _mutmut_signature(x_disable__mutmut_orig)
x_disable__mutmut_orig.__name__ = 'x_disable'


def x_enable__mutmut_orig(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_1(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = None
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_2(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_3(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = None
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_4(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["XXpatternsXX"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_5(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["PATTERNS"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_6(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["Patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_7(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_8(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_9(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["XXhandleAuthRequestsXX"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_10(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleauthrequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_11(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["HANDLEAUTHREQUESTS"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_12(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["Handleauthrequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_13(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_enable__mutmut_14(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_15(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_16(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "Method": "Fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_17(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "XXFetch.enableXX",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_18(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "fetch.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_19(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "FETCH.ENABLE",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_20(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_enable__mutmut_21(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "PARAMS": params,
    }
    yield cmd_dict


def x_enable__mutmut_22(
    patterns: list[RequestPattern] | None = None,
    handle_auth_requests: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables issuing of requestPaused events. A request will be paused until client
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.

    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
    """
    params: T_JSON_DICT = {}
    if patterns is not None:
        params["patterns"] = [i.to_json() for i in patterns]
    if handle_auth_requests is not None:
        params["handleAuthRequests"] = handle_auth_requests
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.enable",
        "Params": params,
    }
    yield cmd_dict

x_enable__mutmut_mutants : ClassVar[MutantDict] = {
'x_enable__mutmut_1': x_enable__mutmut_1, 
    'x_enable__mutmut_2': x_enable__mutmut_2, 
    'x_enable__mutmut_3': x_enable__mutmut_3, 
    'x_enable__mutmut_4': x_enable__mutmut_4, 
    'x_enable__mutmut_5': x_enable__mutmut_5, 
    'x_enable__mutmut_6': x_enable__mutmut_6, 
    'x_enable__mutmut_7': x_enable__mutmut_7, 
    'x_enable__mutmut_8': x_enable__mutmut_8, 
    'x_enable__mutmut_9': x_enable__mutmut_9, 
    'x_enable__mutmut_10': x_enable__mutmut_10, 
    'x_enable__mutmut_11': x_enable__mutmut_11, 
    'x_enable__mutmut_12': x_enable__mutmut_12, 
    'x_enable__mutmut_13': x_enable__mutmut_13, 
    'x_enable__mutmut_14': x_enable__mutmut_14, 
    'x_enable__mutmut_15': x_enable__mutmut_15, 
    'x_enable__mutmut_16': x_enable__mutmut_16, 
    'x_enable__mutmut_17': x_enable__mutmut_17, 
    'x_enable__mutmut_18': x_enable__mutmut_18, 
    'x_enable__mutmut_19': x_enable__mutmut_19, 
    'x_enable__mutmut_20': x_enable__mutmut_20, 
    'x_enable__mutmut_21': x_enable__mutmut_21, 
    'x_enable__mutmut_22': x_enable__mutmut_22
}

def enable(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_enable__mutmut_orig, x_enable__mutmut_mutants, args, kwargs)
    return result 

enable.__signature__ = _mutmut_signature(x_enable__mutmut_orig)
x_enable__mutmut_orig.__name__ = 'x_enable'


def x_fail_request__mutmut_orig(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_1(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = None
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_2(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = None
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_3(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["XXrequestIdXX"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_4(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestid"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_5(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["REQUESTID"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_6(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["Requestid"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_7(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_8(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["XXerrorReasonXX"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_9(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorreason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_10(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["ERRORREASON"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_11(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["Errorreason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_12(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_fail_request__mutmut_13(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_14(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_15(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Fetch.failRequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_16(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXFetch.failRequestXX",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_17(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "fetch.failrequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_18(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "FETCH.FAILREQUEST",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_19(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failrequest",
        "params": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_20(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_21(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "PARAMS": params,
    }
    yield cmd_dict


def x_fail_request__mutmut_22(
    request_id: RequestId,
    error_reason: network.ErrorReason,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Causes the request to fail with specified reason.

    :param request_id: An id the client received in requestPaused event.
    :param error_reason: Causes the request to fail with the given reason.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["errorReason"] = error_reason.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.failRequest",
        "Params": params,
    }
    yield cmd_dict

x_fail_request__mutmut_mutants : ClassVar[MutantDict] = {
'x_fail_request__mutmut_1': x_fail_request__mutmut_1, 
    'x_fail_request__mutmut_2': x_fail_request__mutmut_2, 
    'x_fail_request__mutmut_3': x_fail_request__mutmut_3, 
    'x_fail_request__mutmut_4': x_fail_request__mutmut_4, 
    'x_fail_request__mutmut_5': x_fail_request__mutmut_5, 
    'x_fail_request__mutmut_6': x_fail_request__mutmut_6, 
    'x_fail_request__mutmut_7': x_fail_request__mutmut_7, 
    'x_fail_request__mutmut_8': x_fail_request__mutmut_8, 
    'x_fail_request__mutmut_9': x_fail_request__mutmut_9, 
    'x_fail_request__mutmut_10': x_fail_request__mutmut_10, 
    'x_fail_request__mutmut_11': x_fail_request__mutmut_11, 
    'x_fail_request__mutmut_12': x_fail_request__mutmut_12, 
    'x_fail_request__mutmut_13': x_fail_request__mutmut_13, 
    'x_fail_request__mutmut_14': x_fail_request__mutmut_14, 
    'x_fail_request__mutmut_15': x_fail_request__mutmut_15, 
    'x_fail_request__mutmut_16': x_fail_request__mutmut_16, 
    'x_fail_request__mutmut_17': x_fail_request__mutmut_17, 
    'x_fail_request__mutmut_18': x_fail_request__mutmut_18, 
    'x_fail_request__mutmut_19': x_fail_request__mutmut_19, 
    'x_fail_request__mutmut_20': x_fail_request__mutmut_20, 
    'x_fail_request__mutmut_21': x_fail_request__mutmut_21, 
    'x_fail_request__mutmut_22': x_fail_request__mutmut_22
}

def fail_request(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_fail_request__mutmut_orig, x_fail_request__mutmut_mutants, args, kwargs)
    return result 

fail_request.__signature__ = _mutmut_signature(x_fail_request__mutmut_orig)
x_fail_request__mutmut_orig.__name__ = 'x_fail_request'


def x_fulfill_request__mutmut_orig(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_1(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = None
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_2(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = None
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_3(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["XXrequestIdXX"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_4(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestid"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_5(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["REQUESTID"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_6(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["Requestid"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_7(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = None
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_8(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["XXresponseCodeXX"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_9(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responsecode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_10(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["RESPONSECODE"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_11(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["Responsecode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_12(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_13(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = None
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_14(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["XXresponseHeadersXX"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_15(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseheaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_16(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["RESPONSEHEADERS"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_17(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["Responseheaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_18(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_19(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = None
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_20(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["XXbinaryResponseHeadersXX"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_21(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryresponseheaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_22(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["BINARYRESPONSEHEADERS"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_23(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["Binaryresponseheaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_24(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_25(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = None
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_26(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["XXbodyXX"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_27(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["BODY"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_28(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["Body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_29(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_30(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_31(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["XXresponsePhraseXX"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_32(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsephrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_33(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["RESPONSEPHRASE"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_34(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["Responsephrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_35(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_fulfill_request__mutmut_36(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_37(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_38(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "Method": "Fetch.fulfillRequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_39(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "XXFetch.fulfillRequestXX",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_40(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "fetch.fulfillrequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_41(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "FETCH.FULFILLREQUEST",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_42(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillrequest",
        "params": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_43(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_44(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "PARAMS": params,
    }
    yield cmd_dict


def x_fulfill_request__mutmut_45(
    request_id: RequestId,
    response_code: int,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
    body: str | None = None,
    response_phrase: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Provides response to the request.

    :param request_id: An id the client received in requestPaused event.
    :param response_code: An HTTP response code.
    :param response_headers: *(Optional)* Response headers.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    :param body: *(Optional)* A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["responseCode"] = response_code
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    if body is not None:
        params["body"] = body
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.fulfillRequest",
        "Params": params,
    }
    yield cmd_dict

x_fulfill_request__mutmut_mutants : ClassVar[MutantDict] = {
'x_fulfill_request__mutmut_1': x_fulfill_request__mutmut_1, 
    'x_fulfill_request__mutmut_2': x_fulfill_request__mutmut_2, 
    'x_fulfill_request__mutmut_3': x_fulfill_request__mutmut_3, 
    'x_fulfill_request__mutmut_4': x_fulfill_request__mutmut_4, 
    'x_fulfill_request__mutmut_5': x_fulfill_request__mutmut_5, 
    'x_fulfill_request__mutmut_6': x_fulfill_request__mutmut_6, 
    'x_fulfill_request__mutmut_7': x_fulfill_request__mutmut_7, 
    'x_fulfill_request__mutmut_8': x_fulfill_request__mutmut_8, 
    'x_fulfill_request__mutmut_9': x_fulfill_request__mutmut_9, 
    'x_fulfill_request__mutmut_10': x_fulfill_request__mutmut_10, 
    'x_fulfill_request__mutmut_11': x_fulfill_request__mutmut_11, 
    'x_fulfill_request__mutmut_12': x_fulfill_request__mutmut_12, 
    'x_fulfill_request__mutmut_13': x_fulfill_request__mutmut_13, 
    'x_fulfill_request__mutmut_14': x_fulfill_request__mutmut_14, 
    'x_fulfill_request__mutmut_15': x_fulfill_request__mutmut_15, 
    'x_fulfill_request__mutmut_16': x_fulfill_request__mutmut_16, 
    'x_fulfill_request__mutmut_17': x_fulfill_request__mutmut_17, 
    'x_fulfill_request__mutmut_18': x_fulfill_request__mutmut_18, 
    'x_fulfill_request__mutmut_19': x_fulfill_request__mutmut_19, 
    'x_fulfill_request__mutmut_20': x_fulfill_request__mutmut_20, 
    'x_fulfill_request__mutmut_21': x_fulfill_request__mutmut_21, 
    'x_fulfill_request__mutmut_22': x_fulfill_request__mutmut_22, 
    'x_fulfill_request__mutmut_23': x_fulfill_request__mutmut_23, 
    'x_fulfill_request__mutmut_24': x_fulfill_request__mutmut_24, 
    'x_fulfill_request__mutmut_25': x_fulfill_request__mutmut_25, 
    'x_fulfill_request__mutmut_26': x_fulfill_request__mutmut_26, 
    'x_fulfill_request__mutmut_27': x_fulfill_request__mutmut_27, 
    'x_fulfill_request__mutmut_28': x_fulfill_request__mutmut_28, 
    'x_fulfill_request__mutmut_29': x_fulfill_request__mutmut_29, 
    'x_fulfill_request__mutmut_30': x_fulfill_request__mutmut_30, 
    'x_fulfill_request__mutmut_31': x_fulfill_request__mutmut_31, 
    'x_fulfill_request__mutmut_32': x_fulfill_request__mutmut_32, 
    'x_fulfill_request__mutmut_33': x_fulfill_request__mutmut_33, 
    'x_fulfill_request__mutmut_34': x_fulfill_request__mutmut_34, 
    'x_fulfill_request__mutmut_35': x_fulfill_request__mutmut_35, 
    'x_fulfill_request__mutmut_36': x_fulfill_request__mutmut_36, 
    'x_fulfill_request__mutmut_37': x_fulfill_request__mutmut_37, 
    'x_fulfill_request__mutmut_38': x_fulfill_request__mutmut_38, 
    'x_fulfill_request__mutmut_39': x_fulfill_request__mutmut_39, 
    'x_fulfill_request__mutmut_40': x_fulfill_request__mutmut_40, 
    'x_fulfill_request__mutmut_41': x_fulfill_request__mutmut_41, 
    'x_fulfill_request__mutmut_42': x_fulfill_request__mutmut_42, 
    'x_fulfill_request__mutmut_43': x_fulfill_request__mutmut_43, 
    'x_fulfill_request__mutmut_44': x_fulfill_request__mutmut_44, 
    'x_fulfill_request__mutmut_45': x_fulfill_request__mutmut_45
}

def fulfill_request(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_fulfill_request__mutmut_orig, x_fulfill_request__mutmut_mutants, args, kwargs)
    return result 

fulfill_request.__signature__ = _mutmut_signature(x_fulfill_request__mutmut_orig)
x_fulfill_request__mutmut_orig.__name__ = 'x_fulfill_request'


def x_continue_request__mutmut_orig(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_1(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = None
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_2(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = None
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_3(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["XXrequestIdXX"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_4(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestid"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_5(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["REQUESTID"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_6(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["Requestid"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_7(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_8(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = None
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_9(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["XXurlXX"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_10(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["URL"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_11(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["Url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_12(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_13(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = None
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_14(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["XXmethodXX"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_15(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["METHOD"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_16(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["Method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_17(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_18(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = None
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_19(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["XXpostDataXX"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_20(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postdata"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_21(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["POSTDATA"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_22(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["Postdata"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_23(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_24(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = None
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_25(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["XXheadersXX"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_26(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["HEADERS"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_27(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["Headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_28(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_29(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_30(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["XXinterceptResponseXX"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_31(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptresponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_32(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["INTERCEPTRESPONSE"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_33(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["Interceptresponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_34(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_continue_request__mutmut_35(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_36(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_37(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "Method": "Fetch.continueRequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_38(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "XXFetch.continueRequestXX",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_39(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "fetch.continuerequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_40(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "FETCH.CONTINUEREQUEST",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_41(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continuerequest",
        "params": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_42(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_43(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "PARAMS": params,
    }
    yield cmd_dict


def x_continue_request__mutmut_44(
    request_id: RequestId,
    url: str | None = None,
    method: str | None = None,
    post_data: str | None = None,
    headers: list[HeaderEntry] | None = None,
    intercept_response: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues the request, optionally modifying some of its parameters.

    :param request_id: An id the client received in requestPaused event.
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page.
    :param method: *(Optional)* If set, the request method is overridden.
    :param post_data: *(Optional)* If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
    :param headers: *(Optional)* If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
    :param intercept_response: **(EXPERIMENTAL)** *(Optional)* If set, overrides response interception behavior for this request.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if url is not None:
        params["url"] = url
    if method is not None:
        params["method"] = method
    if post_data is not None:
        params["postData"] = post_data
    if headers is not None:
        params["headers"] = [i.to_json() for i in headers]
    if intercept_response is not None:
        params["interceptResponse"] = intercept_response
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueRequest",
        "Params": params,
    }
    yield cmd_dict

x_continue_request__mutmut_mutants : ClassVar[MutantDict] = {
'x_continue_request__mutmut_1': x_continue_request__mutmut_1, 
    'x_continue_request__mutmut_2': x_continue_request__mutmut_2, 
    'x_continue_request__mutmut_3': x_continue_request__mutmut_3, 
    'x_continue_request__mutmut_4': x_continue_request__mutmut_4, 
    'x_continue_request__mutmut_5': x_continue_request__mutmut_5, 
    'x_continue_request__mutmut_6': x_continue_request__mutmut_6, 
    'x_continue_request__mutmut_7': x_continue_request__mutmut_7, 
    'x_continue_request__mutmut_8': x_continue_request__mutmut_8, 
    'x_continue_request__mutmut_9': x_continue_request__mutmut_9, 
    'x_continue_request__mutmut_10': x_continue_request__mutmut_10, 
    'x_continue_request__mutmut_11': x_continue_request__mutmut_11, 
    'x_continue_request__mutmut_12': x_continue_request__mutmut_12, 
    'x_continue_request__mutmut_13': x_continue_request__mutmut_13, 
    'x_continue_request__mutmut_14': x_continue_request__mutmut_14, 
    'x_continue_request__mutmut_15': x_continue_request__mutmut_15, 
    'x_continue_request__mutmut_16': x_continue_request__mutmut_16, 
    'x_continue_request__mutmut_17': x_continue_request__mutmut_17, 
    'x_continue_request__mutmut_18': x_continue_request__mutmut_18, 
    'x_continue_request__mutmut_19': x_continue_request__mutmut_19, 
    'x_continue_request__mutmut_20': x_continue_request__mutmut_20, 
    'x_continue_request__mutmut_21': x_continue_request__mutmut_21, 
    'x_continue_request__mutmut_22': x_continue_request__mutmut_22, 
    'x_continue_request__mutmut_23': x_continue_request__mutmut_23, 
    'x_continue_request__mutmut_24': x_continue_request__mutmut_24, 
    'x_continue_request__mutmut_25': x_continue_request__mutmut_25, 
    'x_continue_request__mutmut_26': x_continue_request__mutmut_26, 
    'x_continue_request__mutmut_27': x_continue_request__mutmut_27, 
    'x_continue_request__mutmut_28': x_continue_request__mutmut_28, 
    'x_continue_request__mutmut_29': x_continue_request__mutmut_29, 
    'x_continue_request__mutmut_30': x_continue_request__mutmut_30, 
    'x_continue_request__mutmut_31': x_continue_request__mutmut_31, 
    'x_continue_request__mutmut_32': x_continue_request__mutmut_32, 
    'x_continue_request__mutmut_33': x_continue_request__mutmut_33, 
    'x_continue_request__mutmut_34': x_continue_request__mutmut_34, 
    'x_continue_request__mutmut_35': x_continue_request__mutmut_35, 
    'x_continue_request__mutmut_36': x_continue_request__mutmut_36, 
    'x_continue_request__mutmut_37': x_continue_request__mutmut_37, 
    'x_continue_request__mutmut_38': x_continue_request__mutmut_38, 
    'x_continue_request__mutmut_39': x_continue_request__mutmut_39, 
    'x_continue_request__mutmut_40': x_continue_request__mutmut_40, 
    'x_continue_request__mutmut_41': x_continue_request__mutmut_41, 
    'x_continue_request__mutmut_42': x_continue_request__mutmut_42, 
    'x_continue_request__mutmut_43': x_continue_request__mutmut_43, 
    'x_continue_request__mutmut_44': x_continue_request__mutmut_44
}

def continue_request(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_continue_request__mutmut_orig, x_continue_request__mutmut_mutants, args, kwargs)
    return result 

continue_request.__signature__ = _mutmut_signature(x_continue_request__mutmut_orig)
x_continue_request__mutmut_orig.__name__ = 'x_continue_request'


def x_continue_with_auth__mutmut_orig(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_1(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = None
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_2(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = None
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_3(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["XXrequestIdXX"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_4(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestid"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_5(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["REQUESTID"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_6(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["Requestid"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_7(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_8(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["XXauthChallengeResponseXX"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_9(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authchallengeresponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_10(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["AUTHCHALLENGERESPONSE"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_11(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["Authchallengeresponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_12(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_continue_with_auth__mutmut_13(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_14(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_15(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Fetch.continueWithAuth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_16(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXFetch.continueWithAuthXX",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_17(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "fetch.continuewithauth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_18(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "FETCH.CONTINUEWITHAUTH",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_19(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continuewithauth",
        "params": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_20(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_21(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "PARAMS": params,
    }
    yield cmd_dict


def x_continue_with_auth__mutmut_22(
    request_id: RequestId,
    auth_challenge_response: AuthChallengeResponse,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues a request supplying authChallengeResponse following authRequired event.

    :param request_id: An id the client received in authRequired event.
    :param auth_challenge_response: Response to  with an authChallenge.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    params["authChallengeResponse"] = auth_challenge_response.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueWithAuth",
        "Params": params,
    }
    yield cmd_dict

x_continue_with_auth__mutmut_mutants : ClassVar[MutantDict] = {
'x_continue_with_auth__mutmut_1': x_continue_with_auth__mutmut_1, 
    'x_continue_with_auth__mutmut_2': x_continue_with_auth__mutmut_2, 
    'x_continue_with_auth__mutmut_3': x_continue_with_auth__mutmut_3, 
    'x_continue_with_auth__mutmut_4': x_continue_with_auth__mutmut_4, 
    'x_continue_with_auth__mutmut_5': x_continue_with_auth__mutmut_5, 
    'x_continue_with_auth__mutmut_6': x_continue_with_auth__mutmut_6, 
    'x_continue_with_auth__mutmut_7': x_continue_with_auth__mutmut_7, 
    'x_continue_with_auth__mutmut_8': x_continue_with_auth__mutmut_8, 
    'x_continue_with_auth__mutmut_9': x_continue_with_auth__mutmut_9, 
    'x_continue_with_auth__mutmut_10': x_continue_with_auth__mutmut_10, 
    'x_continue_with_auth__mutmut_11': x_continue_with_auth__mutmut_11, 
    'x_continue_with_auth__mutmut_12': x_continue_with_auth__mutmut_12, 
    'x_continue_with_auth__mutmut_13': x_continue_with_auth__mutmut_13, 
    'x_continue_with_auth__mutmut_14': x_continue_with_auth__mutmut_14, 
    'x_continue_with_auth__mutmut_15': x_continue_with_auth__mutmut_15, 
    'x_continue_with_auth__mutmut_16': x_continue_with_auth__mutmut_16, 
    'x_continue_with_auth__mutmut_17': x_continue_with_auth__mutmut_17, 
    'x_continue_with_auth__mutmut_18': x_continue_with_auth__mutmut_18, 
    'x_continue_with_auth__mutmut_19': x_continue_with_auth__mutmut_19, 
    'x_continue_with_auth__mutmut_20': x_continue_with_auth__mutmut_20, 
    'x_continue_with_auth__mutmut_21': x_continue_with_auth__mutmut_21, 
    'x_continue_with_auth__mutmut_22': x_continue_with_auth__mutmut_22
}

def continue_with_auth(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_continue_with_auth__mutmut_orig, x_continue_with_auth__mutmut_mutants, args, kwargs)
    return result 

continue_with_auth.__signature__ = _mutmut_signature(x_continue_with_auth__mutmut_orig)
x_continue_with_auth__mutmut_orig.__name__ = 'x_continue_with_auth'


def x_continue_response__mutmut_orig(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_1(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = None
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_2(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = None
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_3(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["XXrequestIdXX"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_4(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestid"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_5(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["REQUESTID"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_6(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["Requestid"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_7(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_8(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = None
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_9(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["XXresponseCodeXX"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_10(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responsecode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_11(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["RESPONSECODE"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_12(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["Responsecode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_13(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_14(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = None
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_15(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["XXresponsePhraseXX"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_16(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsephrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_17(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["RESPONSEPHRASE"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_18(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["Responsephrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_19(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_20(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = None
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_21(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["XXresponseHeadersXX"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_22(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseheaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_23(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["RESPONSEHEADERS"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_24(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["Responseheaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_25(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_26(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_27(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["XXbinaryResponseHeadersXX"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_28(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryresponseheaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_29(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["BINARYRESPONSEHEADERS"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_30(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["Binaryresponseheaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_31(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_continue_response__mutmut_32(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_33(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_34(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "Method": "Fetch.continueResponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_35(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "XXFetch.continueResponseXX",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_36(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "fetch.continueresponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_37(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "FETCH.CONTINUERESPONSE",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_38(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueresponse",
        "params": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_39(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_40(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "PARAMS": params,
    }
    yield cmd_dict


def x_continue_response__mutmut_41(
    request_id: RequestId,
    response_code: int | None = None,
    response_phrase: str | None = None,
    response_headers: list[HeaderEntry] | None = None,
    binary_response_headers: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues loading of the paused response, optionally modifying the
    response headers. If either responseCode or headers are modified, all of them
    must be present.

    **EXPERIMENTAL**

    :param request_id: An id the client received in requestPaused event.
    :param response_code: *(Optional)* An HTTP response code. If absent, original response code will be used.
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
    :param response_headers: *(Optional)* Response headers. If absent, original response headers will be used.
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    if response_code is not None:
        params["responseCode"] = response_code
    if response_phrase is not None:
        params["responsePhrase"] = response_phrase
    if response_headers is not None:
        params["responseHeaders"] = [i.to_json() for i in response_headers]
    if binary_response_headers is not None:
        params["binaryResponseHeaders"] = binary_response_headers
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.continueResponse",
        "Params": params,
    }
    yield cmd_dict

x_continue_response__mutmut_mutants : ClassVar[MutantDict] = {
'x_continue_response__mutmut_1': x_continue_response__mutmut_1, 
    'x_continue_response__mutmut_2': x_continue_response__mutmut_2, 
    'x_continue_response__mutmut_3': x_continue_response__mutmut_3, 
    'x_continue_response__mutmut_4': x_continue_response__mutmut_4, 
    'x_continue_response__mutmut_5': x_continue_response__mutmut_5, 
    'x_continue_response__mutmut_6': x_continue_response__mutmut_6, 
    'x_continue_response__mutmut_7': x_continue_response__mutmut_7, 
    'x_continue_response__mutmut_8': x_continue_response__mutmut_8, 
    'x_continue_response__mutmut_9': x_continue_response__mutmut_9, 
    'x_continue_response__mutmut_10': x_continue_response__mutmut_10, 
    'x_continue_response__mutmut_11': x_continue_response__mutmut_11, 
    'x_continue_response__mutmut_12': x_continue_response__mutmut_12, 
    'x_continue_response__mutmut_13': x_continue_response__mutmut_13, 
    'x_continue_response__mutmut_14': x_continue_response__mutmut_14, 
    'x_continue_response__mutmut_15': x_continue_response__mutmut_15, 
    'x_continue_response__mutmut_16': x_continue_response__mutmut_16, 
    'x_continue_response__mutmut_17': x_continue_response__mutmut_17, 
    'x_continue_response__mutmut_18': x_continue_response__mutmut_18, 
    'x_continue_response__mutmut_19': x_continue_response__mutmut_19, 
    'x_continue_response__mutmut_20': x_continue_response__mutmut_20, 
    'x_continue_response__mutmut_21': x_continue_response__mutmut_21, 
    'x_continue_response__mutmut_22': x_continue_response__mutmut_22, 
    'x_continue_response__mutmut_23': x_continue_response__mutmut_23, 
    'x_continue_response__mutmut_24': x_continue_response__mutmut_24, 
    'x_continue_response__mutmut_25': x_continue_response__mutmut_25, 
    'x_continue_response__mutmut_26': x_continue_response__mutmut_26, 
    'x_continue_response__mutmut_27': x_continue_response__mutmut_27, 
    'x_continue_response__mutmut_28': x_continue_response__mutmut_28, 
    'x_continue_response__mutmut_29': x_continue_response__mutmut_29, 
    'x_continue_response__mutmut_30': x_continue_response__mutmut_30, 
    'x_continue_response__mutmut_31': x_continue_response__mutmut_31, 
    'x_continue_response__mutmut_32': x_continue_response__mutmut_32, 
    'x_continue_response__mutmut_33': x_continue_response__mutmut_33, 
    'x_continue_response__mutmut_34': x_continue_response__mutmut_34, 
    'x_continue_response__mutmut_35': x_continue_response__mutmut_35, 
    'x_continue_response__mutmut_36': x_continue_response__mutmut_36, 
    'x_continue_response__mutmut_37': x_continue_response__mutmut_37, 
    'x_continue_response__mutmut_38': x_continue_response__mutmut_38, 
    'x_continue_response__mutmut_39': x_continue_response__mutmut_39, 
    'x_continue_response__mutmut_40': x_continue_response__mutmut_40, 
    'x_continue_response__mutmut_41': x_continue_response__mutmut_41
}

def continue_response(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_continue_response__mutmut_orig, x_continue_response__mutmut_mutants, args, kwargs)
    return result 

continue_response.__signature__ = _mutmut_signature(x_continue_response__mutmut_orig)
x_continue_response__mutmut_orig.__name__ = 'x_continue_response'


def x_get_response_body__mutmut_orig(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_1(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = None
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_2(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_3(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["XXrequestIdXX"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_4(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestid"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_5(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["REQUESTID"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_6(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["Requestid"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_7(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_8(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_9(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_10(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_11(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXFetch.getResponseBodyXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_12(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "fetch.getresponsebody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_13(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "FETCH.GETRESPONSEBODY",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_14(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getresponsebody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_15(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_16(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_17(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_18(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = None
    return (
        str(json["body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_19(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(None),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_20(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["XXbodyXX"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_21(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["BODY"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_22(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["Body"]),
        bool(json["base64Encoded"]),
    )


def x_get_response_body__mutmut_23(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(None),
    )


def x_get_response_body__mutmut_24(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["XXbase64EncodedXX"]),
    )


def x_get_response_body__mutmut_25(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["base64encoded"]),
    )


def x_get_response_body__mutmut_26(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["BASE64ENCODED"]),
    )


def x_get_response_body__mutmut_27(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Causes the body of the response to be received from the server and
    returned as a single string. May only be issued for a request that
    is paused in the Response stage and is mutually exclusive with
    takeResponseBodyForInterceptionAsStream. Calling other methods that
    affect the request or disabling fetch domain before body is received
    results in an undefined behavior.
    Note that the response body is not available for redirects. Requests
    paused in the _redirect received_ state may be differentiated by
    ``responseCode`` and presence of ``location`` response header, see
    comments to ``requestPaused`` for details.

    :param request_id: Identifier for the intercepted request to get body for.
    :returns: A tuple with the following items:

        0. **body** - Response body.
        1. **base64Encoded** - True, if content was sent as base64.
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.getResponseBody",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["body"]),
        bool(json["Base64encoded"]),
    )

x_get_response_body__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_response_body__mutmut_1': x_get_response_body__mutmut_1, 
    'x_get_response_body__mutmut_2': x_get_response_body__mutmut_2, 
    'x_get_response_body__mutmut_3': x_get_response_body__mutmut_3, 
    'x_get_response_body__mutmut_4': x_get_response_body__mutmut_4, 
    'x_get_response_body__mutmut_5': x_get_response_body__mutmut_5, 
    'x_get_response_body__mutmut_6': x_get_response_body__mutmut_6, 
    'x_get_response_body__mutmut_7': x_get_response_body__mutmut_7, 
    'x_get_response_body__mutmut_8': x_get_response_body__mutmut_8, 
    'x_get_response_body__mutmut_9': x_get_response_body__mutmut_9, 
    'x_get_response_body__mutmut_10': x_get_response_body__mutmut_10, 
    'x_get_response_body__mutmut_11': x_get_response_body__mutmut_11, 
    'x_get_response_body__mutmut_12': x_get_response_body__mutmut_12, 
    'x_get_response_body__mutmut_13': x_get_response_body__mutmut_13, 
    'x_get_response_body__mutmut_14': x_get_response_body__mutmut_14, 
    'x_get_response_body__mutmut_15': x_get_response_body__mutmut_15, 
    'x_get_response_body__mutmut_16': x_get_response_body__mutmut_16, 
    'x_get_response_body__mutmut_17': x_get_response_body__mutmut_17, 
    'x_get_response_body__mutmut_18': x_get_response_body__mutmut_18, 
    'x_get_response_body__mutmut_19': x_get_response_body__mutmut_19, 
    'x_get_response_body__mutmut_20': x_get_response_body__mutmut_20, 
    'x_get_response_body__mutmut_21': x_get_response_body__mutmut_21, 
    'x_get_response_body__mutmut_22': x_get_response_body__mutmut_22, 
    'x_get_response_body__mutmut_23': x_get_response_body__mutmut_23, 
    'x_get_response_body__mutmut_24': x_get_response_body__mutmut_24, 
    'x_get_response_body__mutmut_25': x_get_response_body__mutmut_25, 
    'x_get_response_body__mutmut_26': x_get_response_body__mutmut_26, 
    'x_get_response_body__mutmut_27': x_get_response_body__mutmut_27
}

def get_response_body(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_response_body__mutmut_orig, x_get_response_body__mutmut_mutants, args, kwargs)
    return result 

get_response_body.__signature__ = _mutmut_signature(x_get_response_body__mutmut_orig)
x_get_response_body__mutmut_orig.__name__ = 'x_get_response_body'


def x_take_response_body_as_stream__mutmut_orig(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_1(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = None
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_2(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_3(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["XXrequestIdXX"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_4(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestid"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_5(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["REQUESTID"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_6(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["Requestid"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_7(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_8(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_9(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_10(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_11(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXFetch.takeResponseBodyAsStreamXX",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_12(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "fetch.takeresponsebodyasstream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_13(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "FETCH.TAKERESPONSEBODYASSTREAM",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_14(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeresponsebodyasstream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_15(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_16(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_17(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "Params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_18(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = None
    return io.StreamHandle.from_json(json["stream"])


def x_take_response_body_as_stream__mutmut_19(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(None)


def x_take_response_body_as_stream__mutmut_20(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["XXstreamXX"])


def x_take_response_body_as_stream__mutmut_21(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["STREAM"])


def x_take_response_body_as_stream__mutmut_22(
    request_id: RequestId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, io.StreamHandle]:
    """
    Returns a handle to the stream representing the response body.
    The request must be paused in the HeadersReceived stage.
    Note that after this command the request can't be continued
    as is -- client either needs to cancel it or to provide the
    response body.
    The stream only supports sequential read, IO.read will fail if the position
    is specified.
    This method is mutually exclusive with getResponseBody.
    Calling other methods that affect the request or disabling fetch
    domain before body is received results in an undefined behavior.

    :param request_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["requestId"] = request_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Fetch.takeResponseBodyAsStream",
        "params": params,
    }
    json = yield cmd_dict
    return io.StreamHandle.from_json(json["Stream"])

x_take_response_body_as_stream__mutmut_mutants : ClassVar[MutantDict] = {
'x_take_response_body_as_stream__mutmut_1': x_take_response_body_as_stream__mutmut_1, 
    'x_take_response_body_as_stream__mutmut_2': x_take_response_body_as_stream__mutmut_2, 
    'x_take_response_body_as_stream__mutmut_3': x_take_response_body_as_stream__mutmut_3, 
    'x_take_response_body_as_stream__mutmut_4': x_take_response_body_as_stream__mutmut_4, 
    'x_take_response_body_as_stream__mutmut_5': x_take_response_body_as_stream__mutmut_5, 
    'x_take_response_body_as_stream__mutmut_6': x_take_response_body_as_stream__mutmut_6, 
    'x_take_response_body_as_stream__mutmut_7': x_take_response_body_as_stream__mutmut_7, 
    'x_take_response_body_as_stream__mutmut_8': x_take_response_body_as_stream__mutmut_8, 
    'x_take_response_body_as_stream__mutmut_9': x_take_response_body_as_stream__mutmut_9, 
    'x_take_response_body_as_stream__mutmut_10': x_take_response_body_as_stream__mutmut_10, 
    'x_take_response_body_as_stream__mutmut_11': x_take_response_body_as_stream__mutmut_11, 
    'x_take_response_body_as_stream__mutmut_12': x_take_response_body_as_stream__mutmut_12, 
    'x_take_response_body_as_stream__mutmut_13': x_take_response_body_as_stream__mutmut_13, 
    'x_take_response_body_as_stream__mutmut_14': x_take_response_body_as_stream__mutmut_14, 
    'x_take_response_body_as_stream__mutmut_15': x_take_response_body_as_stream__mutmut_15, 
    'x_take_response_body_as_stream__mutmut_16': x_take_response_body_as_stream__mutmut_16, 
    'x_take_response_body_as_stream__mutmut_17': x_take_response_body_as_stream__mutmut_17, 
    'x_take_response_body_as_stream__mutmut_18': x_take_response_body_as_stream__mutmut_18, 
    'x_take_response_body_as_stream__mutmut_19': x_take_response_body_as_stream__mutmut_19, 
    'x_take_response_body_as_stream__mutmut_20': x_take_response_body_as_stream__mutmut_20, 
    'x_take_response_body_as_stream__mutmut_21': x_take_response_body_as_stream__mutmut_21, 
    'x_take_response_body_as_stream__mutmut_22': x_take_response_body_as_stream__mutmut_22
}

def take_response_body_as_stream(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_take_response_body_as_stream__mutmut_orig, x_take_response_body_as_stream__mutmut_mutants, args, kwargs)
    return result 

take_response_body_as_stream.__signature__ = _mutmut_signature(x_take_response_body_as_stream__mutmut_orig)
x_take_response_body_as_stream__mutmut_orig.__name__ = 'x_take_response_body_as_stream'


@event_class("Fetch.requestPaused")
@dataclass
class RequestPaused:
    """
    Issued when the domain is enabled and the request URL matches the
    specified filter. The request is paused until the client responds
    with one of continueRequest, failRequest or fulfillRequest.
    The stage of the request can be determined by presence of responseErrorReason
    and responseStatusCode -- the request is at the response stage if either
    of these fields is present and in the request stage otherwise.
    Redirect responses and subsequent requests are reported similarly to regular
    responses and requests. Redirect responses may be distinguished by the value
    of ``responseStatusCode`` (which is one of 301, 302, 303, 307, 308) along with
    presence of the ``location`` header. Requests resulting from a redirect will
    have ``redirectedRequestId`` field set.
    """
    #: Each request the page makes will have a unique id.
    request_id: RequestId
    #: The details of the request.
    request: network.Request
    #: The id of the frame that initiated the request.
    frame_id: page.FrameId
    #: How the requested resource will be used.
    resource_type: network.ResourceType
    #: Response error if intercepted at response stage.
    response_error_reason: network.ErrorReason | None
    #: Response code if intercepted at response stage.
    response_status_code: int | None
    #: Response status text if intercepted at response stage.
    response_status_text: str | None
    #: Response headers if intercepted at the response stage.
    response_headers: list[HeaderEntry] | None
    #: If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,
    #: then this networkId will be the same as the requestId present in the requestWillBeSent event.
    network_id: network.RequestId | None
    #: If the request is due to a redirect response from the server, the id of the request that
    #: has caused the redirect.
    redirected_request_id: RequestId | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> RequestPaused:
        return cls(
            request_id=RequestId.from_json(json["requestId"]),
            request=network.Request.from_json(json["request"]),
            frame_id=page.FrameId.from_json(json["frameId"]),
            resource_type=network.ResourceType.from_json(json["resourceType"]),
            response_error_reason=network.ErrorReason.from_json(json["responseErrorReason"]) if "responseErrorReason" in json else None,
            response_status_code=int(json["responseStatusCode"]) if "responseStatusCode" in json else None,
            response_status_text=str(json["responseStatusText"]) if "responseStatusText" in json else None,
            response_headers=[HeaderEntry.from_json(i) for i in json["responseHeaders"]] if "responseHeaders" in json else None,
            network_id=network.RequestId.from_json(json["networkId"]) if "networkId" in json else None,
            redirected_request_id=RequestId.from_json(json["redirectedRequestId"]) if "redirectedRequestId" in json else None,
        )


@event_class("Fetch.authRequired")
@dataclass
class AuthRequired:
    """
    Issued when the domain is enabled with handleAuthRequests set to true.
    The request is paused until client responds with continueWithAuth.
    """
    #: Each request the page makes will have a unique id.
    request_id: RequestId
    #: The details of the request.
    request: network.Request
    #: The id of the frame that initiated the request.
    frame_id: page.FrameId
    #: How the requested resource will be used.
    resource_type: network.ResourceType
    #: Details of the Authorization Challenge encountered.
    #: If this is set, client should respond with continueRequest that
    #: contains AuthChallengeResponse.
    auth_challenge: AuthChallenge

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AuthRequired:
        return cls(
            request_id=RequestId.from_json(json["requestId"]),
            request=network.Request.from_json(json["request"]),
            frame_id=page.FrameId.from_json(json["frameId"]),
            resource_type=network.ResourceType.from_json(json["resourceType"]),
            auth_challenge=AuthChallenge.from_json(json["authChallenge"]),
        )
