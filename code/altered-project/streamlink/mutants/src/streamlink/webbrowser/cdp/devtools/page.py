# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all modules.
#
# CDP version: v0.0.1438564
# CDP domain: Page

from __future__ import annotations

import enum
from collections.abc import Generator
from dataclasses import dataclass
from typing import Any

import streamlink.webbrowser.cdp.devtools.debugger as debugger
import streamlink.webbrowser.cdp.devtools.dom as dom
import streamlink.webbrowser.cdp.devtools.emulation as emulation
import streamlink.webbrowser.cdp.devtools.io as io
import streamlink.webbrowser.cdp.devtools.network as network
import streamlink.webbrowser.cdp.devtools.runtime as runtime
from streamlink.webbrowser.cdp.devtools.util import T_JSON_DICT, event_class
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


class FrameId(str):
    """
    Unique frame identifier.
    """
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> FrameId:
        return cls(json)

    def __repr__(self):
        return f"FrameId({super().__repr__()})"


class AdFrameType(enum.Enum):
    """
    Indicates whether a frame has been identified as an ad.
    """
    NONE = "none"
    CHILD = "child"
    ROOT = "root"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> AdFrameType:
        return cls(json)


class AdFrameExplanation(enum.Enum):
    PARENT_IS_AD = "ParentIsAd"
    CREATED_BY_AD_SCRIPT = "CreatedByAdScript"
    MATCHED_BLOCKING_RULE = "MatchedBlockingRule"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> AdFrameExplanation:
        return cls(json)


@dataclass
class AdFrameStatus:
    """
    Indicates whether a frame has been identified as an ad and why.
    """
    ad_frame_type: AdFrameType

    explanations: list[AdFrameExplanation] | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["adFrameType"] = self.ad_frame_type.to_json()
        if self.explanations is not None:
            json["explanations"] = [i.to_json() for i in self.explanations]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AdFrameStatus:
        return cls(
            ad_frame_type=AdFrameType.from_json(json["adFrameType"]),
            explanations=[AdFrameExplanation.from_json(i) for i in json["explanations"]] if "explanations" in json else None,
        )


@dataclass
class AdScriptId:
    """
    Identifies the bottom-most script which caused the frame to be labelled
    as an ad.
    """
    #: Script Id of the bottom-most script which caused the frame to be labelled
    #: as an ad.
    script_id: runtime.ScriptId

    #: Id of adScriptId's debugger.
    debugger_id: runtime.UniqueDebuggerId

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["scriptId"] = self.script_id.to_json()
        json["debuggerId"] = self.debugger_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AdScriptId:
        return cls(
            script_id=runtime.ScriptId.from_json(json["scriptId"]),
            debugger_id=runtime.UniqueDebuggerId.from_json(json["debuggerId"]),
        )


class SecureContextType(enum.Enum):
    """
    Indicates whether the frame is a secure context and why it is the case.
    """
    SECURE = "Secure"
    SECURE_LOCALHOST = "SecureLocalhost"
    INSECURE_SCHEME = "InsecureScheme"
    INSECURE_ANCESTOR = "InsecureAncestor"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> SecureContextType:
        return cls(json)


class CrossOriginIsolatedContextType(enum.Enum):
    """
    Indicates whether the frame is cross-origin isolated and why it is the case.
    """
    ISOLATED = "Isolated"
    NOT_ISOLATED = "NotIsolated"
    NOT_ISOLATED_FEATURE_DISABLED = "NotIsolatedFeatureDisabled"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> CrossOriginIsolatedContextType:
        return cls(json)


class GatedAPIFeatures(enum.Enum):
    SHARED_ARRAY_BUFFERS = "SharedArrayBuffers"
    SHARED_ARRAY_BUFFERS_TRANSFER_ALLOWED = "SharedArrayBuffersTransferAllowed"
    PERFORMANCE_MEASURE_MEMORY = "PerformanceMeasureMemory"
    PERFORMANCE_PROFILE = "PerformanceProfile"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> GatedAPIFeatures:
        return cls(json)


class PermissionsPolicyFeature(enum.Enum):
    """
    All Permissions Policy features. This enum should match the one defined
    in services/network/public/cpp/permissions_policy/permissions_policy_features.json5.
    """
    ACCELEROMETER = "accelerometer"
    ALL_SCREENS_CAPTURE = "all-screens-capture"
    AMBIENT_LIGHT_SENSOR = "ambient-light-sensor"
    ATTRIBUTION_REPORTING = "attribution-reporting"
    AUTOPLAY = "autoplay"
    BLUETOOTH = "bluetooth"
    BROWSING_TOPICS = "browsing-topics"
    CAMERA = "camera"
    CAPTURED_SURFACE_CONTROL = "captured-surface-control"
    CH_DPR = "ch-dpr"
    CH_DEVICE_MEMORY = "ch-device-memory"
    CH_DOWNLINK = "ch-downlink"
    CH_ECT = "ch-ect"
    CH_PREFERS_COLOR_SCHEME = "ch-prefers-color-scheme"
    CH_PREFERS_REDUCED_MOTION = "ch-prefers-reduced-motion"
    CH_PREFERS_REDUCED_TRANSPARENCY = "ch-prefers-reduced-transparency"
    CH_RTT = "ch-rtt"
    CH_SAVE_DATA = "ch-save-data"
    CH_UA = "ch-ua"
    CH_UA_ARCH = "ch-ua-arch"
    CH_UA_BITNESS = "ch-ua-bitness"
    CH_UA_HIGH_ENTROPY_VALUES = "ch-ua-high-entropy-values"
    CH_UA_PLATFORM = "ch-ua-platform"
    CH_UA_MODEL = "ch-ua-model"
    CH_UA_MOBILE = "ch-ua-mobile"
    CH_UA_FORM_FACTORS = "ch-ua-form-factors"
    CH_UA_FULL_VERSION = "ch-ua-full-version"
    CH_UA_FULL_VERSION_LIST = "ch-ua-full-version-list"
    CH_UA_PLATFORM_VERSION = "ch-ua-platform-version"
    CH_UA_WOW64 = "ch-ua-wow64"
    CH_VIEWPORT_HEIGHT = "ch-viewport-height"
    CH_VIEWPORT_WIDTH = "ch-viewport-width"
    CH_WIDTH = "ch-width"
    CLIPBOARD_READ = "clipboard-read"
    CLIPBOARD_WRITE = "clipboard-write"
    COMPUTE_PRESSURE = "compute-pressure"
    CONTROLLED_FRAME = "controlled-frame"
    CROSS_ORIGIN_ISOLATED = "cross-origin-isolated"
    DEFERRED_FETCH = "deferred-fetch"
    DEFERRED_FETCH_MINIMAL = "deferred-fetch-minimal"
    DIGITAL_CREDENTIALS_GET = "digital-credentials-get"
    DIRECT_SOCKETS = "direct-sockets"
    DIRECT_SOCKETS_PRIVATE = "direct-sockets-private"
    DISPLAY_CAPTURE = "display-capture"
    DOCUMENT_DOMAIN = "document-domain"
    ENCRYPTED_MEDIA = "encrypted-media"
    EXECUTION_WHILE_OUT_OF_VIEWPORT = "execution-while-out-of-viewport"
    EXECUTION_WHILE_NOT_RENDERED = "execution-while-not-rendered"
    FENCED_UNPARTITIONED_STORAGE_READ = "fenced-unpartitioned-storage-read"
    FOCUS_WITHOUT_USER_ACTIVATION = "focus-without-user-activation"
    FULLSCREEN = "fullscreen"
    FROBULATE = "frobulate"
    GAMEPAD = "gamepad"
    GEOLOCATION = "geolocation"
    GYROSCOPE = "gyroscope"
    HID = "hid"
    IDENTITY_CREDENTIALS_GET = "identity-credentials-get"
    IDLE_DETECTION = "idle-detection"
    INTEREST_COHORT = "interest-cohort"
    JOIN_AD_INTEREST_GROUP = "join-ad-interest-group"
    KEYBOARD_MAP = "keyboard-map"
    LANGUAGE_DETECTOR = "language-detector"
    LOCAL_FONTS = "local-fonts"
    MAGNETOMETER = "magnetometer"
    MEDIA_PLAYBACK_WHILE_NOT_VISIBLE = "media-playback-while-not-visible"
    MICROPHONE = "microphone"
    MIDI = "midi"
    OTP_CREDENTIALS = "otp-credentials"
    PAYMENT = "payment"
    PICTURE_IN_PICTURE = "picture-in-picture"
    POPINS = "popins"
    PRIVATE_AGGREGATION = "private-aggregation"
    PRIVATE_STATE_TOKEN_ISSUANCE = "private-state-token-issuance"
    PRIVATE_STATE_TOKEN_REDEMPTION = "private-state-token-redemption"
    PUBLICKEY_CREDENTIALS_CREATE = "publickey-credentials-create"
    PUBLICKEY_CREDENTIALS_GET = "publickey-credentials-get"
    REWRITER = "rewriter"
    RUN_AD_AUCTION = "run-ad-auction"
    SCREEN_WAKE_LOCK = "screen-wake-lock"
    SERIAL = "serial"
    SHARED_AUTOFILL = "shared-autofill"
    SHARED_STORAGE = "shared-storage"
    SHARED_STORAGE_SELECT_URL = "shared-storage-select-url"
    SMART_CARD = "smart-card"
    SPEAKER_SELECTION = "speaker-selection"
    STORAGE_ACCESS = "storage-access"
    SUB_APPS = "sub-apps"
    SUMMARIZER = "summarizer"
    SYNC_XHR = "sync-xhr"
    TRANSLATOR = "translator"
    UNLOAD = "unload"
    USB = "usb"
    USB_UNRESTRICTED = "usb-unrestricted"
    VERTICAL_SCROLL = "vertical-scroll"
    WEB_APP_INSTALLATION = "web-app-installation"
    WEB_PRINTING = "web-printing"
    WEB_SHARE = "web-share"
    WINDOW_MANAGEMENT = "window-management"
    WRITER = "writer"
    XR_SPATIAL_TRACKING = "xr-spatial-tracking"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> PermissionsPolicyFeature:
        return cls(json)


class PermissionsPolicyBlockReason(enum.Enum):
    """
    Reason for a permissions policy feature to be disabled.
    """
    HEADER = "Header"
    IFRAME_ATTRIBUTE = "IframeAttribute"
    IN_FENCED_FRAME_TREE = "InFencedFrameTree"
    IN_ISOLATED_APP = "InIsolatedApp"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> PermissionsPolicyBlockReason:
        return cls(json)


@dataclass
class PermissionsPolicyBlockLocator:
    frame_id: FrameId

    block_reason: PermissionsPolicyBlockReason

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["frameId"] = self.frame_id.to_json()
        json["blockReason"] = self.block_reason.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PermissionsPolicyBlockLocator:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
            block_reason=PermissionsPolicyBlockReason.from_json(json["blockReason"]),
        )


@dataclass
class PermissionsPolicyFeatureState:
    feature: PermissionsPolicyFeature

    allowed: bool

    locator: PermissionsPolicyBlockLocator | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["feature"] = self.feature.to_json()
        json["allowed"] = self.allowed
        if self.locator is not None:
            json["locator"] = self.locator.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PermissionsPolicyFeatureState:
        return cls(
            feature=PermissionsPolicyFeature.from_json(json["feature"]),
            allowed=bool(json["allowed"]),
            locator=PermissionsPolicyBlockLocator.from_json(json["locator"]) if "locator" in json else None,
        )


class OriginTrialTokenStatus(enum.Enum):
    """
    Origin Trial(https://www.chromium.org/blink/origin-trials) support.
    Status for an Origin Trial token.
    """
    SUCCESS = "Success"
    NOT_SUPPORTED = "NotSupported"
    INSECURE = "Insecure"
    EXPIRED = "Expired"
    WRONG_ORIGIN = "WrongOrigin"
    INVALID_SIGNATURE = "InvalidSignature"
    MALFORMED = "Malformed"
    WRONG_VERSION = "WrongVersion"
    FEATURE_DISABLED = "FeatureDisabled"
    TOKEN_DISABLED = "TokenDisabled"
    FEATURE_DISABLED_FOR_USER = "FeatureDisabledForUser"
    UNKNOWN_TRIAL = "UnknownTrial"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> OriginTrialTokenStatus:
        return cls(json)


class OriginTrialStatus(enum.Enum):
    """
    Status for an Origin Trial.
    """
    ENABLED = "Enabled"
    VALID_TOKEN_NOT_PROVIDED = "ValidTokenNotProvided"
    OS_NOT_SUPPORTED = "OSNotSupported"
    TRIAL_NOT_ALLOWED = "TrialNotAllowed"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> OriginTrialStatus:
        return cls(json)


class OriginTrialUsageRestriction(enum.Enum):
    NONE = "None"
    SUBSET = "Subset"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> OriginTrialUsageRestriction:
        return cls(json)


@dataclass
class OriginTrialToken:
    origin: str

    match_sub_domains: bool

    trial_name: str

    expiry_time: network.TimeSinceEpoch

    is_third_party: bool

    usage_restriction: OriginTrialUsageRestriction

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["origin"] = self.origin
        json["matchSubDomains"] = self.match_sub_domains
        json["trialName"] = self.trial_name
        json["expiryTime"] = self.expiry_time.to_json()
        json["isThirdParty"] = self.is_third_party
        json["usageRestriction"] = self.usage_restriction.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> OriginTrialToken:
        return cls(
            origin=str(json["origin"]),
            match_sub_domains=bool(json["matchSubDomains"]),
            trial_name=str(json["trialName"]),
            expiry_time=network.TimeSinceEpoch.from_json(json["expiryTime"]),
            is_third_party=bool(json["isThirdParty"]),
            usage_restriction=OriginTrialUsageRestriction.from_json(json["usageRestriction"]),
        )


@dataclass
class OriginTrialTokenWithStatus:
    raw_token_text: str

    status: OriginTrialTokenStatus

    #: ``parsedToken`` is present only when the token is extractable and
    #: parsable.
    parsed_token: OriginTrialToken | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["rawTokenText"] = self.raw_token_text
        json["status"] = self.status.to_json()
        if self.parsed_token is not None:
            json["parsedToken"] = self.parsed_token.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> OriginTrialTokenWithStatus:
        return cls(
            raw_token_text=str(json["rawTokenText"]),
            status=OriginTrialTokenStatus.from_json(json["status"]),
            parsed_token=OriginTrialToken.from_json(json["parsedToken"]) if "parsedToken" in json else None,
        )


@dataclass
class OriginTrial:
    trial_name: str

    status: OriginTrialStatus

    tokens_with_status: list[OriginTrialTokenWithStatus]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["trialName"] = self.trial_name
        json["status"] = self.status.to_json()
        json["tokensWithStatus"] = [i.to_json() for i in self.tokens_with_status]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> OriginTrial:
        return cls(
            trial_name=str(json["trialName"]),
            status=OriginTrialStatus.from_json(json["status"]),
            tokens_with_status=[OriginTrialTokenWithStatus.from_json(i) for i in json["tokensWithStatus"]],
        )


@dataclass
class SecurityOriginDetails:
    """
    Additional information about the frame document's security origin.
    """
    #: Indicates whether the frame document's security origin is one
    #: of the local hostnames (e.g. "localhost") or IP addresses (IPv4
    #: 127.0.0.0/8 or IPv6 ::1).
    is_localhost: bool

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["isLocalhost"] = self.is_localhost
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> SecurityOriginDetails:
        return cls(
            is_localhost=bool(json["isLocalhost"]),
        )


@dataclass
class Frame:
    """
    Information about the Frame on the page.
    """
    #: Frame unique identifier.
    id_: FrameId

    #: Identifier of the loader associated with this frame.
    loader_id: network.LoaderId

    #: Frame document's URL without fragment.
    url: str

    #: Frame document's registered domain, taking the public suffixes list into account.
    #: Extracted from the Frame's url.
    #: Example URLs: http://www.google.com/file.html -> "google.com"
    #:               http://a.b.co.uk/file.html      -> "b.co.uk"
    domain_and_registry: str

    #: Frame document's security origin.
    security_origin: str

    #: Frame document's mimeType as determined by the browser.
    mime_type: str

    #: Indicates whether the main document is a secure context and explains why that is the case.
    secure_context_type: SecureContextType

    #: Indicates whether this is a cross origin isolated context.
    cross_origin_isolated_context_type: CrossOriginIsolatedContextType

    #: Indicated which gated APIs / features are available.
    gated_api_features: list[GatedAPIFeatures]

    #: Parent frame identifier.
    parent_id: FrameId | None = None

    #: Frame's name as specified in the tag.
    name: str | None = None

    #: Frame document's URL fragment including the '#'.
    url_fragment: str | None = None

    #: Additional details about the frame document's security origin.
    security_origin_details: SecurityOriginDetails | None = None

    #: If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.
    unreachable_url: str | None = None

    #: Indicates whether this frame was tagged as an ad and why.
    ad_frame_status: AdFrameStatus | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["id"] = self.id_.to_json()
        json["loaderId"] = self.loader_id.to_json()
        json["url"] = self.url
        json["domainAndRegistry"] = self.domain_and_registry
        json["securityOrigin"] = self.security_origin
        json["mimeType"] = self.mime_type
        json["secureContextType"] = self.secure_context_type.to_json()
        json["crossOriginIsolatedContextType"] = self.cross_origin_isolated_context_type.to_json()
        json["gatedAPIFeatures"] = [i.to_json() for i in self.gated_api_features]
        if self.parent_id is not None:
            json["parentId"] = self.parent_id.to_json()
        if self.name is not None:
            json["name"] = self.name
        if self.url_fragment is not None:
            json["urlFragment"] = self.url_fragment
        if self.security_origin_details is not None:
            json["securityOriginDetails"] = self.security_origin_details.to_json()
        if self.unreachable_url is not None:
            json["unreachableUrl"] = self.unreachable_url
        if self.ad_frame_status is not None:
            json["adFrameStatus"] = self.ad_frame_status.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Frame:
        return cls(
            id_=FrameId.from_json(json["id"]),
            loader_id=network.LoaderId.from_json(json["loaderId"]),
            url=str(json["url"]),
            domain_and_registry=str(json["domainAndRegistry"]),
            security_origin=str(json["securityOrigin"]),
            mime_type=str(json["mimeType"]),
            secure_context_type=SecureContextType.from_json(json["secureContextType"]),
            cross_origin_isolated_context_type=CrossOriginIsolatedContextType.from_json(json["crossOriginIsolatedContextType"]),
            gated_api_features=[GatedAPIFeatures.from_json(i) for i in json["gatedAPIFeatures"]],
            parent_id=FrameId.from_json(json["parentId"]) if "parentId" in json else None,
            name=str(json["name"]) if "name" in json else None,
            url_fragment=str(json["urlFragment"]) if "urlFragment" in json else None,
            security_origin_details=SecurityOriginDetails.from_json(json["securityOriginDetails"]) if "securityOriginDetails" in json else None,
            unreachable_url=str(json["unreachableUrl"]) if "unreachableUrl" in json else None,
            ad_frame_status=AdFrameStatus.from_json(json["adFrameStatus"]) if "adFrameStatus" in json else None,
        )


@dataclass
class FrameResource:
    """
    Information about the Resource on the page.
    """
    #: Resource URL.
    url: str

    #: Type of this resource.
    type_: network.ResourceType

    #: Resource mimeType as determined by the browser.
    mime_type: str

    #: last-modified timestamp as reported by server.
    last_modified: network.TimeSinceEpoch | None = None

    #: Resource content size.
    content_size: float | None = None

    #: True if the resource failed to load.
    failed: bool | None = None

    #: True if the resource was canceled during loading.
    canceled: bool | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["url"] = self.url
        json["type"] = self.type_.to_json()
        json["mimeType"] = self.mime_type
        if self.last_modified is not None:
            json["lastModified"] = self.last_modified.to_json()
        if self.content_size is not None:
            json["contentSize"] = self.content_size
        if self.failed is not None:
            json["failed"] = self.failed
        if self.canceled is not None:
            json["canceled"] = self.canceled
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameResource:
        return cls(
            url=str(json["url"]),
            type_=network.ResourceType.from_json(json["type"]),
            mime_type=str(json["mimeType"]),
            last_modified=network.TimeSinceEpoch.from_json(json["lastModified"]) if "lastModified" in json else None,
            content_size=float(json["contentSize"]) if "contentSize" in json else None,
            failed=bool(json["failed"]) if "failed" in json else None,
            canceled=bool(json["canceled"]) if "canceled" in json else None,
        )


@dataclass
class FrameResourceTree:
    """
    Information about the Frame hierarchy along with their cached resources.
    """
    #: Frame information for this tree item.
    frame: Frame

    #: Information about frame resources.
    resources: list[FrameResource]

    #: Child frames.
    child_frames: list[FrameResourceTree] | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["frame"] = self.frame.to_json()
        json["resources"] = [i.to_json() for i in self.resources]
        if self.child_frames is not None:
            json["childFrames"] = [i.to_json() for i in self.child_frames]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameResourceTree:
        return cls(
            frame=Frame.from_json(json["frame"]),
            resources=[FrameResource.from_json(i) for i in json["resources"]],
            child_frames=[FrameResourceTree.from_json(i) for i in json["childFrames"]] if "childFrames" in json else None,
        )


@dataclass
class FrameTree:
    """
    Information about the Frame hierarchy.
    """
    #: Frame information for this tree item.
    frame: Frame

    #: Child frames.
    child_frames: list[FrameTree] | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["frame"] = self.frame.to_json()
        if self.child_frames is not None:
            json["childFrames"] = [i.to_json() for i in self.child_frames]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameTree:
        return cls(
            frame=Frame.from_json(json["frame"]),
            child_frames=[FrameTree.from_json(i) for i in json["childFrames"]] if "childFrames" in json else None,
        )


class ScriptIdentifier(str):
    """
    Unique script identifier.
    """
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> ScriptIdentifier:
        return cls(json)

    def __repr__(self):
        return f"ScriptIdentifier({super().__repr__()})"


class TransitionType(enum.Enum):
    """
    Transition type.
    """
    LINK = "link"
    TYPED = "typed"
    ADDRESS_BAR = "address_bar"
    AUTO_BOOKMARK = "auto_bookmark"
    AUTO_SUBFRAME = "auto_subframe"
    MANUAL_SUBFRAME = "manual_subframe"
    GENERATED = "generated"
    AUTO_TOPLEVEL = "auto_toplevel"
    FORM_SUBMIT = "form_submit"
    RELOAD = "reload"
    KEYWORD = "keyword"
    KEYWORD_GENERATED = "keyword_generated"
    OTHER = "other"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> TransitionType:
        return cls(json)


@dataclass
class NavigationEntry:
    """
    Navigation history entry.
    """
    #: Unique id of the navigation history entry.
    id_: int

    #: URL of the navigation history entry.
    url: str

    #: URL that the user typed in the url bar.
    user_typed_url: str

    #: Title of the navigation history entry.
    title: str

    #: Transition type.
    transition_type: TransitionType

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["id"] = self.id_
        json["url"] = self.url
        json["userTypedURL"] = self.user_typed_url
        json["title"] = self.title
        json["transitionType"] = self.transition_type.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> NavigationEntry:
        return cls(
            id_=int(json["id"]),
            url=str(json["url"]),
            user_typed_url=str(json["userTypedURL"]),
            title=str(json["title"]),
            transition_type=TransitionType.from_json(json["transitionType"]),
        )


@dataclass
class ScreencastFrameMetadata:
    """
    Screencast frame metadata.
    """
    #: Top offset in DIP.
    offset_top: float

    #: Page scale factor.
    page_scale_factor: float

    #: Device screen width in DIP.
    device_width: float

    #: Device screen height in DIP.
    device_height: float

    #: Position of horizontal scroll in CSS pixels.
    scroll_offset_x: float

    #: Position of vertical scroll in CSS pixels.
    scroll_offset_y: float

    #: Frame swap timestamp.
    timestamp: network.TimeSinceEpoch | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["offsetTop"] = self.offset_top
        json["pageScaleFactor"] = self.page_scale_factor
        json["deviceWidth"] = self.device_width
        json["deviceHeight"] = self.device_height
        json["scrollOffsetX"] = self.scroll_offset_x
        json["scrollOffsetY"] = self.scroll_offset_y
        if self.timestamp is not None:
            json["timestamp"] = self.timestamp.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScreencastFrameMetadata:
        return cls(
            offset_top=float(json["offsetTop"]),
            page_scale_factor=float(json["pageScaleFactor"]),
            device_width=float(json["deviceWidth"]),
            device_height=float(json["deviceHeight"]),
            scroll_offset_x=float(json["scrollOffsetX"]),
            scroll_offset_y=float(json["scrollOffsetY"]),
            timestamp=network.TimeSinceEpoch.from_json(json["timestamp"]) if "timestamp" in json else None,
        )


class DialogType(enum.Enum):
    """
    Javascript dialog type.
    """
    ALERT = "alert"
    CONFIRM = "confirm"
    PROMPT = "prompt"
    BEFOREUNLOAD = "beforeunload"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> DialogType:
        return cls(json)


@dataclass
class AppManifestError:
    """
    Error while paring app manifest.
    """
    #: Error message.
    message: str

    #: If critical, this is a non-recoverable parse error.
    critical: int

    #: Error line.
    line: int

    #: Error column.
    column: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["message"] = self.message
        json["critical"] = self.critical
        json["line"] = self.line
        json["column"] = self.column
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AppManifestError:
        return cls(
            message=str(json["message"]),
            critical=int(json["critical"]),
            line=int(json["line"]),
            column=int(json["column"]),
        )


@dataclass
class AppManifestParsedProperties:
    """
    Parsed app manifest properties.
    """
    #: Computed scope value
    scope: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["scope"] = self.scope
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AppManifestParsedProperties:
        return cls(
            scope=str(json["scope"]),
        )


@dataclass
class LayoutViewport:
    """
    Layout viewport position and dimensions.
    """
    #: Horizontal offset relative to the document (CSS pixels).
    page_x: int

    #: Vertical offset relative to the document (CSS pixels).
    page_y: int

    #: Width (CSS pixels), excludes scrollbar if present.
    client_width: int

    #: Height (CSS pixels), excludes scrollbar if present.
    client_height: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["pageX"] = self.page_x
        json["pageY"] = self.page_y
        json["clientWidth"] = self.client_width
        json["clientHeight"] = self.client_height
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> LayoutViewport:
        return cls(
            page_x=int(json["pageX"]),
            page_y=int(json["pageY"]),
            client_width=int(json["clientWidth"]),
            client_height=int(json["clientHeight"]),
        )


@dataclass
class VisualViewport:
    """
    Visual viewport position, dimensions, and scale.
    """
    #: Horizontal offset relative to the layout viewport (CSS pixels).
    offset_x: float

    #: Vertical offset relative to the layout viewport (CSS pixels).
    offset_y: float

    #: Horizontal offset relative to the document (CSS pixels).
    page_x: float

    #: Vertical offset relative to the document (CSS pixels).
    page_y: float

    #: Width (CSS pixels), excludes scrollbar if present.
    client_width: float

    #: Height (CSS pixels), excludes scrollbar if present.
    client_height: float

    #: Scale relative to the ideal viewport (size at width=device-width).
    scale: float

    #: Page zoom factor (CSS to device independent pixels ratio).
    zoom: float | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["offsetX"] = self.offset_x
        json["offsetY"] = self.offset_y
        json["pageX"] = self.page_x
        json["pageY"] = self.page_y
        json["clientWidth"] = self.client_width
        json["clientHeight"] = self.client_height
        json["scale"] = self.scale
        if self.zoom is not None:
            json["zoom"] = self.zoom
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> VisualViewport:
        return cls(
            offset_x=float(json["offsetX"]),
            offset_y=float(json["offsetY"]),
            page_x=float(json["pageX"]),
            page_y=float(json["pageY"]),
            client_width=float(json["clientWidth"]),
            client_height=float(json["clientHeight"]),
            scale=float(json["scale"]),
            zoom=float(json["zoom"]) if "zoom" in json else None,
        )


@dataclass
class Viewport:
    """
    Viewport for capturing screenshot.
    """
    #: X offset in device independent pixels (dip).
    x: float

    #: Y offset in device independent pixels (dip).
    y: float

    #: Rectangle width in device independent pixels (dip).
    width: float

    #: Rectangle height in device independent pixels (dip).
    height: float

    #: Page scale factor.
    scale: float

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["x"] = self.x
        json["y"] = self.y
        json["width"] = self.width
        json["height"] = self.height
        json["scale"] = self.scale
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Viewport:
        return cls(
            x=float(json["x"]),
            y=float(json["y"]),
            width=float(json["width"]),
            height=float(json["height"]),
            scale=float(json["scale"]),
        )


@dataclass
class FontFamilies:
    """
    Generic font families collection.
    """
    #: The standard font-family.
    standard: str | None = None

    #: The fixed font-family.
    fixed: str | None = None

    #: The serif font-family.
    serif: str | None = None

    #: The sansSerif font-family.
    sans_serif: str | None = None

    #: The cursive font-family.
    cursive: str | None = None

    #: The fantasy font-family.
    fantasy: str | None = None

    #: The math font-family.
    math: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.standard is not None:
            json["standard"] = self.standard
        if self.fixed is not None:
            json["fixed"] = self.fixed
        if self.serif is not None:
            json["serif"] = self.serif
        if self.sans_serif is not None:
            json["sansSerif"] = self.sans_serif
        if self.cursive is not None:
            json["cursive"] = self.cursive
        if self.fantasy is not None:
            json["fantasy"] = self.fantasy
        if self.math is not None:
            json["math"] = self.math
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FontFamilies:
        return cls(
            standard=str(json["standard"]) if "standard" in json else None,
            fixed=str(json["fixed"]) if "fixed" in json else None,
            serif=str(json["serif"]) if "serif" in json else None,
            sans_serif=str(json["sansSerif"]) if "sansSerif" in json else None,
            cursive=str(json["cursive"]) if "cursive" in json else None,
            fantasy=str(json["fantasy"]) if "fantasy" in json else None,
            math=str(json["math"]) if "math" in json else None,
        )


@dataclass
class ScriptFontFamilies:
    """
    Font families collection for a script.
    """
    #: Name of the script which these font families are defined for.
    script: str

    #: Generic font families collection for the script.
    font_families: FontFamilies

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["script"] = self.script
        json["fontFamilies"] = self.font_families.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScriptFontFamilies:
        return cls(
            script=str(json["script"]),
            font_families=FontFamilies.from_json(json["fontFamilies"]),
        )


@dataclass
class FontSizes:
    """
    Default font sizes.
    """
    #: Default standard font size.
    standard: int | None = None

    #: Default fixed font size.
    fixed: int | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.standard is not None:
            json["standard"] = self.standard
        if self.fixed is not None:
            json["fixed"] = self.fixed
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FontSizes:
        return cls(
            standard=int(json["standard"]) if "standard" in json else None,
            fixed=int(json["fixed"]) if "fixed" in json else None,
        )


class ClientNavigationReason(enum.Enum):
    ANCHOR_CLICK = "anchorClick"
    FORM_SUBMISSION_GET = "formSubmissionGet"
    FORM_SUBMISSION_POST = "formSubmissionPost"
    HTTP_HEADER_REFRESH = "httpHeaderRefresh"
    INITIAL_FRAME_NAVIGATION = "initialFrameNavigation"
    META_TAG_REFRESH = "metaTagRefresh"
    OTHER = "other"
    PAGE_BLOCK_INTERSTITIAL = "pageBlockInterstitial"
    RELOAD = "reload"
    SCRIPT_INITIATED = "scriptInitiated"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> ClientNavigationReason:
        return cls(json)


class ClientNavigationDisposition(enum.Enum):
    CURRENT_TAB = "currentTab"
    NEW_TAB = "newTab"
    NEW_WINDOW = "newWindow"
    DOWNLOAD = "download"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> ClientNavigationDisposition:
        return cls(json)


@dataclass
class InstallabilityErrorArgument:
    #: Argument name (e.g. name:'minimum-icon-size-in-pixels').
    name: str

    #: Argument value (e.g. value:'64').
    value: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["name"] = self.name
        json["value"] = self.value
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> InstallabilityErrorArgument:
        return cls(
            name=str(json["name"]),
            value=str(json["value"]),
        )


@dataclass
class InstallabilityError:
    """
    The installability error
    """
    #: The error id (e.g. 'manifest-missing-suitable-icon').
    error_id: str

    #: The list of error arguments (e.g. {name:'minimum-icon-size-in-pixels', value:'64'}).
    error_arguments: list[InstallabilityErrorArgument]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["errorId"] = self.error_id
        json["errorArguments"] = [i.to_json() for i in self.error_arguments]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> InstallabilityError:
        return cls(
            error_id=str(json["errorId"]),
            error_arguments=[InstallabilityErrorArgument.from_json(i) for i in json["errorArguments"]],
        )


class ReferrerPolicy(enum.Enum):
    """
    The referring-policy used for the navigation.
    """
    NO_REFERRER = "noReferrer"
    NO_REFERRER_WHEN_DOWNGRADE = "noReferrerWhenDowngrade"
    ORIGIN = "origin"
    ORIGIN_WHEN_CROSS_ORIGIN = "originWhenCrossOrigin"
    SAME_ORIGIN = "sameOrigin"
    STRICT_ORIGIN = "strictOrigin"
    STRICT_ORIGIN_WHEN_CROSS_ORIGIN = "strictOriginWhenCrossOrigin"
    UNSAFE_URL = "unsafeUrl"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> ReferrerPolicy:
        return cls(json)


@dataclass
class CompilationCacheParams:
    """
    Per-script compilation cache parameters for ``Page.produceCompilationCache``
    """
    #: The URL of the script to produce a compilation cache entry for.
    url: str

    #: A hint to the backend whether eager compilation is recommended.
    #: (the actual compilation mode used is upon backend discretion).
    eager: bool | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["url"] = self.url
        if self.eager is not None:
            json["eager"] = self.eager
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CompilationCacheParams:
        return cls(
            url=str(json["url"]),
            eager=bool(json["eager"]) if "eager" in json else None,
        )


@dataclass
class FileFilter:
    name: str | None = None

    accepts: list[str] | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.name is not None:
            json["name"] = self.name
        if self.accepts is not None:
            json["accepts"] = list(self.accepts)
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FileFilter:
        return cls(
            name=str(json["name"]) if "name" in json else None,
            accepts=[str(i) for i in json["accepts"]] if "accepts" in json else None,
        )


@dataclass
class FileHandler:
    action: str

    name: str

    #: Won't repeat the enums, using string for easy comparison. Same as the
    #: other enums below.
    launch_type: str

    icons: list[ImageResource] | None = None

    #: Mimic a map, name is the key, accepts is the value.
    accepts: list[FileFilter] | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["action"] = self.action
        json["name"] = self.name
        json["launchType"] = self.launch_type
        if self.icons is not None:
            json["icons"] = [i.to_json() for i in self.icons]
        if self.accepts is not None:
            json["accepts"] = [i.to_json() for i in self.accepts]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FileHandler:
        return cls(
            action=str(json["action"]),
            name=str(json["name"]),
            launch_type=str(json["launchType"]),
            icons=[ImageResource.from_json(i) for i in json["icons"]] if "icons" in json else None,
            accepts=[FileFilter.from_json(i) for i in json["accepts"]] if "accepts" in json else None,
        )


@dataclass
class ImageResource:
    """
    The image definition used in both icon and screenshot.
    """
    #: The src field in the definition, but changing to url in favor of
    #: consistency.
    url: str

    sizes: str | None = None

    type_: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["url"] = self.url
        if self.sizes is not None:
            json["sizes"] = self.sizes
        if self.type_ is not None:
            json["type"] = self.type_
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ImageResource:
        return cls(
            url=str(json["url"]),
            sizes=str(json["sizes"]) if "sizes" in json else None,
            type_=str(json["type"]) if "type" in json else None,
        )


@dataclass
class LaunchHandler:
    client_mode: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["clientMode"] = self.client_mode
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> LaunchHandler:
        return cls(
            client_mode=str(json["clientMode"]),
        )


@dataclass
class ProtocolHandler:
    protocol: str

    url: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["protocol"] = self.protocol
        json["url"] = self.url
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ProtocolHandler:
        return cls(
            protocol=str(json["protocol"]),
            url=str(json["url"]),
        )


@dataclass
class RelatedApplication:
    url: str

    id_: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["url"] = self.url
        if self.id_ is not None:
            json["id"] = self.id_
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> RelatedApplication:
        return cls(
            url=str(json["url"]),
            id_=str(json["id"]) if "id" in json else None,
        )


@dataclass
class ScopeExtension:
    #: Instead of using tuple, this field always returns the serialized string
    #: for easy understanding and comparison.
    origin: str

    has_origin_wildcard: bool

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["origin"] = self.origin
        json["hasOriginWildcard"] = self.has_origin_wildcard
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScopeExtension:
        return cls(
            origin=str(json["origin"]),
            has_origin_wildcard=bool(json["hasOriginWildcard"]),
        )


@dataclass
class Screenshot:
    image: ImageResource

    form_factor: str

    label: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["image"] = self.image.to_json()
        json["formFactor"] = self.form_factor
        if self.label is not None:
            json["label"] = self.label
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Screenshot:
        return cls(
            image=ImageResource.from_json(json["image"]),
            form_factor=str(json["formFactor"]),
            label=str(json["label"]) if "label" in json else None,
        )


@dataclass
class ShareTarget:
    action: str

    method: str

    enctype: str

    #: Embed the ShareTargetParams
    title: str | None = None

    text: str | None = None

    url: str | None = None

    files: list[FileFilter] | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["action"] = self.action
        json["method"] = self.method
        json["enctype"] = self.enctype
        if self.title is not None:
            json["title"] = self.title
        if self.text is not None:
            json["text"] = self.text
        if self.url is not None:
            json["url"] = self.url
        if self.files is not None:
            json["files"] = [i.to_json() for i in self.files]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ShareTarget:
        return cls(
            action=str(json["action"]),
            method=str(json["method"]),
            enctype=str(json["enctype"]),
            title=str(json["title"]) if "title" in json else None,
            text=str(json["text"]) if "text" in json else None,
            url=str(json["url"]) if "url" in json else None,
            files=[FileFilter.from_json(i) for i in json["files"]] if "files" in json else None,
        )


@dataclass
class Shortcut:
    name: str

    url: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["name"] = self.name
        json["url"] = self.url
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Shortcut:
        return cls(
            name=str(json["name"]),
            url=str(json["url"]),
        )


@dataclass
class WebAppManifest:
    background_color: str | None = None

    #: The extra description provided by the manifest.
    description: str | None = None

    dir_: str | None = None

    display: str | None = None

    #: The overrided display mode controlled by the user.
    display_overrides: list[str] | None = None

    #: The handlers to open files.
    file_handlers: list[FileHandler] | None = None

    icons: list[ImageResource] | None = None

    id_: str | None = None

    lang: str | None = None

    #: TODO(crbug.com/1231886): This field is non-standard and part of a Chrome
    #: experiment. See:
    #: https://github.com/WICG/web-app-launch/blob/main/launch_handler.md
    launch_handler: LaunchHandler | None = None

    name: str | None = None

    orientation: str | None = None

    prefer_related_applications: bool | None = None

    #: The handlers to open protocols.
    protocol_handlers: list[ProtocolHandler] | None = None

    related_applications: list[RelatedApplication] | None = None

    scope: str | None = None

    #: Non-standard, see
    #: https://github.com/WICG/manifest-incubations/blob/gh-pages/scope_extensions-explainer.md
    scope_extensions: list[ScopeExtension] | None = None

    #: The screenshots used by chromium.
    screenshots: list[Screenshot] | None = None

    share_target: ShareTarget | None = None

    short_name: str | None = None

    shortcuts: list[Shortcut] | None = None

    start_url: str | None = None

    theme_color: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.background_color is not None:
            json["backgroundColor"] = self.background_color
        if self.description is not None:
            json["description"] = self.description
        if self.dir_ is not None:
            json["dir"] = self.dir_
        if self.display is not None:
            json["display"] = self.display
        if self.display_overrides is not None:
            json["displayOverrides"] = list(self.display_overrides)
        if self.file_handlers is not None:
            json["fileHandlers"] = [i.to_json() for i in self.file_handlers]
        if self.icons is not None:
            json["icons"] = [i.to_json() for i in self.icons]
        if self.id_ is not None:
            json["id"] = self.id_
        if self.lang is not None:
            json["lang"] = self.lang
        if self.launch_handler is not None:
            json["launchHandler"] = self.launch_handler.to_json()
        if self.name is not None:
            json["name"] = self.name
        if self.orientation is not None:
            json["orientation"] = self.orientation
        if self.prefer_related_applications is not None:
            json["preferRelatedApplications"] = self.prefer_related_applications
        if self.protocol_handlers is not None:
            json["protocolHandlers"] = [i.to_json() for i in self.protocol_handlers]
        if self.related_applications is not None:
            json["relatedApplications"] = [i.to_json() for i in self.related_applications]
        if self.scope is not None:
            json["scope"] = self.scope
        if self.scope_extensions is not None:
            json["scopeExtensions"] = [i.to_json() for i in self.scope_extensions]
        if self.screenshots is not None:
            json["screenshots"] = [i.to_json() for i in self.screenshots]
        if self.share_target is not None:
            json["shareTarget"] = self.share_target.to_json()
        if self.short_name is not None:
            json["shortName"] = self.short_name
        if self.shortcuts is not None:
            json["shortcuts"] = [i.to_json() for i in self.shortcuts]
        if self.start_url is not None:
            json["startUrl"] = self.start_url
        if self.theme_color is not None:
            json["themeColor"] = self.theme_color
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> WebAppManifest:
        return cls(
            background_color=str(json["backgroundColor"]) if "backgroundColor" in json else None,
            description=str(json["description"]) if "description" in json else None,
            dir_=str(json["dir"]) if "dir" in json else None,
            display=str(json["display"]) if "display" in json else None,
            display_overrides=[str(i) for i in json["displayOverrides"]] if "displayOverrides" in json else None,
            file_handlers=[FileHandler.from_json(i) for i in json["fileHandlers"]] if "fileHandlers" in json else None,
            icons=[ImageResource.from_json(i) for i in json["icons"]] if "icons" in json else None,
            id_=str(json["id"]) if "id" in json else None,
            lang=str(json["lang"]) if "lang" in json else None,
            launch_handler=LaunchHandler.from_json(json["launchHandler"]) if "launchHandler" in json else None,
            name=str(json["name"]) if "name" in json else None,
            orientation=str(json["orientation"]) if "orientation" in json else None,
            prefer_related_applications=bool(json["preferRelatedApplications"]) if "preferRelatedApplications" in json else None,
            protocol_handlers=[ProtocolHandler.from_json(i) for i in json["protocolHandlers"]] if "protocolHandlers" in json else None,
            related_applications=[RelatedApplication.from_json(i) for i in json["relatedApplications"]] if "relatedApplications" in json else None,
            scope=str(json["scope"]) if "scope" in json else None,
            scope_extensions=[ScopeExtension.from_json(i) for i in json["scopeExtensions"]] if "scopeExtensions" in json else None,
            screenshots=[Screenshot.from_json(i) for i in json["screenshots"]] if "screenshots" in json else None,
            share_target=ShareTarget.from_json(json["shareTarget"]) if "shareTarget" in json else None,
            short_name=str(json["shortName"]) if "shortName" in json else None,
            shortcuts=[Shortcut.from_json(i) for i in json["shortcuts"]] if "shortcuts" in json else None,
            start_url=str(json["startUrl"]) if "startUrl" in json else None,
            theme_color=str(json["themeColor"]) if "themeColor" in json else None,
        )


class AutoResponseMode(enum.Enum):
    """
    Enum of possible auto-response for permission / prompt dialogs.
    """
    NONE = "none"
    AUTO_ACCEPT = "autoAccept"
    AUTO_REJECT = "autoReject"
    AUTO_OPT_OUT = "autoOptOut"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> AutoResponseMode:
        return cls(json)


class NavigationType(enum.Enum):
    """
    The type of a frameNavigated event.
    """
    NAVIGATION = "Navigation"
    BACK_FORWARD_CACHE_RESTORE = "BackForwardCacheRestore"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> NavigationType:
        return cls(json)


class BackForwardCacheNotRestoredReason(enum.Enum):
    """
    List of not restored reasons for back-forward cache.
    """
    NOT_PRIMARY_MAIN_FRAME = "NotPrimaryMainFrame"
    BACK_FORWARD_CACHE_DISABLED = "BackForwardCacheDisabled"
    RELATED_ACTIVE_CONTENTS_EXIST = "RelatedActiveContentsExist"
    HTTP_STATUS_NOT_OK = "HTTPStatusNotOK"
    SCHEME_NOT_HTTP_OR_HTTPS = "SchemeNotHTTPOrHTTPS"
    LOADING = "Loading"
    WAS_GRANTED_MEDIA_ACCESS = "WasGrantedMediaAccess"
    DISABLE_FOR_RENDER_FRAME_HOST_CALLED = "DisableForRenderFrameHostCalled"
    DOMAIN_NOT_ALLOWED = "DomainNotAllowed"
    HTTP_METHOD_NOT_GET = "HTTPMethodNotGET"
    SUBFRAME_IS_NAVIGATING = "SubframeIsNavigating"
    TIMEOUT = "Timeout"
    CACHE_LIMIT = "CacheLimit"
    JAVA_SCRIPT_EXECUTION = "JavaScriptExecution"
    RENDERER_PROCESS_KILLED = "RendererProcessKilled"
    RENDERER_PROCESS_CRASHED = "RendererProcessCrashed"
    SCHEDULER_TRACKED_FEATURE_USED = "SchedulerTrackedFeatureUsed"
    CONFLICTING_BROWSING_INSTANCE = "ConflictingBrowsingInstance"
    CACHE_FLUSHED = "CacheFlushed"
    SERVICE_WORKER_VERSION_ACTIVATION = "ServiceWorkerVersionActivation"
    SESSION_RESTORED = "SessionRestored"
    SERVICE_WORKER_POST_MESSAGE = "ServiceWorkerPostMessage"
    ENTERED_BACK_FORWARD_CACHE_BEFORE_SERVICE_WORKER_HOST_ADDED = "EnteredBackForwardCacheBeforeServiceWorkerHostAdded"
    RENDER_FRAME_HOST_REUSED_SAME_SITE = "RenderFrameHostReused_SameSite"
    RENDER_FRAME_HOST_REUSED_CROSS_SITE = "RenderFrameHostReused_CrossSite"
    SERVICE_WORKER_CLAIM = "ServiceWorkerClaim"
    IGNORE_EVENT_AND_EVICT = "IgnoreEventAndEvict"
    HAVE_INNER_CONTENTS = "HaveInnerContents"
    TIMEOUT_PUTTING_IN_CACHE = "TimeoutPuttingInCache"
    BACK_FORWARD_CACHE_DISABLED_BY_LOW_MEMORY = "BackForwardCacheDisabledByLowMemory"
    BACK_FORWARD_CACHE_DISABLED_BY_COMMAND_LINE = "BackForwardCacheDisabledByCommandLine"
    NETWORK_REQUEST_DATAPIPE_DRAINED_AS_BYTES_CONSUMER = "NetworkRequestDatapipeDrainedAsBytesConsumer"
    NETWORK_REQUEST_REDIRECTED = "NetworkRequestRedirected"
    NETWORK_REQUEST_TIMEOUT = "NetworkRequestTimeout"
    NETWORK_EXCEEDS_BUFFER_LIMIT = "NetworkExceedsBufferLimit"
    NAVIGATION_CANCELLED_WHILE_RESTORING = "NavigationCancelledWhileRestoring"
    NOT_MOST_RECENT_NAVIGATION_ENTRY = "NotMostRecentNavigationEntry"
    BACK_FORWARD_CACHE_DISABLED_FOR_PRERENDER = "BackForwardCacheDisabledForPrerender"
    USER_AGENT_OVERRIDE_DIFFERS = "UserAgentOverrideDiffers"
    FOREGROUND_CACHE_LIMIT = "ForegroundCacheLimit"
    BROWSING_INSTANCE_NOT_SWAPPED = "BrowsingInstanceNotSwapped"
    BACK_FORWARD_CACHE_DISABLED_FOR_DELEGATE = "BackForwardCacheDisabledForDelegate"
    UNLOAD_HANDLER_EXISTS_IN_MAIN_FRAME = "UnloadHandlerExistsInMainFrame"
    UNLOAD_HANDLER_EXISTS_IN_SUB_FRAME = "UnloadHandlerExistsInSubFrame"
    SERVICE_WORKER_UNREGISTRATION = "ServiceWorkerUnregistration"
    CACHE_CONTROL_NO_STORE = "CacheControlNoStore"
    CACHE_CONTROL_NO_STORE_COOKIE_MODIFIED = "CacheControlNoStoreCookieModified"
    CACHE_CONTROL_NO_STORE_HTTP_ONLY_COOKIE_MODIFIED = "CacheControlNoStoreHTTPOnlyCookieModified"
    NO_RESPONSE_HEAD = "NoResponseHead"
    UNKNOWN = "Unknown"
    ACTIVATION_NAVIGATIONS_DISALLOWED_FOR_BUG1234857 = "ActivationNavigationsDisallowedForBug1234857"
    ERROR_DOCUMENT = "ErrorDocument"
    FENCED_FRAMES_EMBEDDER = "FencedFramesEmbedder"
    COOKIE_DISABLED = "CookieDisabled"
    HTTP_AUTH_REQUIRED = "HTTPAuthRequired"
    COOKIE_FLUSHED = "CookieFlushed"
    BROADCAST_CHANNEL_ON_MESSAGE = "BroadcastChannelOnMessage"
    WEB_VIEW_SETTINGS_CHANGED = "WebViewSettingsChanged"
    WEB_VIEW_JAVA_SCRIPT_OBJECT_CHANGED = "WebViewJavaScriptObjectChanged"
    WEB_VIEW_MESSAGE_LISTENER_INJECTED = "WebViewMessageListenerInjected"
    WEB_VIEW_SAFE_BROWSING_ALLOWLIST_CHANGED = "WebViewSafeBrowsingAllowlistChanged"
    WEB_VIEW_DOCUMENT_START_JAVASCRIPT_CHANGED = "WebViewDocumentStartJavascriptChanged"
    WEB_SOCKET = "WebSocket"
    WEB_TRANSPORT = "WebTransport"
    WEB_RTC = "WebRTC"
    MAIN_RESOURCE_HAS_CACHE_CONTROL_NO_STORE = "MainResourceHasCacheControlNoStore"
    MAIN_RESOURCE_HAS_CACHE_CONTROL_NO_CACHE = "MainResourceHasCacheControlNoCache"
    SUBRESOURCE_HAS_CACHE_CONTROL_NO_STORE = "SubresourceHasCacheControlNoStore"
    SUBRESOURCE_HAS_CACHE_CONTROL_NO_CACHE = "SubresourceHasCacheControlNoCache"
    CONTAINS_PLUGINS = "ContainsPlugins"
    DOCUMENT_LOADED = "DocumentLoaded"
    OUTSTANDING_NETWORK_REQUEST_OTHERS = "OutstandingNetworkRequestOthers"
    REQUESTED_MIDI_PERMISSION = "RequestedMIDIPermission"
    REQUESTED_AUDIO_CAPTURE_PERMISSION = "RequestedAudioCapturePermission"
    REQUESTED_VIDEO_CAPTURE_PERMISSION = "RequestedVideoCapturePermission"
    REQUESTED_BACK_FORWARD_CACHE_BLOCKED_SENSORS = "RequestedBackForwardCacheBlockedSensors"
    REQUESTED_BACKGROUND_WORK_PERMISSION = "RequestedBackgroundWorkPermission"
    BROADCAST_CHANNEL = "BroadcastChannel"
    WEB_XR = "WebXR"
    SHARED_WORKER = "SharedWorker"
    WEB_LOCKS = "WebLocks"
    WEB_HID = "WebHID"
    WEB_SHARE = "WebShare"
    REQUESTED_STORAGE_ACCESS_GRANT = "RequestedStorageAccessGrant"
    WEB_NFC = "WebNfc"
    OUTSTANDING_NETWORK_REQUEST_FETCH = "OutstandingNetworkRequestFetch"
    OUTSTANDING_NETWORK_REQUEST_XHR = "OutstandingNetworkRequestXHR"
    APP_BANNER = "AppBanner"
    PRINTING = "Printing"
    WEB_DATABASE = "WebDatabase"
    PICTURE_IN_PICTURE = "PictureInPicture"
    SPEECH_RECOGNIZER = "SpeechRecognizer"
    IDLE_MANAGER = "IdleManager"
    PAYMENT_MANAGER = "PaymentManager"
    SPEECH_SYNTHESIS = "SpeechSynthesis"
    KEYBOARD_LOCK = "KeyboardLock"
    WEB_OTP_SERVICE = "WebOTPService"
    OUTSTANDING_NETWORK_REQUEST_DIRECT_SOCKET = "OutstandingNetworkRequestDirectSocket"
    INJECTED_JAVASCRIPT = "InjectedJavascript"
    INJECTED_STYLE_SHEET = "InjectedStyleSheet"
    KEEPALIVE_REQUEST = "KeepaliveRequest"
    INDEXED_DB_EVENT = "IndexedDBEvent"
    DUMMY = "Dummy"
    JS_NETWORK_REQUEST_RECEIVED_CACHE_CONTROL_NO_STORE_RESOURCE = "JsNetworkRequestReceivedCacheControlNoStoreResource"
    WEB_RTC_STICKY = "WebRTCSticky"
    WEB_TRANSPORT_STICKY = "WebTransportSticky"
    WEB_SOCKET_STICKY = "WebSocketSticky"
    SMART_CARD = "SmartCard"
    LIVE_MEDIA_STREAM_TRACK = "LiveMediaStreamTrack"
    UNLOAD_HANDLER = "UnloadHandler"
    PARSER_ABORTED = "ParserAborted"
    CONTENT_SECURITY_HANDLER = "ContentSecurityHandler"
    CONTENT_WEB_AUTHENTICATION_API = "ContentWebAuthenticationAPI"
    CONTENT_FILE_CHOOSER = "ContentFileChooser"
    CONTENT_SERIAL = "ContentSerial"
    CONTENT_FILE_SYSTEM_ACCESS = "ContentFileSystemAccess"
    CONTENT_MEDIA_DEVICES_DISPATCHER_HOST = "ContentMediaDevicesDispatcherHost"
    CONTENT_WEB_BLUETOOTH = "ContentWebBluetooth"
    CONTENT_WEB_USB = "ContentWebUSB"
    CONTENT_MEDIA_SESSION_SERVICE = "ContentMediaSessionService"
    CONTENT_SCREEN_READER = "ContentScreenReader"
    CONTENT_DISCARDED = "ContentDiscarded"
    EMBEDDER_POPUP_BLOCKER_TAB_HELPER = "EmbedderPopupBlockerTabHelper"
    EMBEDDER_SAFE_BROWSING_TRIGGERED_POPUP_BLOCKER = "EmbedderSafeBrowsingTriggeredPopupBlocker"
    EMBEDDER_SAFE_BROWSING_THREAT_DETAILS = "EmbedderSafeBrowsingThreatDetails"
    EMBEDDER_APP_BANNER_MANAGER = "EmbedderAppBannerManager"
    EMBEDDER_DOM_DISTILLER_VIEWER_SOURCE = "EmbedderDomDistillerViewerSource"
    EMBEDDER_DOM_DISTILLER_SELF_DELETING_REQUEST_DELEGATE = "EmbedderDomDistillerSelfDeletingRequestDelegate"
    EMBEDDER_OOM_INTERVENTION_TAB_HELPER = "EmbedderOomInterventionTabHelper"
    EMBEDDER_OFFLINE_PAGE = "EmbedderOfflinePage"
    EMBEDDER_CHROME_PASSWORD_MANAGER_CLIENT_BIND_CREDENTIAL_MANAGER = "EmbedderChromePasswordManagerClientBindCredentialManager"
    EMBEDDER_PERMISSION_REQUEST_MANAGER = "EmbedderPermissionRequestManager"
    EMBEDDER_MODAL_DIALOG = "EmbedderModalDialog"
    EMBEDDER_EXTENSIONS = "EmbedderExtensions"
    EMBEDDER_EXTENSION_MESSAGING = "EmbedderExtensionMessaging"
    EMBEDDER_EXTENSION_MESSAGING_FOR_OPEN_PORT = "EmbedderExtensionMessagingForOpenPort"
    EMBEDDER_EXTENSION_SENT_MESSAGE_TO_CACHED_FRAME = "EmbedderExtensionSentMessageToCachedFrame"
    REQUESTED_BY_WEB_VIEW_CLIENT = "RequestedByWebViewClient"
    POST_MESSAGE_BY_WEB_VIEW_CLIENT = "PostMessageByWebViewClient"
    CACHE_CONTROL_NO_STORE_DEVICE_BOUND_SESSION_TERMINATED = "CacheControlNoStoreDeviceBoundSessionTerminated"
    CACHE_LIMIT_PRUNED = "CacheLimitPruned"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> BackForwardCacheNotRestoredReason:
        return cls(json)


class BackForwardCacheNotRestoredReasonType(enum.Enum):
    """
    Types of not restored reasons for back-forward cache.
    """
    SUPPORT_PENDING = "SupportPending"
    PAGE_SUPPORT_NEEDED = "PageSupportNeeded"
    CIRCUMSTANTIAL = "Circumstantial"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> BackForwardCacheNotRestoredReasonType:
        return cls(json)


@dataclass
class BackForwardCacheBlockingDetails:
    #: Line number in the script (0-based).
    line_number: int

    #: Column number in the script (0-based).
    column_number: int

    #: Url of the file where blockage happened. Optional because of tests.
    url: str | None = None

    #: Function name where blockage happened. Optional because of anonymous functions and tests.
    function: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["lineNumber"] = self.line_number
        json["columnNumber"] = self.column_number
        if self.url is not None:
            json["url"] = self.url
        if self.function is not None:
            json["function"] = self.function
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BackForwardCacheBlockingDetails:
        return cls(
            line_number=int(json["lineNumber"]),
            column_number=int(json["columnNumber"]),
            url=str(json["url"]) if "url" in json else None,
            function=str(json["function"]) if "function" in json else None,
        )


@dataclass
class BackForwardCacheNotRestoredExplanation:
    #: Type of the reason
    type_: BackForwardCacheNotRestoredReasonType

    #: Not restored reason
    reason: BackForwardCacheNotRestoredReason

    #: Context associated with the reason. The meaning of this context is
    #: dependent on the reason:
    #: - EmbedderExtensionSentMessageToCachedFrame: the extension ID.
    context: str | None = None

    details: list[BackForwardCacheBlockingDetails] | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["type"] = self.type_.to_json()
        json["reason"] = self.reason.to_json()
        if self.context is not None:
            json["context"] = self.context
        if self.details is not None:
            json["details"] = [i.to_json() for i in self.details]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BackForwardCacheNotRestoredExplanation:
        return cls(
            type_=BackForwardCacheNotRestoredReasonType.from_json(json["type"]),
            reason=BackForwardCacheNotRestoredReason.from_json(json["reason"]),
            context=str(json["context"]) if "context" in json else None,
            details=[BackForwardCacheBlockingDetails.from_json(i) for i in json["details"]] if "details" in json else None,
        )


@dataclass
class BackForwardCacheNotRestoredExplanationTree:
    #: URL of each frame
    url: str

    #: Not restored reasons of each frame
    explanations: list[BackForwardCacheNotRestoredExplanation]

    #: Array of children frame
    children: list[BackForwardCacheNotRestoredExplanationTree]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["url"] = self.url
        json["explanations"] = [i.to_json() for i in self.explanations]
        json["children"] = [i.to_json() for i in self.children]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BackForwardCacheNotRestoredExplanationTree:
        return cls(
            url=str(json["url"]),
            explanations=[BackForwardCacheNotRestoredExplanation.from_json(i) for i in json["explanations"]],
            children=[BackForwardCacheNotRestoredExplanationTree.from_json(i) for i in json["children"]],
        )


def x_add_script_to_evaluate_on_load__mutmut_orig(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_1(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = None
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_2(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_3(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["XXscriptSourceXX"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_4(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptsource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_5(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["SCRIPTSOURCE"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_6(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["Scriptsource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_7(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_8(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_9(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_10(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_11(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.addScriptToEvaluateOnLoadXX",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_12(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "page.addscripttoevaluateonload",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_13(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.ADDSCRIPTTOEVALUATEONLOAD",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_14(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addscripttoevaluateonload",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_15(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_16(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_17(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "Params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_18(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = None
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_load__mutmut_19(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(None)


def x_add_script_to_evaluate_on_load__mutmut_20(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["XXidentifierXX"])


def x_add_script_to_evaluate_on_load__mutmut_21(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["IDENTIFIER"])


def x_add_script_to_evaluate_on_load__mutmut_22(
    script_source: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Deprecated, please use addScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param script_source:
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["scriptSource"] = script_source
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnLoad",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["Identifier"])

x_add_script_to_evaluate_on_load__mutmut_mutants : ClassVar[MutantDict] = {
'x_add_script_to_evaluate_on_load__mutmut_1': x_add_script_to_evaluate_on_load__mutmut_1, 
    'x_add_script_to_evaluate_on_load__mutmut_2': x_add_script_to_evaluate_on_load__mutmut_2, 
    'x_add_script_to_evaluate_on_load__mutmut_3': x_add_script_to_evaluate_on_load__mutmut_3, 
    'x_add_script_to_evaluate_on_load__mutmut_4': x_add_script_to_evaluate_on_load__mutmut_4, 
    'x_add_script_to_evaluate_on_load__mutmut_5': x_add_script_to_evaluate_on_load__mutmut_5, 
    'x_add_script_to_evaluate_on_load__mutmut_6': x_add_script_to_evaluate_on_load__mutmut_6, 
    'x_add_script_to_evaluate_on_load__mutmut_7': x_add_script_to_evaluate_on_load__mutmut_7, 
    'x_add_script_to_evaluate_on_load__mutmut_8': x_add_script_to_evaluate_on_load__mutmut_8, 
    'x_add_script_to_evaluate_on_load__mutmut_9': x_add_script_to_evaluate_on_load__mutmut_9, 
    'x_add_script_to_evaluate_on_load__mutmut_10': x_add_script_to_evaluate_on_load__mutmut_10, 
    'x_add_script_to_evaluate_on_load__mutmut_11': x_add_script_to_evaluate_on_load__mutmut_11, 
    'x_add_script_to_evaluate_on_load__mutmut_12': x_add_script_to_evaluate_on_load__mutmut_12, 
    'x_add_script_to_evaluate_on_load__mutmut_13': x_add_script_to_evaluate_on_load__mutmut_13, 
    'x_add_script_to_evaluate_on_load__mutmut_14': x_add_script_to_evaluate_on_load__mutmut_14, 
    'x_add_script_to_evaluate_on_load__mutmut_15': x_add_script_to_evaluate_on_load__mutmut_15, 
    'x_add_script_to_evaluate_on_load__mutmut_16': x_add_script_to_evaluate_on_load__mutmut_16, 
    'x_add_script_to_evaluate_on_load__mutmut_17': x_add_script_to_evaluate_on_load__mutmut_17, 
    'x_add_script_to_evaluate_on_load__mutmut_18': x_add_script_to_evaluate_on_load__mutmut_18, 
    'x_add_script_to_evaluate_on_load__mutmut_19': x_add_script_to_evaluate_on_load__mutmut_19, 
    'x_add_script_to_evaluate_on_load__mutmut_20': x_add_script_to_evaluate_on_load__mutmut_20, 
    'x_add_script_to_evaluate_on_load__mutmut_21': x_add_script_to_evaluate_on_load__mutmut_21, 
    'x_add_script_to_evaluate_on_load__mutmut_22': x_add_script_to_evaluate_on_load__mutmut_22
}

def add_script_to_evaluate_on_load(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_add_script_to_evaluate_on_load__mutmut_orig, x_add_script_to_evaluate_on_load__mutmut_mutants, args, kwargs)
    return result 

add_script_to_evaluate_on_load.__signature__ = _mutmut_signature(x_add_script_to_evaluate_on_load__mutmut_orig)
x_add_script_to_evaluate_on_load__mutmut_orig.__name__ = 'x_add_script_to_evaluate_on_load'


def x_add_script_to_evaluate_on_new_document__mutmut_orig(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_1(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = None
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_2(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = None
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_3(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["XXsourceXX"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_4(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["SOURCE"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_5(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["Source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_6(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_7(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = None
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_8(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["XXworldNameXX"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_9(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldname"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_10(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["WORLDNAME"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_11(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["Worldname"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_12(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_13(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = None
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_14(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["XXincludeCommandLineAPIXX"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_15(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includecommandlineapi"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_16(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["INCLUDECOMMANDLINEAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_17(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["Includecommandlineapi"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_18(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_19(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_20(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["XXrunImmediatelyXX"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_21(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runimmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_22(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["RUNIMMEDIATELY"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_23(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["Runimmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_24(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_25(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_26(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_27(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_28(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.addScriptToEvaluateOnNewDocumentXX",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_29(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "page.addscripttoevaluateonnewdocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_30(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.ADDSCRIPTTOEVALUATEONNEWDOCUMENT",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_31(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addscripttoevaluateonnewdocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_32(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_33(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_34(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "Params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_35(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = None
    return ScriptIdentifier.from_json(json["identifier"])


def x_add_script_to_evaluate_on_new_document__mutmut_36(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(None)


def x_add_script_to_evaluate_on_new_document__mutmut_37(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["XXidentifierXX"])


def x_add_script_to_evaluate_on_new_document__mutmut_38(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["IDENTIFIER"])


def x_add_script_to_evaluate_on_new_document__mutmut_39(
    source: str,
    world_name: str | None = None,
    include_command_line_api: bool | None = None,
    run_immediately: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ScriptIdentifier]:
    """
    Evaluates given script in every frame upon creation (before loading frame's scripts).

    :param source:
    :param world_name: **(EXPERIMENTAL)** *(Optional)* If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
    :param include_command_line_api: **(EXPERIMENTAL)** *(Optional)* Specifies whether command line API should be available to the script, defaults to false.
    :param run_immediately: **(EXPERIMENTAL)** *(Optional)* If true, runs the script immediately on existing execution contexts or worlds. Default: false.
    :returns: Identifier of the added script.
    """
    params: T_JSON_DICT = {}
    params["source"] = source
    if world_name is not None:
        params["worldName"] = world_name
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if run_immediately is not None:
        params["runImmediately"] = run_immediately
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addScriptToEvaluateOnNewDocument",
        "params": params,
    }
    json = yield cmd_dict
    return ScriptIdentifier.from_json(json["Identifier"])

x_add_script_to_evaluate_on_new_document__mutmut_mutants : ClassVar[MutantDict] = {
'x_add_script_to_evaluate_on_new_document__mutmut_1': x_add_script_to_evaluate_on_new_document__mutmut_1, 
    'x_add_script_to_evaluate_on_new_document__mutmut_2': x_add_script_to_evaluate_on_new_document__mutmut_2, 
    'x_add_script_to_evaluate_on_new_document__mutmut_3': x_add_script_to_evaluate_on_new_document__mutmut_3, 
    'x_add_script_to_evaluate_on_new_document__mutmut_4': x_add_script_to_evaluate_on_new_document__mutmut_4, 
    'x_add_script_to_evaluate_on_new_document__mutmut_5': x_add_script_to_evaluate_on_new_document__mutmut_5, 
    'x_add_script_to_evaluate_on_new_document__mutmut_6': x_add_script_to_evaluate_on_new_document__mutmut_6, 
    'x_add_script_to_evaluate_on_new_document__mutmut_7': x_add_script_to_evaluate_on_new_document__mutmut_7, 
    'x_add_script_to_evaluate_on_new_document__mutmut_8': x_add_script_to_evaluate_on_new_document__mutmut_8, 
    'x_add_script_to_evaluate_on_new_document__mutmut_9': x_add_script_to_evaluate_on_new_document__mutmut_9, 
    'x_add_script_to_evaluate_on_new_document__mutmut_10': x_add_script_to_evaluate_on_new_document__mutmut_10, 
    'x_add_script_to_evaluate_on_new_document__mutmut_11': x_add_script_to_evaluate_on_new_document__mutmut_11, 
    'x_add_script_to_evaluate_on_new_document__mutmut_12': x_add_script_to_evaluate_on_new_document__mutmut_12, 
    'x_add_script_to_evaluate_on_new_document__mutmut_13': x_add_script_to_evaluate_on_new_document__mutmut_13, 
    'x_add_script_to_evaluate_on_new_document__mutmut_14': x_add_script_to_evaluate_on_new_document__mutmut_14, 
    'x_add_script_to_evaluate_on_new_document__mutmut_15': x_add_script_to_evaluate_on_new_document__mutmut_15, 
    'x_add_script_to_evaluate_on_new_document__mutmut_16': x_add_script_to_evaluate_on_new_document__mutmut_16, 
    'x_add_script_to_evaluate_on_new_document__mutmut_17': x_add_script_to_evaluate_on_new_document__mutmut_17, 
    'x_add_script_to_evaluate_on_new_document__mutmut_18': x_add_script_to_evaluate_on_new_document__mutmut_18, 
    'x_add_script_to_evaluate_on_new_document__mutmut_19': x_add_script_to_evaluate_on_new_document__mutmut_19, 
    'x_add_script_to_evaluate_on_new_document__mutmut_20': x_add_script_to_evaluate_on_new_document__mutmut_20, 
    'x_add_script_to_evaluate_on_new_document__mutmut_21': x_add_script_to_evaluate_on_new_document__mutmut_21, 
    'x_add_script_to_evaluate_on_new_document__mutmut_22': x_add_script_to_evaluate_on_new_document__mutmut_22, 
    'x_add_script_to_evaluate_on_new_document__mutmut_23': x_add_script_to_evaluate_on_new_document__mutmut_23, 
    'x_add_script_to_evaluate_on_new_document__mutmut_24': x_add_script_to_evaluate_on_new_document__mutmut_24, 
    'x_add_script_to_evaluate_on_new_document__mutmut_25': x_add_script_to_evaluate_on_new_document__mutmut_25, 
    'x_add_script_to_evaluate_on_new_document__mutmut_26': x_add_script_to_evaluate_on_new_document__mutmut_26, 
    'x_add_script_to_evaluate_on_new_document__mutmut_27': x_add_script_to_evaluate_on_new_document__mutmut_27, 
    'x_add_script_to_evaluate_on_new_document__mutmut_28': x_add_script_to_evaluate_on_new_document__mutmut_28, 
    'x_add_script_to_evaluate_on_new_document__mutmut_29': x_add_script_to_evaluate_on_new_document__mutmut_29, 
    'x_add_script_to_evaluate_on_new_document__mutmut_30': x_add_script_to_evaluate_on_new_document__mutmut_30, 
    'x_add_script_to_evaluate_on_new_document__mutmut_31': x_add_script_to_evaluate_on_new_document__mutmut_31, 
    'x_add_script_to_evaluate_on_new_document__mutmut_32': x_add_script_to_evaluate_on_new_document__mutmut_32, 
    'x_add_script_to_evaluate_on_new_document__mutmut_33': x_add_script_to_evaluate_on_new_document__mutmut_33, 
    'x_add_script_to_evaluate_on_new_document__mutmut_34': x_add_script_to_evaluate_on_new_document__mutmut_34, 
    'x_add_script_to_evaluate_on_new_document__mutmut_35': x_add_script_to_evaluate_on_new_document__mutmut_35, 
    'x_add_script_to_evaluate_on_new_document__mutmut_36': x_add_script_to_evaluate_on_new_document__mutmut_36, 
    'x_add_script_to_evaluate_on_new_document__mutmut_37': x_add_script_to_evaluate_on_new_document__mutmut_37, 
    'x_add_script_to_evaluate_on_new_document__mutmut_38': x_add_script_to_evaluate_on_new_document__mutmut_38, 
    'x_add_script_to_evaluate_on_new_document__mutmut_39': x_add_script_to_evaluate_on_new_document__mutmut_39
}

def add_script_to_evaluate_on_new_document(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_add_script_to_evaluate_on_new_document__mutmut_orig, x_add_script_to_evaluate_on_new_document__mutmut_mutants, args, kwargs)
    return result 

add_script_to_evaluate_on_new_document.__signature__ = _mutmut_signature(x_add_script_to_evaluate_on_new_document__mutmut_orig)
x_add_script_to_evaluate_on_new_document__mutmut_orig.__name__ = 'x_add_script_to_evaluate_on_new_document'


def x_bring_to_front__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Brings page to front (activates tab).
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.bringToFront",
    }
    yield cmd_dict


def x_bring_to_front__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Brings page to front (activates tab).
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_bring_to_front__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Brings page to front (activates tab).
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.bringToFront",
    }
    yield cmd_dict


def x_bring_to_front__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Brings page to front (activates tab).
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.bringToFront",
    }
    yield cmd_dict


def x_bring_to_front__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Brings page to front (activates tab).
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.bringToFront",
    }
    yield cmd_dict


def x_bring_to_front__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Brings page to front (activates tab).
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.bringToFrontXX",
    }
    yield cmd_dict


def x_bring_to_front__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Brings page to front (activates tab).
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.bringtofront",
    }
    yield cmd_dict


def x_bring_to_front__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Brings page to front (activates tab).
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.BRINGTOFRONT",
    }
    yield cmd_dict


def x_bring_to_front__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Brings page to front (activates tab).
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.bringtofront",
    }
    yield cmd_dict

x_bring_to_front__mutmut_mutants : ClassVar[MutantDict] = {
'x_bring_to_front__mutmut_1': x_bring_to_front__mutmut_1, 
    'x_bring_to_front__mutmut_2': x_bring_to_front__mutmut_2, 
    'x_bring_to_front__mutmut_3': x_bring_to_front__mutmut_3, 
    'x_bring_to_front__mutmut_4': x_bring_to_front__mutmut_4, 
    'x_bring_to_front__mutmut_5': x_bring_to_front__mutmut_5, 
    'x_bring_to_front__mutmut_6': x_bring_to_front__mutmut_6, 
    'x_bring_to_front__mutmut_7': x_bring_to_front__mutmut_7, 
    'x_bring_to_front__mutmut_8': x_bring_to_front__mutmut_8
}

def bring_to_front(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_bring_to_front__mutmut_orig, x_bring_to_front__mutmut_mutants, args, kwargs)
    return result 

bring_to_front.__signature__ = _mutmut_signature(x_bring_to_front__mutmut_orig)
x_bring_to_front__mutmut_orig.__name__ = 'x_bring_to_front'


def x_capture_screenshot__mutmut_orig(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_1(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = None
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_2(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_3(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = None
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_4(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["XXformatXX"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_5(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["FORMAT"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_6(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["Format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_7(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_8(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = None
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_9(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["XXqualityXX"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_10(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["QUALITY"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_11(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["Quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_12(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_13(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = None
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_14(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["XXclipXX"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_15(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["CLIP"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_16(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["Clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_17(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_18(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = None
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_19(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["XXfromSurfaceXX"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_20(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromsurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_21(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["FROMSURFACE"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_22(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["Fromsurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_23(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_24(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = None
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_25(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["XXcaptureBeyondViewportXX"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_26(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["capturebeyondviewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_27(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["CAPTUREBEYONDVIEWPORT"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_28(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["Capturebeyondviewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_29(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_30(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_31(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["XXoptimizeForSpeedXX"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_32(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeforspeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_33(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["OPTIMIZEFORSPEED"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_34(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["Optimizeforspeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_35(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_36(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_37(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_38(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_39(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.captureScreenshotXX",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_40(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "page.capturescreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_41(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.CAPTURESCREENSHOT",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_42(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.capturescreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_43(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_44(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_45(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "Params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_screenshot__mutmut_46(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = None
    return str(json["data"])


def x_capture_screenshot__mutmut_47(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(None)


def x_capture_screenshot__mutmut_48(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["XXdataXX"])


def x_capture_screenshot__mutmut_49(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["DATA"])


def x_capture_screenshot__mutmut_50(
    format_: str | None = None,
    quality: int | None = None,
    clip: Viewport | None = None,
    from_surface: bool | None = None,
    capture_beyond_viewport: bool | None = None,
    optimize_for_speed: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Capture page screenshot.

    :param format_: *(Optional)* Image compression format (defaults to png).
    :param quality: *(Optional)* Compression quality from range [0..100] (jpeg only).
    :param clip: *(Optional)* Capture the screenshot of a given region only.
    :param from_surface: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot from the surface, rather than the view. Defaults to true.
    :param capture_beyond_viewport: **(EXPERIMENTAL)** *(Optional)* Capture the screenshot beyond the viewport. Defaults to false.
    :param optimize_for_speed: **(EXPERIMENTAL)** *(Optional)* Optimize image encoding for speed, not for resulting size (defaults to false)
    :returns: Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if clip is not None:
        params["clip"] = clip.to_json()
    if from_surface is not None:
        params["fromSurface"] = from_surface
    if capture_beyond_viewport is not None:
        params["captureBeyondViewport"] = capture_beyond_viewport
    if optimize_for_speed is not None:
        params["optimizeForSpeed"] = optimize_for_speed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureScreenshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["Data"])

x_capture_screenshot__mutmut_mutants : ClassVar[MutantDict] = {
'x_capture_screenshot__mutmut_1': x_capture_screenshot__mutmut_1, 
    'x_capture_screenshot__mutmut_2': x_capture_screenshot__mutmut_2, 
    'x_capture_screenshot__mutmut_3': x_capture_screenshot__mutmut_3, 
    'x_capture_screenshot__mutmut_4': x_capture_screenshot__mutmut_4, 
    'x_capture_screenshot__mutmut_5': x_capture_screenshot__mutmut_5, 
    'x_capture_screenshot__mutmut_6': x_capture_screenshot__mutmut_6, 
    'x_capture_screenshot__mutmut_7': x_capture_screenshot__mutmut_7, 
    'x_capture_screenshot__mutmut_8': x_capture_screenshot__mutmut_8, 
    'x_capture_screenshot__mutmut_9': x_capture_screenshot__mutmut_9, 
    'x_capture_screenshot__mutmut_10': x_capture_screenshot__mutmut_10, 
    'x_capture_screenshot__mutmut_11': x_capture_screenshot__mutmut_11, 
    'x_capture_screenshot__mutmut_12': x_capture_screenshot__mutmut_12, 
    'x_capture_screenshot__mutmut_13': x_capture_screenshot__mutmut_13, 
    'x_capture_screenshot__mutmut_14': x_capture_screenshot__mutmut_14, 
    'x_capture_screenshot__mutmut_15': x_capture_screenshot__mutmut_15, 
    'x_capture_screenshot__mutmut_16': x_capture_screenshot__mutmut_16, 
    'x_capture_screenshot__mutmut_17': x_capture_screenshot__mutmut_17, 
    'x_capture_screenshot__mutmut_18': x_capture_screenshot__mutmut_18, 
    'x_capture_screenshot__mutmut_19': x_capture_screenshot__mutmut_19, 
    'x_capture_screenshot__mutmut_20': x_capture_screenshot__mutmut_20, 
    'x_capture_screenshot__mutmut_21': x_capture_screenshot__mutmut_21, 
    'x_capture_screenshot__mutmut_22': x_capture_screenshot__mutmut_22, 
    'x_capture_screenshot__mutmut_23': x_capture_screenshot__mutmut_23, 
    'x_capture_screenshot__mutmut_24': x_capture_screenshot__mutmut_24, 
    'x_capture_screenshot__mutmut_25': x_capture_screenshot__mutmut_25, 
    'x_capture_screenshot__mutmut_26': x_capture_screenshot__mutmut_26, 
    'x_capture_screenshot__mutmut_27': x_capture_screenshot__mutmut_27, 
    'x_capture_screenshot__mutmut_28': x_capture_screenshot__mutmut_28, 
    'x_capture_screenshot__mutmut_29': x_capture_screenshot__mutmut_29, 
    'x_capture_screenshot__mutmut_30': x_capture_screenshot__mutmut_30, 
    'x_capture_screenshot__mutmut_31': x_capture_screenshot__mutmut_31, 
    'x_capture_screenshot__mutmut_32': x_capture_screenshot__mutmut_32, 
    'x_capture_screenshot__mutmut_33': x_capture_screenshot__mutmut_33, 
    'x_capture_screenshot__mutmut_34': x_capture_screenshot__mutmut_34, 
    'x_capture_screenshot__mutmut_35': x_capture_screenshot__mutmut_35, 
    'x_capture_screenshot__mutmut_36': x_capture_screenshot__mutmut_36, 
    'x_capture_screenshot__mutmut_37': x_capture_screenshot__mutmut_37, 
    'x_capture_screenshot__mutmut_38': x_capture_screenshot__mutmut_38, 
    'x_capture_screenshot__mutmut_39': x_capture_screenshot__mutmut_39, 
    'x_capture_screenshot__mutmut_40': x_capture_screenshot__mutmut_40, 
    'x_capture_screenshot__mutmut_41': x_capture_screenshot__mutmut_41, 
    'x_capture_screenshot__mutmut_42': x_capture_screenshot__mutmut_42, 
    'x_capture_screenshot__mutmut_43': x_capture_screenshot__mutmut_43, 
    'x_capture_screenshot__mutmut_44': x_capture_screenshot__mutmut_44, 
    'x_capture_screenshot__mutmut_45': x_capture_screenshot__mutmut_45, 
    'x_capture_screenshot__mutmut_46': x_capture_screenshot__mutmut_46, 
    'x_capture_screenshot__mutmut_47': x_capture_screenshot__mutmut_47, 
    'x_capture_screenshot__mutmut_48': x_capture_screenshot__mutmut_48, 
    'x_capture_screenshot__mutmut_49': x_capture_screenshot__mutmut_49, 
    'x_capture_screenshot__mutmut_50': x_capture_screenshot__mutmut_50
}

def capture_screenshot(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_capture_screenshot__mutmut_orig, x_capture_screenshot__mutmut_mutants, args, kwargs)
    return result 

capture_screenshot.__signature__ = _mutmut_signature(x_capture_screenshot__mutmut_orig)
x_capture_screenshot__mutmut_orig.__name__ = 'x_capture_screenshot'


def x_capture_snapshot__mutmut_orig(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_1(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = None
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_2(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_3(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_4(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["XXformatXX"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_5(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["FORMAT"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_6(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["Format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_7(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_8(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_9(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_10(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_11(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.captureSnapshotXX",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_12(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "page.capturesnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_13(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.CAPTURESNAPSHOT",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_14(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.capturesnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_15(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_16(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_17(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "Params": params,
    }
    json = yield cmd_dict
    return str(json["data"])


def x_capture_snapshot__mutmut_18(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = None
    return str(json["data"])


def x_capture_snapshot__mutmut_19(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(None)


def x_capture_snapshot__mutmut_20(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["XXdataXX"])


def x_capture_snapshot__mutmut_21(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["DATA"])


def x_capture_snapshot__mutmut_22(
    format_: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns a snapshot of the page as a string. For MHTML format, the serialization includes
    iframes, shadow DOM, external resources, and element-inline styles.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Format (defaults to mhtml).
    :returns: Serialized page data.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    cmd_dict: T_JSON_DICT = {
        "method": "Page.captureSnapshot",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["Data"])

x_capture_snapshot__mutmut_mutants : ClassVar[MutantDict] = {
'x_capture_snapshot__mutmut_1': x_capture_snapshot__mutmut_1, 
    'x_capture_snapshot__mutmut_2': x_capture_snapshot__mutmut_2, 
    'x_capture_snapshot__mutmut_3': x_capture_snapshot__mutmut_3, 
    'x_capture_snapshot__mutmut_4': x_capture_snapshot__mutmut_4, 
    'x_capture_snapshot__mutmut_5': x_capture_snapshot__mutmut_5, 
    'x_capture_snapshot__mutmut_6': x_capture_snapshot__mutmut_6, 
    'x_capture_snapshot__mutmut_7': x_capture_snapshot__mutmut_7, 
    'x_capture_snapshot__mutmut_8': x_capture_snapshot__mutmut_8, 
    'x_capture_snapshot__mutmut_9': x_capture_snapshot__mutmut_9, 
    'x_capture_snapshot__mutmut_10': x_capture_snapshot__mutmut_10, 
    'x_capture_snapshot__mutmut_11': x_capture_snapshot__mutmut_11, 
    'x_capture_snapshot__mutmut_12': x_capture_snapshot__mutmut_12, 
    'x_capture_snapshot__mutmut_13': x_capture_snapshot__mutmut_13, 
    'x_capture_snapshot__mutmut_14': x_capture_snapshot__mutmut_14, 
    'x_capture_snapshot__mutmut_15': x_capture_snapshot__mutmut_15, 
    'x_capture_snapshot__mutmut_16': x_capture_snapshot__mutmut_16, 
    'x_capture_snapshot__mutmut_17': x_capture_snapshot__mutmut_17, 
    'x_capture_snapshot__mutmut_18': x_capture_snapshot__mutmut_18, 
    'x_capture_snapshot__mutmut_19': x_capture_snapshot__mutmut_19, 
    'x_capture_snapshot__mutmut_20': x_capture_snapshot__mutmut_20, 
    'x_capture_snapshot__mutmut_21': x_capture_snapshot__mutmut_21, 
    'x_capture_snapshot__mutmut_22': x_capture_snapshot__mutmut_22
}

def capture_snapshot(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_capture_snapshot__mutmut_orig, x_capture_snapshot__mutmut_mutants, args, kwargs)
    return result 

capture_snapshot.__signature__ = _mutmut_signature(x_capture_snapshot__mutmut_orig)
x_capture_snapshot__mutmut_orig.__name__ = 'x_capture_snapshot'


def x_clear_device_metrics_override__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden device metrics.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.clearDeviceMetricsOverride",
    }
    yield cmd_dict


def x_clear_device_metrics_override__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden device metrics.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_clear_device_metrics_override__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden device metrics.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.clearDeviceMetricsOverride",
    }
    yield cmd_dict


def x_clear_device_metrics_override__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden device metrics.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.clearDeviceMetricsOverride",
    }
    yield cmd_dict


def x_clear_device_metrics_override__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden device metrics.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.clearDeviceMetricsOverride",
    }
    yield cmd_dict


def x_clear_device_metrics_override__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden device metrics.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.clearDeviceMetricsOverrideXX",
    }
    yield cmd_dict


def x_clear_device_metrics_override__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden device metrics.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.cleardevicemetricsoverride",
    }
    yield cmd_dict


def x_clear_device_metrics_override__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden device metrics.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.CLEARDEVICEMETRICSOVERRIDE",
    }
    yield cmd_dict


def x_clear_device_metrics_override__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden device metrics.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.cleardevicemetricsoverride",
    }
    yield cmd_dict

x_clear_device_metrics_override__mutmut_mutants : ClassVar[MutantDict] = {
'x_clear_device_metrics_override__mutmut_1': x_clear_device_metrics_override__mutmut_1, 
    'x_clear_device_metrics_override__mutmut_2': x_clear_device_metrics_override__mutmut_2, 
    'x_clear_device_metrics_override__mutmut_3': x_clear_device_metrics_override__mutmut_3, 
    'x_clear_device_metrics_override__mutmut_4': x_clear_device_metrics_override__mutmut_4, 
    'x_clear_device_metrics_override__mutmut_5': x_clear_device_metrics_override__mutmut_5, 
    'x_clear_device_metrics_override__mutmut_6': x_clear_device_metrics_override__mutmut_6, 
    'x_clear_device_metrics_override__mutmut_7': x_clear_device_metrics_override__mutmut_7, 
    'x_clear_device_metrics_override__mutmut_8': x_clear_device_metrics_override__mutmut_8
}

def clear_device_metrics_override(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_clear_device_metrics_override__mutmut_orig, x_clear_device_metrics_override__mutmut_mutants, args, kwargs)
    return result 

clear_device_metrics_override.__signature__ = _mutmut_signature(x_clear_device_metrics_override__mutmut_orig)
x_clear_device_metrics_override__mutmut_orig.__name__ = 'x_clear_device_metrics_override'


def x_clear_device_orientation_override__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Device Orientation.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.clearDeviceOrientationOverride",
    }
    yield cmd_dict


def x_clear_device_orientation_override__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Device Orientation.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_clear_device_orientation_override__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Device Orientation.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.clearDeviceOrientationOverride",
    }
    yield cmd_dict


def x_clear_device_orientation_override__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Device Orientation.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.clearDeviceOrientationOverride",
    }
    yield cmd_dict


def x_clear_device_orientation_override__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Device Orientation.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.clearDeviceOrientationOverride",
    }
    yield cmd_dict


def x_clear_device_orientation_override__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Device Orientation.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.clearDeviceOrientationOverrideXX",
    }
    yield cmd_dict


def x_clear_device_orientation_override__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Device Orientation.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.cleardeviceorientationoverride",
    }
    yield cmd_dict


def x_clear_device_orientation_override__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Device Orientation.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.CLEARDEVICEORIENTATIONOVERRIDE",
    }
    yield cmd_dict


def x_clear_device_orientation_override__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Device Orientation.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.cleardeviceorientationoverride",
    }
    yield cmd_dict

x_clear_device_orientation_override__mutmut_mutants : ClassVar[MutantDict] = {
'x_clear_device_orientation_override__mutmut_1': x_clear_device_orientation_override__mutmut_1, 
    'x_clear_device_orientation_override__mutmut_2': x_clear_device_orientation_override__mutmut_2, 
    'x_clear_device_orientation_override__mutmut_3': x_clear_device_orientation_override__mutmut_3, 
    'x_clear_device_orientation_override__mutmut_4': x_clear_device_orientation_override__mutmut_4, 
    'x_clear_device_orientation_override__mutmut_5': x_clear_device_orientation_override__mutmut_5, 
    'x_clear_device_orientation_override__mutmut_6': x_clear_device_orientation_override__mutmut_6, 
    'x_clear_device_orientation_override__mutmut_7': x_clear_device_orientation_override__mutmut_7, 
    'x_clear_device_orientation_override__mutmut_8': x_clear_device_orientation_override__mutmut_8
}

def clear_device_orientation_override(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_clear_device_orientation_override__mutmut_orig, x_clear_device_orientation_override__mutmut_mutants, args, kwargs)
    return result 

clear_device_orientation_override.__signature__ = _mutmut_signature(x_clear_device_orientation_override__mutmut_orig)
x_clear_device_orientation_override__mutmut_orig.__name__ = 'x_clear_device_orientation_override'


def x_clear_geolocation_override__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Geolocation Position and Error.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.clearGeolocationOverride",
    }
    yield cmd_dict


def x_clear_geolocation_override__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Geolocation Position and Error.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_clear_geolocation_override__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Geolocation Position and Error.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.clearGeolocationOverride",
    }
    yield cmd_dict


def x_clear_geolocation_override__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Geolocation Position and Error.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.clearGeolocationOverride",
    }
    yield cmd_dict


def x_clear_geolocation_override__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Geolocation Position and Error.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.clearGeolocationOverride",
    }
    yield cmd_dict


def x_clear_geolocation_override__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Geolocation Position and Error.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.clearGeolocationOverrideXX",
    }
    yield cmd_dict


def x_clear_geolocation_override__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Geolocation Position and Error.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.cleargeolocationoverride",
    }
    yield cmd_dict


def x_clear_geolocation_override__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Geolocation Position and Error.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.CLEARGEOLOCATIONOVERRIDE",
    }
    yield cmd_dict


def x_clear_geolocation_override__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears the overridden Geolocation Position and Error.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.cleargeolocationoverride",
    }
    yield cmd_dict

x_clear_geolocation_override__mutmut_mutants : ClassVar[MutantDict] = {
'x_clear_geolocation_override__mutmut_1': x_clear_geolocation_override__mutmut_1, 
    'x_clear_geolocation_override__mutmut_2': x_clear_geolocation_override__mutmut_2, 
    'x_clear_geolocation_override__mutmut_3': x_clear_geolocation_override__mutmut_3, 
    'x_clear_geolocation_override__mutmut_4': x_clear_geolocation_override__mutmut_4, 
    'x_clear_geolocation_override__mutmut_5': x_clear_geolocation_override__mutmut_5, 
    'x_clear_geolocation_override__mutmut_6': x_clear_geolocation_override__mutmut_6, 
    'x_clear_geolocation_override__mutmut_7': x_clear_geolocation_override__mutmut_7, 
    'x_clear_geolocation_override__mutmut_8': x_clear_geolocation_override__mutmut_8
}

def clear_geolocation_override(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_clear_geolocation_override__mutmut_orig, x_clear_geolocation_override__mutmut_mutants, args, kwargs)
    return result 

clear_geolocation_override.__signature__ = _mutmut_signature(x_clear_geolocation_override__mutmut_orig)
x_clear_geolocation_override__mutmut_orig.__name__ = 'x_clear_geolocation_override'


def x_create_isolated_world__mutmut_orig(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_1(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = None
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_2(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = None
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_3(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["XXframeIdXX"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_4(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameid"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_5(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["FRAMEID"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_6(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["Frameid"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_7(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_8(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = None
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_9(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["XXworldNameXX"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_10(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldname"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_11(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["WORLDNAME"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_12(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["Worldname"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_13(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_14(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_15(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["XXgrantUniveralAccessXX"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_16(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantuniveralaccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_17(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["GRANTUNIVERALACCESS"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_18(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["Grantuniveralaccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_19(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_20(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_21(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_22(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_23(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.createIsolatedWorldXX",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_24(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "page.createisolatedworld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_25(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.CREATEISOLATEDWORLD",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_26(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createisolatedworld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_27(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_28(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_29(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "Params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_30(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = None
    return runtime.ExecutionContextId.from_json(json["executionContextId"])


def x_create_isolated_world__mutmut_31(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(None)


def x_create_isolated_world__mutmut_32(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["XXexecutionContextIdXX"])


def x_create_isolated_world__mutmut_33(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["executioncontextid"])


def x_create_isolated_world__mutmut_34(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["EXECUTIONCONTEXTID"])


def x_create_isolated_world__mutmut_35(
    frame_id: FrameId,
    world_name: str | None = None,
    grant_univeral_access: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.ExecutionContextId]:
    """
    Creates an isolated world for the given frame.

    :param frame_id: Id of the frame in which the isolated world should be created.
    :param world_name: *(Optional)* An optional name which is reported in the Execution Context.
    :param grant_univeral_access: *(Optional)* Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
    :returns: Execution context of the isolated world.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    if world_name is not None:
        params["worldName"] = world_name
    if grant_univeral_access is not None:
        params["grantUniveralAccess"] = grant_univeral_access
    cmd_dict: T_JSON_DICT = {
        "method": "Page.createIsolatedWorld",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.ExecutionContextId.from_json(json["Executioncontextid"])

x_create_isolated_world__mutmut_mutants : ClassVar[MutantDict] = {
'x_create_isolated_world__mutmut_1': x_create_isolated_world__mutmut_1, 
    'x_create_isolated_world__mutmut_2': x_create_isolated_world__mutmut_2, 
    'x_create_isolated_world__mutmut_3': x_create_isolated_world__mutmut_3, 
    'x_create_isolated_world__mutmut_4': x_create_isolated_world__mutmut_4, 
    'x_create_isolated_world__mutmut_5': x_create_isolated_world__mutmut_5, 
    'x_create_isolated_world__mutmut_6': x_create_isolated_world__mutmut_6, 
    'x_create_isolated_world__mutmut_7': x_create_isolated_world__mutmut_7, 
    'x_create_isolated_world__mutmut_8': x_create_isolated_world__mutmut_8, 
    'x_create_isolated_world__mutmut_9': x_create_isolated_world__mutmut_9, 
    'x_create_isolated_world__mutmut_10': x_create_isolated_world__mutmut_10, 
    'x_create_isolated_world__mutmut_11': x_create_isolated_world__mutmut_11, 
    'x_create_isolated_world__mutmut_12': x_create_isolated_world__mutmut_12, 
    'x_create_isolated_world__mutmut_13': x_create_isolated_world__mutmut_13, 
    'x_create_isolated_world__mutmut_14': x_create_isolated_world__mutmut_14, 
    'x_create_isolated_world__mutmut_15': x_create_isolated_world__mutmut_15, 
    'x_create_isolated_world__mutmut_16': x_create_isolated_world__mutmut_16, 
    'x_create_isolated_world__mutmut_17': x_create_isolated_world__mutmut_17, 
    'x_create_isolated_world__mutmut_18': x_create_isolated_world__mutmut_18, 
    'x_create_isolated_world__mutmut_19': x_create_isolated_world__mutmut_19, 
    'x_create_isolated_world__mutmut_20': x_create_isolated_world__mutmut_20, 
    'x_create_isolated_world__mutmut_21': x_create_isolated_world__mutmut_21, 
    'x_create_isolated_world__mutmut_22': x_create_isolated_world__mutmut_22, 
    'x_create_isolated_world__mutmut_23': x_create_isolated_world__mutmut_23, 
    'x_create_isolated_world__mutmut_24': x_create_isolated_world__mutmut_24, 
    'x_create_isolated_world__mutmut_25': x_create_isolated_world__mutmut_25, 
    'x_create_isolated_world__mutmut_26': x_create_isolated_world__mutmut_26, 
    'x_create_isolated_world__mutmut_27': x_create_isolated_world__mutmut_27, 
    'x_create_isolated_world__mutmut_28': x_create_isolated_world__mutmut_28, 
    'x_create_isolated_world__mutmut_29': x_create_isolated_world__mutmut_29, 
    'x_create_isolated_world__mutmut_30': x_create_isolated_world__mutmut_30, 
    'x_create_isolated_world__mutmut_31': x_create_isolated_world__mutmut_31, 
    'x_create_isolated_world__mutmut_32': x_create_isolated_world__mutmut_32, 
    'x_create_isolated_world__mutmut_33': x_create_isolated_world__mutmut_33, 
    'x_create_isolated_world__mutmut_34': x_create_isolated_world__mutmut_34, 
    'x_create_isolated_world__mutmut_35': x_create_isolated_world__mutmut_35
}

def create_isolated_world(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_create_isolated_world__mutmut_orig, x_create_isolated_world__mutmut_mutants, args, kwargs)
    return result 

create_isolated_world.__signature__ = _mutmut_signature(x_create_isolated_world__mutmut_orig)
x_create_isolated_world__mutmut_orig.__name__ = 'x_create_isolated_world'


def x_delete_cookie__mutmut_orig(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_1(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = None
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_2(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = None
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_3(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["XXcookieNameXX"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_4(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookiename"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_5(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["COOKIENAME"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_6(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["Cookiename"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_7(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_8(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["XXurlXX"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_9(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["URL"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_10(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["Url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_11(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_delete_cookie__mutmut_12(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_13(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_14(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.deleteCookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_15(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.deleteCookieXX",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_16(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "page.deletecookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_17(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.DELETECOOKIE",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_18(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deletecookie",
        "params": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_19(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_20(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "PARAMS": params,
    }
    yield cmd_dict


def x_delete_cookie__mutmut_21(
    cookie_name: str,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deletes browser cookie with given name, domain and path.

    **EXPERIMENTAL**

    :param cookie_name: Name of the cookie to remove.
    :param url: URL to match cooke domain and path.
    """
    params: T_JSON_DICT = {}
    params["cookieName"] = cookie_name
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.deleteCookie",
        "Params": params,
    }
    yield cmd_dict

x_delete_cookie__mutmut_mutants : ClassVar[MutantDict] = {
'x_delete_cookie__mutmut_1': x_delete_cookie__mutmut_1, 
    'x_delete_cookie__mutmut_2': x_delete_cookie__mutmut_2, 
    'x_delete_cookie__mutmut_3': x_delete_cookie__mutmut_3, 
    'x_delete_cookie__mutmut_4': x_delete_cookie__mutmut_4, 
    'x_delete_cookie__mutmut_5': x_delete_cookie__mutmut_5, 
    'x_delete_cookie__mutmut_6': x_delete_cookie__mutmut_6, 
    'x_delete_cookie__mutmut_7': x_delete_cookie__mutmut_7, 
    'x_delete_cookie__mutmut_8': x_delete_cookie__mutmut_8, 
    'x_delete_cookie__mutmut_9': x_delete_cookie__mutmut_9, 
    'x_delete_cookie__mutmut_10': x_delete_cookie__mutmut_10, 
    'x_delete_cookie__mutmut_11': x_delete_cookie__mutmut_11, 
    'x_delete_cookie__mutmut_12': x_delete_cookie__mutmut_12, 
    'x_delete_cookie__mutmut_13': x_delete_cookie__mutmut_13, 
    'x_delete_cookie__mutmut_14': x_delete_cookie__mutmut_14, 
    'x_delete_cookie__mutmut_15': x_delete_cookie__mutmut_15, 
    'x_delete_cookie__mutmut_16': x_delete_cookie__mutmut_16, 
    'x_delete_cookie__mutmut_17': x_delete_cookie__mutmut_17, 
    'x_delete_cookie__mutmut_18': x_delete_cookie__mutmut_18, 
    'x_delete_cookie__mutmut_19': x_delete_cookie__mutmut_19, 
    'x_delete_cookie__mutmut_20': x_delete_cookie__mutmut_20, 
    'x_delete_cookie__mutmut_21': x_delete_cookie__mutmut_21
}

def delete_cookie(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_delete_cookie__mutmut_orig, x_delete_cookie__mutmut_mutants, args, kwargs)
    return result 

delete_cookie.__signature__ = _mutmut_signature(x_delete_cookie__mutmut_orig)
x_delete_cookie__mutmut_orig.__name__ = 'x_delete_cookie'


def x_disable__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables page domain notifications.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.disable",
    }
    yield cmd_dict


def x_disable__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables page domain notifications.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_disable__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables page domain notifications.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.disable",
    }
    yield cmd_dict


def x_disable__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables page domain notifications.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.disable",
    }
    yield cmd_dict


def x_disable__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables page domain notifications.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.disable",
    }
    yield cmd_dict


def x_disable__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables page domain notifications.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.disableXX",
    }
    yield cmd_dict


def x_disable__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables page domain notifications.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.disable",
    }
    yield cmd_dict


def x_disable__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables page domain notifications.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.DISABLE",
    }
    yield cmd_dict

x_disable__mutmut_mutants : ClassVar[MutantDict] = {
'x_disable__mutmut_1': x_disable__mutmut_1, 
    'x_disable__mutmut_2': x_disable__mutmut_2, 
    'x_disable__mutmut_3': x_disable__mutmut_3, 
    'x_disable__mutmut_4': x_disable__mutmut_4, 
    'x_disable__mutmut_5': x_disable__mutmut_5, 
    'x_disable__mutmut_6': x_disable__mutmut_6, 
    'x_disable__mutmut_7': x_disable__mutmut_7
}

def disable(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_disable__mutmut_orig, x_disable__mutmut_mutants, args, kwargs)
    return result 

disable.__signature__ = _mutmut_signature(x_disable__mutmut_orig)
x_disable__mutmut_orig.__name__ = 'x_disable'


def x_enable__mutmut_orig(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "Page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_1(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = None
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "Page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_2(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "Page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_3(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_4(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["XXenableFileChooserOpenedEventXX"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "Page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_5(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enablefilechooseropenedevent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "Page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_6(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["ENABLEFILECHOOSEROPENEDEVENT"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "Page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_7(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["Enablefilechooseropenedevent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "Page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_8(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_enable__mutmut_9(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_10(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_11(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_12(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.enableXX",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_13(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "page.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_14(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.ENABLE",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_15(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "Page.enable",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_enable__mutmut_16(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "Page.enable",
        "PARAMS": params,
    }
    yield cmd_dict


def x_enable__mutmut_17(
    enable_file_chooser_opened_event: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables page domain notifications.

    :param enable_file_chooser_opened_event: **(EXPERIMENTAL)** *(Optional)* If true, the ```Page.fileChooserOpened```` event will be emitted regardless of the state set by ````Page.setInterceptFileChooserDialog``` command (default: false).
    """
    params: T_JSON_DICT = {}
    if enable_file_chooser_opened_event is not None:
        params["enableFileChooserOpenedEvent"] = enable_file_chooser_opened_event
    cmd_dict: T_JSON_DICT = {
        "method": "Page.enable",
        "Params": params,
    }
    yield cmd_dict

x_enable__mutmut_mutants : ClassVar[MutantDict] = {
'x_enable__mutmut_1': x_enable__mutmut_1, 
    'x_enable__mutmut_2': x_enable__mutmut_2, 
    'x_enable__mutmut_3': x_enable__mutmut_3, 
    'x_enable__mutmut_4': x_enable__mutmut_4, 
    'x_enable__mutmut_5': x_enable__mutmut_5, 
    'x_enable__mutmut_6': x_enable__mutmut_6, 
    'x_enable__mutmut_7': x_enable__mutmut_7, 
    'x_enable__mutmut_8': x_enable__mutmut_8, 
    'x_enable__mutmut_9': x_enable__mutmut_9, 
    'x_enable__mutmut_10': x_enable__mutmut_10, 
    'x_enable__mutmut_11': x_enable__mutmut_11, 
    'x_enable__mutmut_12': x_enable__mutmut_12, 
    'x_enable__mutmut_13': x_enable__mutmut_13, 
    'x_enable__mutmut_14': x_enable__mutmut_14, 
    'x_enable__mutmut_15': x_enable__mutmut_15, 
    'x_enable__mutmut_16': x_enable__mutmut_16, 
    'x_enable__mutmut_17': x_enable__mutmut_17
}

def enable(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_enable__mutmut_orig, x_enable__mutmut_mutants, args, kwargs)
    return result 

enable.__signature__ = _mutmut_signature(x_enable__mutmut_orig)
x_enable__mutmut_orig.__name__ = 'x_enable'


def x_get_app_manifest__mutmut_orig(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_1(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = None
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_2(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_3(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_4(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["XXmanifestIdXX"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_5(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestid"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_6(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["MANIFESTID"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_7(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["Manifestid"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_8(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_9(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_10(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_11(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_12(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getAppManifestXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_13(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "page.getappmanifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_14(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETAPPMANIFEST",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_15(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getappmanifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_16(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_17(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_18(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_19(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = None
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_20(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(None),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_21(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["XXurlXX"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_22(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["URL"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_23(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["Url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_24(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(None) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_25(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["XXerrorsXX"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_26(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["ERRORS"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_27(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["Errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_28(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(None) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_29(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["XXdataXX"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_30(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["DATA"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_31(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["Data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_32(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "XXdataXX" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_33(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "DATA" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_34(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "Data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_35(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" not in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_36(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(None) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_37(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["XXparsedXX"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_38(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["PARSED"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_39(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["Parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_40(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "XXparsedXX" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_41(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "PARSED" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_42(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "Parsed" in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_43(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" not in json else None,
        WebAppManifest.from_json(json["manifest"]),
    )


def x_get_app_manifest__mutmut_44(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(None),
    )


def x_get_app_manifest__mutmut_45(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["XXmanifestXX"]),
    )


def x_get_app_manifest__mutmut_46(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["MANIFEST"]),
    )


def x_get_app_manifest__mutmut_47(
    manifest_id: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, list[AppManifestError], str | None, AppManifestParsedProperties | None, WebAppManifest]]:
    """
    Gets the processed manifest for this current document.
      This API always waits for the manifest to be loaded.
      If manifestId is provided, and it does not match the manifest of the
        current document, this API errors out.
      If there is not a loaded page, this API errors out immediately.

    :param manifest_id: *(Optional)*
    :returns: A tuple with the following items:

        0. **url** - Manifest location.
        1. **errors** -
        2. **data** - *(Optional)* Manifest content.
        3. **parsed** - *(Optional)* Parsed manifest properties. Deprecated, use manifest instead.
        4. **manifest** -
    """
    params: T_JSON_DICT = {}
    if manifest_id is not None:
        params["manifestId"] = manifest_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppManifest",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["url"]),
        [AppManifestError.from_json(i) for i in json["errors"]],
        str(json["data"]) if "data" in json else None,
        AppManifestParsedProperties.from_json(json["parsed"]) if "parsed" in json else None,
        WebAppManifest.from_json(json["Manifest"]),
    )

x_get_app_manifest__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_app_manifest__mutmut_1': x_get_app_manifest__mutmut_1, 
    'x_get_app_manifest__mutmut_2': x_get_app_manifest__mutmut_2, 
    'x_get_app_manifest__mutmut_3': x_get_app_manifest__mutmut_3, 
    'x_get_app_manifest__mutmut_4': x_get_app_manifest__mutmut_4, 
    'x_get_app_manifest__mutmut_5': x_get_app_manifest__mutmut_5, 
    'x_get_app_manifest__mutmut_6': x_get_app_manifest__mutmut_6, 
    'x_get_app_manifest__mutmut_7': x_get_app_manifest__mutmut_7, 
    'x_get_app_manifest__mutmut_8': x_get_app_manifest__mutmut_8, 
    'x_get_app_manifest__mutmut_9': x_get_app_manifest__mutmut_9, 
    'x_get_app_manifest__mutmut_10': x_get_app_manifest__mutmut_10, 
    'x_get_app_manifest__mutmut_11': x_get_app_manifest__mutmut_11, 
    'x_get_app_manifest__mutmut_12': x_get_app_manifest__mutmut_12, 
    'x_get_app_manifest__mutmut_13': x_get_app_manifest__mutmut_13, 
    'x_get_app_manifest__mutmut_14': x_get_app_manifest__mutmut_14, 
    'x_get_app_manifest__mutmut_15': x_get_app_manifest__mutmut_15, 
    'x_get_app_manifest__mutmut_16': x_get_app_manifest__mutmut_16, 
    'x_get_app_manifest__mutmut_17': x_get_app_manifest__mutmut_17, 
    'x_get_app_manifest__mutmut_18': x_get_app_manifest__mutmut_18, 
    'x_get_app_manifest__mutmut_19': x_get_app_manifest__mutmut_19, 
    'x_get_app_manifest__mutmut_20': x_get_app_manifest__mutmut_20, 
    'x_get_app_manifest__mutmut_21': x_get_app_manifest__mutmut_21, 
    'x_get_app_manifest__mutmut_22': x_get_app_manifest__mutmut_22, 
    'x_get_app_manifest__mutmut_23': x_get_app_manifest__mutmut_23, 
    'x_get_app_manifest__mutmut_24': x_get_app_manifest__mutmut_24, 
    'x_get_app_manifest__mutmut_25': x_get_app_manifest__mutmut_25, 
    'x_get_app_manifest__mutmut_26': x_get_app_manifest__mutmut_26, 
    'x_get_app_manifest__mutmut_27': x_get_app_manifest__mutmut_27, 
    'x_get_app_manifest__mutmut_28': x_get_app_manifest__mutmut_28, 
    'x_get_app_manifest__mutmut_29': x_get_app_manifest__mutmut_29, 
    'x_get_app_manifest__mutmut_30': x_get_app_manifest__mutmut_30, 
    'x_get_app_manifest__mutmut_31': x_get_app_manifest__mutmut_31, 
    'x_get_app_manifest__mutmut_32': x_get_app_manifest__mutmut_32, 
    'x_get_app_manifest__mutmut_33': x_get_app_manifest__mutmut_33, 
    'x_get_app_manifest__mutmut_34': x_get_app_manifest__mutmut_34, 
    'x_get_app_manifest__mutmut_35': x_get_app_manifest__mutmut_35, 
    'x_get_app_manifest__mutmut_36': x_get_app_manifest__mutmut_36, 
    'x_get_app_manifest__mutmut_37': x_get_app_manifest__mutmut_37, 
    'x_get_app_manifest__mutmut_38': x_get_app_manifest__mutmut_38, 
    'x_get_app_manifest__mutmut_39': x_get_app_manifest__mutmut_39, 
    'x_get_app_manifest__mutmut_40': x_get_app_manifest__mutmut_40, 
    'x_get_app_manifest__mutmut_41': x_get_app_manifest__mutmut_41, 
    'x_get_app_manifest__mutmut_42': x_get_app_manifest__mutmut_42, 
    'x_get_app_manifest__mutmut_43': x_get_app_manifest__mutmut_43, 
    'x_get_app_manifest__mutmut_44': x_get_app_manifest__mutmut_44, 
    'x_get_app_manifest__mutmut_45': x_get_app_manifest__mutmut_45, 
    'x_get_app_manifest__mutmut_46': x_get_app_manifest__mutmut_46, 
    'x_get_app_manifest__mutmut_47': x_get_app_manifest__mutmut_47
}

def get_app_manifest(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_app_manifest__mutmut_orig, x_get_app_manifest__mutmut_mutants, args, kwargs)
    return result 

get_app_manifest.__signature__ = _mutmut_signature(x_get_app_manifest__mutmut_orig)
x_get_app_manifest__mutmut_orig.__name__ = 'x_get_app_manifest'


def x_get_installability_errors__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getInstallabilityErrors",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["installabilityErrors"]]


def x_get_installability_errors__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["installabilityErrors"]]


def x_get_installability_errors__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getInstallabilityErrors",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["installabilityErrors"]]


def x_get_installability_errors__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getInstallabilityErrors",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["installabilityErrors"]]


def x_get_installability_errors__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getInstallabilityErrors",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["installabilityErrors"]]


def x_get_installability_errors__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getInstallabilityErrorsXX",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["installabilityErrors"]]


def x_get_installability_errors__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.getinstallabilityerrors",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["installabilityErrors"]]


def x_get_installability_errors__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETINSTALLABILITYERRORS",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["installabilityErrors"]]


def x_get_installability_errors__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getinstallabilityerrors",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["installabilityErrors"]]


def x_get_installability_errors__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getInstallabilityErrors",
    }
    json = None
    return [InstallabilityError.from_json(i) for i in json["installabilityErrors"]]


def x_get_installability_errors__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getInstallabilityErrors",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(None) for i in json["installabilityErrors"]]


def x_get_installability_errors__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getInstallabilityErrors",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["XXinstallabilityErrorsXX"]]


def x_get_installability_errors__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getInstallabilityErrors",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["installabilityerrors"]]


def x_get_installability_errors__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getInstallabilityErrors",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["INSTALLABILITYERRORS"]]


def x_get_installability_errors__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, list[InstallabilityError]]:
    """


    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getInstallabilityErrors",
    }
    json = yield cmd_dict
    return [InstallabilityError.from_json(i) for i in json["Installabilityerrors"]]

x_get_installability_errors__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_installability_errors__mutmut_1': x_get_installability_errors__mutmut_1, 
    'x_get_installability_errors__mutmut_2': x_get_installability_errors__mutmut_2, 
    'x_get_installability_errors__mutmut_3': x_get_installability_errors__mutmut_3, 
    'x_get_installability_errors__mutmut_4': x_get_installability_errors__mutmut_4, 
    'x_get_installability_errors__mutmut_5': x_get_installability_errors__mutmut_5, 
    'x_get_installability_errors__mutmut_6': x_get_installability_errors__mutmut_6, 
    'x_get_installability_errors__mutmut_7': x_get_installability_errors__mutmut_7, 
    'x_get_installability_errors__mutmut_8': x_get_installability_errors__mutmut_8, 
    'x_get_installability_errors__mutmut_9': x_get_installability_errors__mutmut_9, 
    'x_get_installability_errors__mutmut_10': x_get_installability_errors__mutmut_10, 
    'x_get_installability_errors__mutmut_11': x_get_installability_errors__mutmut_11, 
    'x_get_installability_errors__mutmut_12': x_get_installability_errors__mutmut_12, 
    'x_get_installability_errors__mutmut_13': x_get_installability_errors__mutmut_13, 
    'x_get_installability_errors__mutmut_14': x_get_installability_errors__mutmut_14
}

def get_installability_errors(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_installability_errors__mutmut_orig, x_get_installability_errors__mutmut_mutants, args, kwargs)
    return result 

get_installability_errors.__signature__ = _mutmut_signature(x_get_installability_errors__mutmut_orig)
x_get_installability_errors__mutmut_orig.__name__ = 'x_get_installability_errors'


def x_get_manifest_icons__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getManifestIconsXX",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.getmanifesticons",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETMANIFESTICONS",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getmanifesticons",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = None
    return str(json["primaryIcon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(None) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["XXprimaryIconXX"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["primaryicon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["PRIMARYICON"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["Primaryicon"]) if "primaryIcon" in json else None


def x_get_manifest_icons__mutmut_15() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "XXprimaryIconXX" in json else None


def x_get_manifest_icons__mutmut_16() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "primaryicon" in json else None


def x_get_manifest_icons__mutmut_17() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "PRIMARYICON" in json else None


def x_get_manifest_icons__mutmut_18() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "Primaryicon" in json else None


def x_get_manifest_icons__mutmut_19() -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.

    **EXPERIMENTAL**

    :returns:
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getManifestIcons",
    }
    json = yield cmd_dict
    return str(json["primaryIcon"]) if "primaryIcon" not in json else None

x_get_manifest_icons__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_manifest_icons__mutmut_1': x_get_manifest_icons__mutmut_1, 
    'x_get_manifest_icons__mutmut_2': x_get_manifest_icons__mutmut_2, 
    'x_get_manifest_icons__mutmut_3': x_get_manifest_icons__mutmut_3, 
    'x_get_manifest_icons__mutmut_4': x_get_manifest_icons__mutmut_4, 
    'x_get_manifest_icons__mutmut_5': x_get_manifest_icons__mutmut_5, 
    'x_get_manifest_icons__mutmut_6': x_get_manifest_icons__mutmut_6, 
    'x_get_manifest_icons__mutmut_7': x_get_manifest_icons__mutmut_7, 
    'x_get_manifest_icons__mutmut_8': x_get_manifest_icons__mutmut_8, 
    'x_get_manifest_icons__mutmut_9': x_get_manifest_icons__mutmut_9, 
    'x_get_manifest_icons__mutmut_10': x_get_manifest_icons__mutmut_10, 
    'x_get_manifest_icons__mutmut_11': x_get_manifest_icons__mutmut_11, 
    'x_get_manifest_icons__mutmut_12': x_get_manifest_icons__mutmut_12, 
    'x_get_manifest_icons__mutmut_13': x_get_manifest_icons__mutmut_13, 
    'x_get_manifest_icons__mutmut_14': x_get_manifest_icons__mutmut_14, 
    'x_get_manifest_icons__mutmut_15': x_get_manifest_icons__mutmut_15, 
    'x_get_manifest_icons__mutmut_16': x_get_manifest_icons__mutmut_16, 
    'x_get_manifest_icons__mutmut_17': x_get_manifest_icons__mutmut_17, 
    'x_get_manifest_icons__mutmut_18': x_get_manifest_icons__mutmut_18, 
    'x_get_manifest_icons__mutmut_19': x_get_manifest_icons__mutmut_19
}

def get_manifest_icons(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_manifest_icons__mutmut_orig, x_get_manifest_icons__mutmut_mutants, args, kwargs)
    return result 

get_manifest_icons.__signature__ = _mutmut_signature(x_get_manifest_icons__mutmut_orig)
x_get_manifest_icons__mutmut_orig.__name__ = 'x_get_manifest_icons'


def x_get_app_id__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getAppIdXX",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.getappid",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETAPPID",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getappid",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = None
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(None) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["XXappIdXX"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appid"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["APPID"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["Appid"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_15() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "XXappIdXX" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_16() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appid" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_17() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "APPID" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_18() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "Appid" in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_19() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" not in json else None,
        str(json["recommendedId"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_20() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(None) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_21() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["XXrecommendedIdXX"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_22() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedid"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_23() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["RECOMMENDEDID"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_24() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["Recommendedid"]) if "recommendedId" in json else None,
    )


def x_get_app_id__mutmut_25() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "XXrecommendedIdXX" in json else None,
    )


def x_get_app_id__mutmut_26() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedid" in json else None,
    )


def x_get_app_id__mutmut_27() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "RECOMMENDEDID" in json else None,
    )


def x_get_app_id__mutmut_28() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "Recommendedid" in json else None,
    )


def x_get_app_id__mutmut_29() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, str | None]]:
    """
    Returns the unique (PWA) app id.
    Only returns values if the feature flag 'WebAppEnableManifestId' is enabled

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **appId** - *(Optional)* App id, either from manifest's id attribute or computed from start_url
        1. **recommendedId** - *(Optional)* Recommendation for manifest's id attribute to match current id computed from start_url
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAppId",
    }
    json = yield cmd_dict
    return (
        str(json["appId"]) if "appId" in json else None,
        str(json["recommendedId"]) if "recommendedId" not in json else None,
    )

x_get_app_id__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_app_id__mutmut_1': x_get_app_id__mutmut_1, 
    'x_get_app_id__mutmut_2': x_get_app_id__mutmut_2, 
    'x_get_app_id__mutmut_3': x_get_app_id__mutmut_3, 
    'x_get_app_id__mutmut_4': x_get_app_id__mutmut_4, 
    'x_get_app_id__mutmut_5': x_get_app_id__mutmut_5, 
    'x_get_app_id__mutmut_6': x_get_app_id__mutmut_6, 
    'x_get_app_id__mutmut_7': x_get_app_id__mutmut_7, 
    'x_get_app_id__mutmut_8': x_get_app_id__mutmut_8, 
    'x_get_app_id__mutmut_9': x_get_app_id__mutmut_9, 
    'x_get_app_id__mutmut_10': x_get_app_id__mutmut_10, 
    'x_get_app_id__mutmut_11': x_get_app_id__mutmut_11, 
    'x_get_app_id__mutmut_12': x_get_app_id__mutmut_12, 
    'x_get_app_id__mutmut_13': x_get_app_id__mutmut_13, 
    'x_get_app_id__mutmut_14': x_get_app_id__mutmut_14, 
    'x_get_app_id__mutmut_15': x_get_app_id__mutmut_15, 
    'x_get_app_id__mutmut_16': x_get_app_id__mutmut_16, 
    'x_get_app_id__mutmut_17': x_get_app_id__mutmut_17, 
    'x_get_app_id__mutmut_18': x_get_app_id__mutmut_18, 
    'x_get_app_id__mutmut_19': x_get_app_id__mutmut_19, 
    'x_get_app_id__mutmut_20': x_get_app_id__mutmut_20, 
    'x_get_app_id__mutmut_21': x_get_app_id__mutmut_21, 
    'x_get_app_id__mutmut_22': x_get_app_id__mutmut_22, 
    'x_get_app_id__mutmut_23': x_get_app_id__mutmut_23, 
    'x_get_app_id__mutmut_24': x_get_app_id__mutmut_24, 
    'x_get_app_id__mutmut_25': x_get_app_id__mutmut_25, 
    'x_get_app_id__mutmut_26': x_get_app_id__mutmut_26, 
    'x_get_app_id__mutmut_27': x_get_app_id__mutmut_27, 
    'x_get_app_id__mutmut_28': x_get_app_id__mutmut_28, 
    'x_get_app_id__mutmut_29': x_get_app_id__mutmut_29
}

def get_app_id(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_app_id__mutmut_orig, x_get_app_id__mutmut_mutants, args, kwargs)
    return result 

get_app_id.__signature__ = _mutmut_signature(x_get_app_id__mutmut_orig)
x_get_app_id__mutmut_orig.__name__ = 'x_get_app_id'


def x_get_ad_script_id__mutmut_orig(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_1(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = None
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_2(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_3(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["XXframeIdXX"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_4(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameid"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_5(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["FRAMEID"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_6(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["Frameid"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_7(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_8(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_9(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_10(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_11(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getAdScriptIdXX",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_12(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "page.getadscriptid",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_13(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETADSCRIPTID",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_14(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getadscriptid",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_15(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_16(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_17(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "Params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_18(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = None
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_19(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(None) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_20(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["XXadScriptIdXX"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_21(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adscriptid"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_22(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["ADSCRIPTID"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_23(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["Adscriptid"]) if "adScriptId" in json else None


def x_get_ad_script_id__mutmut_24(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "XXadScriptIdXX" in json else None


def x_get_ad_script_id__mutmut_25(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adscriptid" in json else None


def x_get_ad_script_id__mutmut_26(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "ADSCRIPTID" in json else None


def x_get_ad_script_id__mutmut_27(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "Adscriptid" in json else None


def x_get_ad_script_id__mutmut_28(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, AdScriptId | None]:
    """


    **EXPERIMENTAL**

    :param frame_id:
    :returns: *(Optional)* Identifies the bottom-most script which caused the frame to be labelled as an ad. Only sent if frame is labelled as an ad and id is available.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getAdScriptId",
        "params": params,
    }
    json = yield cmd_dict
    return AdScriptId.from_json(json["adScriptId"]) if "adScriptId" not in json else None

x_get_ad_script_id__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_ad_script_id__mutmut_1': x_get_ad_script_id__mutmut_1, 
    'x_get_ad_script_id__mutmut_2': x_get_ad_script_id__mutmut_2, 
    'x_get_ad_script_id__mutmut_3': x_get_ad_script_id__mutmut_3, 
    'x_get_ad_script_id__mutmut_4': x_get_ad_script_id__mutmut_4, 
    'x_get_ad_script_id__mutmut_5': x_get_ad_script_id__mutmut_5, 
    'x_get_ad_script_id__mutmut_6': x_get_ad_script_id__mutmut_6, 
    'x_get_ad_script_id__mutmut_7': x_get_ad_script_id__mutmut_7, 
    'x_get_ad_script_id__mutmut_8': x_get_ad_script_id__mutmut_8, 
    'x_get_ad_script_id__mutmut_9': x_get_ad_script_id__mutmut_9, 
    'x_get_ad_script_id__mutmut_10': x_get_ad_script_id__mutmut_10, 
    'x_get_ad_script_id__mutmut_11': x_get_ad_script_id__mutmut_11, 
    'x_get_ad_script_id__mutmut_12': x_get_ad_script_id__mutmut_12, 
    'x_get_ad_script_id__mutmut_13': x_get_ad_script_id__mutmut_13, 
    'x_get_ad_script_id__mutmut_14': x_get_ad_script_id__mutmut_14, 
    'x_get_ad_script_id__mutmut_15': x_get_ad_script_id__mutmut_15, 
    'x_get_ad_script_id__mutmut_16': x_get_ad_script_id__mutmut_16, 
    'x_get_ad_script_id__mutmut_17': x_get_ad_script_id__mutmut_17, 
    'x_get_ad_script_id__mutmut_18': x_get_ad_script_id__mutmut_18, 
    'x_get_ad_script_id__mutmut_19': x_get_ad_script_id__mutmut_19, 
    'x_get_ad_script_id__mutmut_20': x_get_ad_script_id__mutmut_20, 
    'x_get_ad_script_id__mutmut_21': x_get_ad_script_id__mutmut_21, 
    'x_get_ad_script_id__mutmut_22': x_get_ad_script_id__mutmut_22, 
    'x_get_ad_script_id__mutmut_23': x_get_ad_script_id__mutmut_23, 
    'x_get_ad_script_id__mutmut_24': x_get_ad_script_id__mutmut_24, 
    'x_get_ad_script_id__mutmut_25': x_get_ad_script_id__mutmut_25, 
    'x_get_ad_script_id__mutmut_26': x_get_ad_script_id__mutmut_26, 
    'x_get_ad_script_id__mutmut_27': x_get_ad_script_id__mutmut_27, 
    'x_get_ad_script_id__mutmut_28': x_get_ad_script_id__mutmut_28
}

def get_ad_script_id(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_ad_script_id__mutmut_orig, x_get_ad_script_id__mutmut_mutants, args, kwargs)
    return result 

get_ad_script_id.__signature__ = _mutmut_signature(x_get_ad_script_id__mutmut_orig)
x_get_ad_script_id__mutmut_orig.__name__ = 'x_get_ad_script_id'


def x_get_frame_tree__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getFrameTree",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["frameTree"])


def x_get_frame_tree__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return FrameTree.from_json(json["frameTree"])


def x_get_frame_tree__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getFrameTree",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["frameTree"])


def x_get_frame_tree__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getFrameTree",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["frameTree"])


def x_get_frame_tree__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getFrameTree",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["frameTree"])


def x_get_frame_tree__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getFrameTreeXX",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["frameTree"])


def x_get_frame_tree__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.getframetree",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["frameTree"])


def x_get_frame_tree__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETFRAMETREE",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["frameTree"])


def x_get_frame_tree__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getframetree",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["frameTree"])


def x_get_frame_tree__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getFrameTree",
    }
    json = None
    return FrameTree.from_json(json["frameTree"])


def x_get_frame_tree__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getFrameTree",
    }
    json = yield cmd_dict
    return FrameTree.from_json(None)


def x_get_frame_tree__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getFrameTree",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["XXframeTreeXX"])


def x_get_frame_tree__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getFrameTree",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["frametree"])


def x_get_frame_tree__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getFrameTree",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["FRAMETREE"])


def x_get_frame_tree__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameTree]:
    """
    Returns present frame tree structure.

    :returns: Present frame tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getFrameTree",
    }
    json = yield cmd_dict
    return FrameTree.from_json(json["Frametree"])

x_get_frame_tree__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_frame_tree__mutmut_1': x_get_frame_tree__mutmut_1, 
    'x_get_frame_tree__mutmut_2': x_get_frame_tree__mutmut_2, 
    'x_get_frame_tree__mutmut_3': x_get_frame_tree__mutmut_3, 
    'x_get_frame_tree__mutmut_4': x_get_frame_tree__mutmut_4, 
    'x_get_frame_tree__mutmut_5': x_get_frame_tree__mutmut_5, 
    'x_get_frame_tree__mutmut_6': x_get_frame_tree__mutmut_6, 
    'x_get_frame_tree__mutmut_7': x_get_frame_tree__mutmut_7, 
    'x_get_frame_tree__mutmut_8': x_get_frame_tree__mutmut_8, 
    'x_get_frame_tree__mutmut_9': x_get_frame_tree__mutmut_9, 
    'x_get_frame_tree__mutmut_10': x_get_frame_tree__mutmut_10, 
    'x_get_frame_tree__mutmut_11': x_get_frame_tree__mutmut_11, 
    'x_get_frame_tree__mutmut_12': x_get_frame_tree__mutmut_12, 
    'x_get_frame_tree__mutmut_13': x_get_frame_tree__mutmut_13, 
    'x_get_frame_tree__mutmut_14': x_get_frame_tree__mutmut_14
}

def get_frame_tree(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_frame_tree__mutmut_orig, x_get_frame_tree__mutmut_mutants, args, kwargs)
    return result 

get_frame_tree.__signature__ = _mutmut_signature(x_get_frame_tree__mutmut_orig)
x_get_frame_tree__mutmut_orig.__name__ = 'x_get_frame_tree'


def x_get_layout_metrics__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getLayoutMetricsXX",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.getlayoutmetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETLAYOUTMETRICS",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getlayoutmetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = None
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(None),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["XXlayoutViewportXX"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutviewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["LAYOUTVIEWPORT"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["Layoutviewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_15() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(None),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_16() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["XXvisualViewportXX"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_17() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualviewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_18() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["VISUALVIEWPORT"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_19() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["Visualviewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_20() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(None),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_21() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["XXcontentSizeXX"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_22() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentsize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_23() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["CONTENTSIZE"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_24() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["Contentsize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_25() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(None),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_26() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["XXcssLayoutViewportXX"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_27() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["csslayoutviewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_28() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["CSSLAYOUTVIEWPORT"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_29() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["Csslayoutviewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_30() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(None),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_31() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["XXcssVisualViewportXX"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_32() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssvisualviewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_33() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["CSSVISUALVIEWPORT"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_34() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["Cssvisualviewport"]),
        dom.Rect.from_json(json["cssContentSize"]),
    )


def x_get_layout_metrics__mutmut_35() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(None),
    )


def x_get_layout_metrics__mutmut_36() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["XXcssContentSizeXX"]),
    )


def x_get_layout_metrics__mutmut_37() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["csscontentsize"]),
    )


def x_get_layout_metrics__mutmut_38() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["CSSCONTENTSIZE"]),
    )


def x_get_layout_metrics__mutmut_39() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[LayoutViewport, VisualViewport, dom.Rect, LayoutViewport, VisualViewport, dom.Rect]]:
    """
    Returns metrics relating to the layouting of the page, such as viewport bounds/scale.

    :returns: A tuple with the following items:

        0. **layoutViewport** - Deprecated metrics relating to the layout viewport. Is in device pixels. Use ``cssLayoutViewport`` instead.
        1. **visualViewport** - Deprecated metrics relating to the visual viewport. Is in device pixels. Use ``cssVisualViewport`` instead.
        2. **contentSize** - Deprecated size of scrollable area. Is in DP. Use ``cssContentSize`` instead.
        3. **cssLayoutViewport** - Metrics relating to the layout viewport in CSS pixels.
        4. **cssVisualViewport** - Metrics relating to the visual viewport in CSS pixels.
        5. **cssContentSize** - Size of scrollable area in CSS pixels.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getLayoutMetrics",
    }
    json = yield cmd_dict
    return (
        LayoutViewport.from_json(json["layoutViewport"]),
        VisualViewport.from_json(json["visualViewport"]),
        dom.Rect.from_json(json["contentSize"]),
        LayoutViewport.from_json(json["cssLayoutViewport"]),
        VisualViewport.from_json(json["cssVisualViewport"]),
        dom.Rect.from_json(json["Csscontentsize"]),
    )

x_get_layout_metrics__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_layout_metrics__mutmut_1': x_get_layout_metrics__mutmut_1, 
    'x_get_layout_metrics__mutmut_2': x_get_layout_metrics__mutmut_2, 
    'x_get_layout_metrics__mutmut_3': x_get_layout_metrics__mutmut_3, 
    'x_get_layout_metrics__mutmut_4': x_get_layout_metrics__mutmut_4, 
    'x_get_layout_metrics__mutmut_5': x_get_layout_metrics__mutmut_5, 
    'x_get_layout_metrics__mutmut_6': x_get_layout_metrics__mutmut_6, 
    'x_get_layout_metrics__mutmut_7': x_get_layout_metrics__mutmut_7, 
    'x_get_layout_metrics__mutmut_8': x_get_layout_metrics__mutmut_8, 
    'x_get_layout_metrics__mutmut_9': x_get_layout_metrics__mutmut_9, 
    'x_get_layout_metrics__mutmut_10': x_get_layout_metrics__mutmut_10, 
    'x_get_layout_metrics__mutmut_11': x_get_layout_metrics__mutmut_11, 
    'x_get_layout_metrics__mutmut_12': x_get_layout_metrics__mutmut_12, 
    'x_get_layout_metrics__mutmut_13': x_get_layout_metrics__mutmut_13, 
    'x_get_layout_metrics__mutmut_14': x_get_layout_metrics__mutmut_14, 
    'x_get_layout_metrics__mutmut_15': x_get_layout_metrics__mutmut_15, 
    'x_get_layout_metrics__mutmut_16': x_get_layout_metrics__mutmut_16, 
    'x_get_layout_metrics__mutmut_17': x_get_layout_metrics__mutmut_17, 
    'x_get_layout_metrics__mutmut_18': x_get_layout_metrics__mutmut_18, 
    'x_get_layout_metrics__mutmut_19': x_get_layout_metrics__mutmut_19, 
    'x_get_layout_metrics__mutmut_20': x_get_layout_metrics__mutmut_20, 
    'x_get_layout_metrics__mutmut_21': x_get_layout_metrics__mutmut_21, 
    'x_get_layout_metrics__mutmut_22': x_get_layout_metrics__mutmut_22, 
    'x_get_layout_metrics__mutmut_23': x_get_layout_metrics__mutmut_23, 
    'x_get_layout_metrics__mutmut_24': x_get_layout_metrics__mutmut_24, 
    'x_get_layout_metrics__mutmut_25': x_get_layout_metrics__mutmut_25, 
    'x_get_layout_metrics__mutmut_26': x_get_layout_metrics__mutmut_26, 
    'x_get_layout_metrics__mutmut_27': x_get_layout_metrics__mutmut_27, 
    'x_get_layout_metrics__mutmut_28': x_get_layout_metrics__mutmut_28, 
    'x_get_layout_metrics__mutmut_29': x_get_layout_metrics__mutmut_29, 
    'x_get_layout_metrics__mutmut_30': x_get_layout_metrics__mutmut_30, 
    'x_get_layout_metrics__mutmut_31': x_get_layout_metrics__mutmut_31, 
    'x_get_layout_metrics__mutmut_32': x_get_layout_metrics__mutmut_32, 
    'x_get_layout_metrics__mutmut_33': x_get_layout_metrics__mutmut_33, 
    'x_get_layout_metrics__mutmut_34': x_get_layout_metrics__mutmut_34, 
    'x_get_layout_metrics__mutmut_35': x_get_layout_metrics__mutmut_35, 
    'x_get_layout_metrics__mutmut_36': x_get_layout_metrics__mutmut_36, 
    'x_get_layout_metrics__mutmut_37': x_get_layout_metrics__mutmut_37, 
    'x_get_layout_metrics__mutmut_38': x_get_layout_metrics__mutmut_38, 
    'x_get_layout_metrics__mutmut_39': x_get_layout_metrics__mutmut_39
}

def get_layout_metrics(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_layout_metrics__mutmut_orig, x_get_layout_metrics__mutmut_mutants, args, kwargs)
    return result 

get_layout_metrics.__signature__ = _mutmut_signature(x_get_layout_metrics__mutmut_orig)
x_get_layout_metrics__mutmut_orig.__name__ = 'x_get_layout_metrics'


def x_get_navigation_history__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getNavigationHistoryXX",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.getnavigationhistory",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETNAVIGATIONHISTORY",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getnavigationhistory",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getNavigationHistory",
    }
    json = None
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(None),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["XXcurrentIndexXX"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["currentindex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["CURRENTINDEX"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["Currentindex"]),
        [NavigationEntry.from_json(i) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_15() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(None) for i in json["entries"]],
    )


def x_get_navigation_history__mutmut_16() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["XXentriesXX"]],
    )


def x_get_navigation_history__mutmut_17() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["ENTRIES"]],
    )


def x_get_navigation_history__mutmut_18() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, list[NavigationEntry]]]:
    """
    Returns navigation history for the current page.

    :returns: A tuple with the following items:

        0. **currentIndex** - Index of the current navigation history entry.
        1. **entries** - Array of navigation history entries.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getNavigationHistory",
    }
    json = yield cmd_dict
    return (
        int(json["currentIndex"]),
        [NavigationEntry.from_json(i) for i in json["Entries"]],
    )

x_get_navigation_history__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_navigation_history__mutmut_1': x_get_navigation_history__mutmut_1, 
    'x_get_navigation_history__mutmut_2': x_get_navigation_history__mutmut_2, 
    'x_get_navigation_history__mutmut_3': x_get_navigation_history__mutmut_3, 
    'x_get_navigation_history__mutmut_4': x_get_navigation_history__mutmut_4, 
    'x_get_navigation_history__mutmut_5': x_get_navigation_history__mutmut_5, 
    'x_get_navigation_history__mutmut_6': x_get_navigation_history__mutmut_6, 
    'x_get_navigation_history__mutmut_7': x_get_navigation_history__mutmut_7, 
    'x_get_navigation_history__mutmut_8': x_get_navigation_history__mutmut_8, 
    'x_get_navigation_history__mutmut_9': x_get_navigation_history__mutmut_9, 
    'x_get_navigation_history__mutmut_10': x_get_navigation_history__mutmut_10, 
    'x_get_navigation_history__mutmut_11': x_get_navigation_history__mutmut_11, 
    'x_get_navigation_history__mutmut_12': x_get_navigation_history__mutmut_12, 
    'x_get_navigation_history__mutmut_13': x_get_navigation_history__mutmut_13, 
    'x_get_navigation_history__mutmut_14': x_get_navigation_history__mutmut_14, 
    'x_get_navigation_history__mutmut_15': x_get_navigation_history__mutmut_15, 
    'x_get_navigation_history__mutmut_16': x_get_navigation_history__mutmut_16, 
    'x_get_navigation_history__mutmut_17': x_get_navigation_history__mutmut_17, 
    'x_get_navigation_history__mutmut_18': x_get_navigation_history__mutmut_18
}

def get_navigation_history(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_navigation_history__mutmut_orig, x_get_navigation_history__mutmut_mutants, args, kwargs)
    return result 

get_navigation_history.__signature__ = _mutmut_signature(x_get_navigation_history__mutmut_orig)
x_get_navigation_history__mutmut_orig.__name__ = 'x_get_navigation_history'


def x_reset_navigation_history__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resets navigation history for the current page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.resetNavigationHistory",
    }
    yield cmd_dict


def x_reset_navigation_history__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resets navigation history for the current page.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_reset_navigation_history__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resets navigation history for the current page.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.resetNavigationHistory",
    }
    yield cmd_dict


def x_reset_navigation_history__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resets navigation history for the current page.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.resetNavigationHistory",
    }
    yield cmd_dict


def x_reset_navigation_history__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resets navigation history for the current page.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.resetNavigationHistory",
    }
    yield cmd_dict


def x_reset_navigation_history__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resets navigation history for the current page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.resetNavigationHistoryXX",
    }
    yield cmd_dict


def x_reset_navigation_history__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resets navigation history for the current page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.resetnavigationhistory",
    }
    yield cmd_dict


def x_reset_navigation_history__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resets navigation history for the current page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.RESETNAVIGATIONHISTORY",
    }
    yield cmd_dict


def x_reset_navigation_history__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resets navigation history for the current page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.resetnavigationhistory",
    }
    yield cmd_dict

x_reset_navigation_history__mutmut_mutants : ClassVar[MutantDict] = {
'x_reset_navigation_history__mutmut_1': x_reset_navigation_history__mutmut_1, 
    'x_reset_navigation_history__mutmut_2': x_reset_navigation_history__mutmut_2, 
    'x_reset_navigation_history__mutmut_3': x_reset_navigation_history__mutmut_3, 
    'x_reset_navigation_history__mutmut_4': x_reset_navigation_history__mutmut_4, 
    'x_reset_navigation_history__mutmut_5': x_reset_navigation_history__mutmut_5, 
    'x_reset_navigation_history__mutmut_6': x_reset_navigation_history__mutmut_6, 
    'x_reset_navigation_history__mutmut_7': x_reset_navigation_history__mutmut_7, 
    'x_reset_navigation_history__mutmut_8': x_reset_navigation_history__mutmut_8
}

def reset_navigation_history(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_reset_navigation_history__mutmut_orig, x_reset_navigation_history__mutmut_mutants, args, kwargs)
    return result 

reset_navigation_history.__signature__ = _mutmut_signature(x_reset_navigation_history__mutmut_orig)
x_reset_navigation_history__mutmut_orig.__name__ = 'x_reset_navigation_history'


def x_get_resource_content__mutmut_orig(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_1(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = None
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_2(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = None
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_3(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["XXframeIdXX"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_4(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameid"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_5(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["FRAMEID"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_6(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["Frameid"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_7(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_8(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["XXurlXX"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_9(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["URL"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_10(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["Url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_11(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_12(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_13(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_14(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_15(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getResourceContentXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_16(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "page.getresourcecontent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_17(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETRESOURCECONTENT",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_18(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getresourcecontent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_19(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_20(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_21(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_22(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = None
    return (
        str(json["content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_23(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(None),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_24(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["XXcontentXX"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_25(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["CONTENT"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_26(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["Content"]),
        bool(json["base64Encoded"]),
    )


def x_get_resource_content__mutmut_27(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(None),
    )


def x_get_resource_content__mutmut_28(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["XXbase64EncodedXX"]),
    )


def x_get_resource_content__mutmut_29(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["base64encoded"]),
    )


def x_get_resource_content__mutmut_30(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["BASE64ENCODED"]),
    )


def x_get_resource_content__mutmut_31(
    frame_id: FrameId,
    url: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, bool]]:
    """
    Returns content of the given resource.

    **EXPERIMENTAL**

    :param frame_id: Frame id to get resource for.
    :param url: URL of the resource to get content for.
    :returns: A tuple with the following items:

        0. **content** - Resource content.
        1. **base64Encoded** - True, if content was served as base64.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceContent",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["content"]),
        bool(json["Base64encoded"]),
    )

x_get_resource_content__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_resource_content__mutmut_1': x_get_resource_content__mutmut_1, 
    'x_get_resource_content__mutmut_2': x_get_resource_content__mutmut_2, 
    'x_get_resource_content__mutmut_3': x_get_resource_content__mutmut_3, 
    'x_get_resource_content__mutmut_4': x_get_resource_content__mutmut_4, 
    'x_get_resource_content__mutmut_5': x_get_resource_content__mutmut_5, 
    'x_get_resource_content__mutmut_6': x_get_resource_content__mutmut_6, 
    'x_get_resource_content__mutmut_7': x_get_resource_content__mutmut_7, 
    'x_get_resource_content__mutmut_8': x_get_resource_content__mutmut_8, 
    'x_get_resource_content__mutmut_9': x_get_resource_content__mutmut_9, 
    'x_get_resource_content__mutmut_10': x_get_resource_content__mutmut_10, 
    'x_get_resource_content__mutmut_11': x_get_resource_content__mutmut_11, 
    'x_get_resource_content__mutmut_12': x_get_resource_content__mutmut_12, 
    'x_get_resource_content__mutmut_13': x_get_resource_content__mutmut_13, 
    'x_get_resource_content__mutmut_14': x_get_resource_content__mutmut_14, 
    'x_get_resource_content__mutmut_15': x_get_resource_content__mutmut_15, 
    'x_get_resource_content__mutmut_16': x_get_resource_content__mutmut_16, 
    'x_get_resource_content__mutmut_17': x_get_resource_content__mutmut_17, 
    'x_get_resource_content__mutmut_18': x_get_resource_content__mutmut_18, 
    'x_get_resource_content__mutmut_19': x_get_resource_content__mutmut_19, 
    'x_get_resource_content__mutmut_20': x_get_resource_content__mutmut_20, 
    'x_get_resource_content__mutmut_21': x_get_resource_content__mutmut_21, 
    'x_get_resource_content__mutmut_22': x_get_resource_content__mutmut_22, 
    'x_get_resource_content__mutmut_23': x_get_resource_content__mutmut_23, 
    'x_get_resource_content__mutmut_24': x_get_resource_content__mutmut_24, 
    'x_get_resource_content__mutmut_25': x_get_resource_content__mutmut_25, 
    'x_get_resource_content__mutmut_26': x_get_resource_content__mutmut_26, 
    'x_get_resource_content__mutmut_27': x_get_resource_content__mutmut_27, 
    'x_get_resource_content__mutmut_28': x_get_resource_content__mutmut_28, 
    'x_get_resource_content__mutmut_29': x_get_resource_content__mutmut_29, 
    'x_get_resource_content__mutmut_30': x_get_resource_content__mutmut_30, 
    'x_get_resource_content__mutmut_31': x_get_resource_content__mutmut_31
}

def get_resource_content(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_resource_content__mutmut_orig, x_get_resource_content__mutmut_mutants, args, kwargs)
    return result 

get_resource_content.__signature__ = _mutmut_signature(x_get_resource_content__mutmut_orig)
x_get_resource_content__mutmut_orig.__name__ = 'x_get_resource_content'


def x_get_resource_tree__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceTree",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["frameTree"])


def x_get_resource_tree__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["frameTree"])


def x_get_resource_tree__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getResourceTree",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["frameTree"])


def x_get_resource_tree__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getResourceTree",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["frameTree"])


def x_get_resource_tree__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getResourceTree",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["frameTree"])


def x_get_resource_tree__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getResourceTreeXX",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["frameTree"])


def x_get_resource_tree__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.getresourcetree",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["frameTree"])


def x_get_resource_tree__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETRESOURCETREE",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["frameTree"])


def x_get_resource_tree__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getresourcetree",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["frameTree"])


def x_get_resource_tree__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceTree",
    }
    json = None
    return FrameResourceTree.from_json(json["frameTree"])


def x_get_resource_tree__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceTree",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(None)


def x_get_resource_tree__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceTree",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["XXframeTreeXX"])


def x_get_resource_tree__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceTree",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["frametree"])


def x_get_resource_tree__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceTree",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["FRAMETREE"])


def x_get_resource_tree__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, FrameResourceTree]:
    """
    Returns present frame / resource tree structure.

    **EXPERIMENTAL**

    :returns: Present frame / resource tree structure.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getResourceTree",
    }
    json = yield cmd_dict
    return FrameResourceTree.from_json(json["Frametree"])

x_get_resource_tree__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_resource_tree__mutmut_1': x_get_resource_tree__mutmut_1, 
    'x_get_resource_tree__mutmut_2': x_get_resource_tree__mutmut_2, 
    'x_get_resource_tree__mutmut_3': x_get_resource_tree__mutmut_3, 
    'x_get_resource_tree__mutmut_4': x_get_resource_tree__mutmut_4, 
    'x_get_resource_tree__mutmut_5': x_get_resource_tree__mutmut_5, 
    'x_get_resource_tree__mutmut_6': x_get_resource_tree__mutmut_6, 
    'x_get_resource_tree__mutmut_7': x_get_resource_tree__mutmut_7, 
    'x_get_resource_tree__mutmut_8': x_get_resource_tree__mutmut_8, 
    'x_get_resource_tree__mutmut_9': x_get_resource_tree__mutmut_9, 
    'x_get_resource_tree__mutmut_10': x_get_resource_tree__mutmut_10, 
    'x_get_resource_tree__mutmut_11': x_get_resource_tree__mutmut_11, 
    'x_get_resource_tree__mutmut_12': x_get_resource_tree__mutmut_12, 
    'x_get_resource_tree__mutmut_13': x_get_resource_tree__mutmut_13, 
    'x_get_resource_tree__mutmut_14': x_get_resource_tree__mutmut_14
}

def get_resource_tree(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_resource_tree__mutmut_orig, x_get_resource_tree__mutmut_mutants, args, kwargs)
    return result 

get_resource_tree.__signature__ = _mutmut_signature(x_get_resource_tree__mutmut_orig)
x_get_resource_tree__mutmut_orig.__name__ = 'x_get_resource_tree'


def x_handle_java_script_dialog__mutmut_orig(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_1(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = None
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_2(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = None
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_3(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["XXacceptXX"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_4(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["ACCEPT"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_5(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["Accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_6(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_7(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_8(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["XXpromptTextXX"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_9(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["prompttext"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_10(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["PROMPTTEXT"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_11(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["Prompttext"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_12(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_13(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_14(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_15(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.handleJavaScriptDialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_16(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.handleJavaScriptDialogXX",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_17(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "page.handlejavascriptdialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_18(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.HANDLEJAVASCRIPTDIALOG",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_19(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handlejavascriptdialog",
        "params": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_20(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_21(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "PARAMS": params,
    }
    yield cmd_dict


def x_handle_java_script_dialog__mutmut_22(
    accept: bool,
    prompt_text: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).

    :param accept: Whether to accept or dismiss the dialog.
    :param prompt_text: *(Optional)* The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
    """
    params: T_JSON_DICT = {}
    params["accept"] = accept
    if prompt_text is not None:
        params["promptText"] = prompt_text
    cmd_dict: T_JSON_DICT = {
        "method": "Page.handleJavaScriptDialog",
        "Params": params,
    }
    yield cmd_dict

x_handle_java_script_dialog__mutmut_mutants : ClassVar[MutantDict] = {
'x_handle_java_script_dialog__mutmut_1': x_handle_java_script_dialog__mutmut_1, 
    'x_handle_java_script_dialog__mutmut_2': x_handle_java_script_dialog__mutmut_2, 
    'x_handle_java_script_dialog__mutmut_3': x_handle_java_script_dialog__mutmut_3, 
    'x_handle_java_script_dialog__mutmut_4': x_handle_java_script_dialog__mutmut_4, 
    'x_handle_java_script_dialog__mutmut_5': x_handle_java_script_dialog__mutmut_5, 
    'x_handle_java_script_dialog__mutmut_6': x_handle_java_script_dialog__mutmut_6, 
    'x_handle_java_script_dialog__mutmut_7': x_handle_java_script_dialog__mutmut_7, 
    'x_handle_java_script_dialog__mutmut_8': x_handle_java_script_dialog__mutmut_8, 
    'x_handle_java_script_dialog__mutmut_9': x_handle_java_script_dialog__mutmut_9, 
    'x_handle_java_script_dialog__mutmut_10': x_handle_java_script_dialog__mutmut_10, 
    'x_handle_java_script_dialog__mutmut_11': x_handle_java_script_dialog__mutmut_11, 
    'x_handle_java_script_dialog__mutmut_12': x_handle_java_script_dialog__mutmut_12, 
    'x_handle_java_script_dialog__mutmut_13': x_handle_java_script_dialog__mutmut_13, 
    'x_handle_java_script_dialog__mutmut_14': x_handle_java_script_dialog__mutmut_14, 
    'x_handle_java_script_dialog__mutmut_15': x_handle_java_script_dialog__mutmut_15, 
    'x_handle_java_script_dialog__mutmut_16': x_handle_java_script_dialog__mutmut_16, 
    'x_handle_java_script_dialog__mutmut_17': x_handle_java_script_dialog__mutmut_17, 
    'x_handle_java_script_dialog__mutmut_18': x_handle_java_script_dialog__mutmut_18, 
    'x_handle_java_script_dialog__mutmut_19': x_handle_java_script_dialog__mutmut_19, 
    'x_handle_java_script_dialog__mutmut_20': x_handle_java_script_dialog__mutmut_20, 
    'x_handle_java_script_dialog__mutmut_21': x_handle_java_script_dialog__mutmut_21, 
    'x_handle_java_script_dialog__mutmut_22': x_handle_java_script_dialog__mutmut_22
}

def handle_java_script_dialog(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_handle_java_script_dialog__mutmut_orig, x_handle_java_script_dialog__mutmut_mutants, args, kwargs)
    return result 

handle_java_script_dialog.__signature__ = _mutmut_signature(x_handle_java_script_dialog__mutmut_orig)
x_handle_java_script_dialog__mutmut_orig.__name__ = 'x_handle_java_script_dialog'


def x_navigate__mutmut_orig(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_1(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = None
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_2(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = None
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_3(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["XXurlXX"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_4(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["URL"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_5(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["Url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_6(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_7(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = None
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_8(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["XXreferrerXX"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_9(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["REFERRER"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_10(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["Referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_11(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_12(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = None
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_13(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["XXtransitionTypeXX"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_14(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitiontype"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_15(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["TRANSITIONTYPE"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_16(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["Transitiontype"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_17(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_18(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = None
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_19(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["XXframeIdXX"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_20(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameid"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_21(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["FRAMEID"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_22(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["Frameid"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_23(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_24(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_25(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["XXreferrerPolicyXX"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_26(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerpolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_27(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["REFERRERPOLICY"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_28(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["Referrerpolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_29(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_30(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_31(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_32(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_33(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.navigateXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_34(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_35(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.NAVIGATE",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_36(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_37(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_38(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_39(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = None
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_40(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(None),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_41(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["XXframeIdXX"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_42(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameid"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_43(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["FRAMEID"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_44(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["Frameid"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_45(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(None) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_46(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["XXloaderIdXX"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_47(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderid"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_48(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["LOADERID"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_49(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["Loaderid"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_50(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "XXloaderIdXX" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_51(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderid" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_52(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "LOADERID" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_53(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "Loaderid" in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_54(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" not in json else None,
        str(json["errorText"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_55(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(None) if "errorText" in json else None,
    )


def x_navigate__mutmut_56(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["XXerrorTextXX"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_57(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errortext"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_58(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["ERRORTEXT"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_59(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["Errortext"]) if "errorText" in json else None,
    )


def x_navigate__mutmut_60(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "XXerrorTextXX" in json else None,
    )


def x_navigate__mutmut_61(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errortext" in json else None,
    )


def x_navigate__mutmut_62(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "ERRORTEXT" in json else None,
    )


def x_navigate__mutmut_63(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "Errortext" in json else None,
    )


def x_navigate__mutmut_64(
    url: str,
    referrer: str | None = None,
    transition_type: TransitionType | None = None,
    frame_id: FrameId | None = None,
    referrer_policy: ReferrerPolicy | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[FrameId, network.LoaderId | None, str | None]]:
    """
    Navigates current page to the given URL.

    :param url: URL to navigate the page to.
    :param referrer: *(Optional)* Referrer URL.
    :param transition_type: *(Optional)* Intended transition type.
    :param frame_id: *(Optional)* Frame id to navigate, if not specified navigates the top frame.
    :param referrer_policy: **(EXPERIMENTAL)** *(Optional)* Referrer-policy used for the navigation.
    :returns: A tuple with the following items:

        0. **frameId** - Frame id that has navigated (or failed to navigate)
        1. **loaderId** - *(Optional)* Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        2. **errorText** - *(Optional)* User friendly error message, present if and only if navigation has failed.
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    if referrer is not None:
        params["referrer"] = referrer
    if transition_type is not None:
        params["transitionType"] = transition_type.to_json()
    if frame_id is not None:
        params["frameId"] = frame_id.to_json()
    if referrer_policy is not None:
        params["referrerPolicy"] = referrer_policy.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        FrameId.from_json(json["frameId"]),
        network.LoaderId.from_json(json["loaderId"]) if "loaderId" in json else None,
        str(json["errorText"]) if "errorText" not in json else None,
    )

x_navigate__mutmut_mutants : ClassVar[MutantDict] = {
'x_navigate__mutmut_1': x_navigate__mutmut_1, 
    'x_navigate__mutmut_2': x_navigate__mutmut_2, 
    'x_navigate__mutmut_3': x_navigate__mutmut_3, 
    'x_navigate__mutmut_4': x_navigate__mutmut_4, 
    'x_navigate__mutmut_5': x_navigate__mutmut_5, 
    'x_navigate__mutmut_6': x_navigate__mutmut_6, 
    'x_navigate__mutmut_7': x_navigate__mutmut_7, 
    'x_navigate__mutmut_8': x_navigate__mutmut_8, 
    'x_navigate__mutmut_9': x_navigate__mutmut_9, 
    'x_navigate__mutmut_10': x_navigate__mutmut_10, 
    'x_navigate__mutmut_11': x_navigate__mutmut_11, 
    'x_navigate__mutmut_12': x_navigate__mutmut_12, 
    'x_navigate__mutmut_13': x_navigate__mutmut_13, 
    'x_navigate__mutmut_14': x_navigate__mutmut_14, 
    'x_navigate__mutmut_15': x_navigate__mutmut_15, 
    'x_navigate__mutmut_16': x_navigate__mutmut_16, 
    'x_navigate__mutmut_17': x_navigate__mutmut_17, 
    'x_navigate__mutmut_18': x_navigate__mutmut_18, 
    'x_navigate__mutmut_19': x_navigate__mutmut_19, 
    'x_navigate__mutmut_20': x_navigate__mutmut_20, 
    'x_navigate__mutmut_21': x_navigate__mutmut_21, 
    'x_navigate__mutmut_22': x_navigate__mutmut_22, 
    'x_navigate__mutmut_23': x_navigate__mutmut_23, 
    'x_navigate__mutmut_24': x_navigate__mutmut_24, 
    'x_navigate__mutmut_25': x_navigate__mutmut_25, 
    'x_navigate__mutmut_26': x_navigate__mutmut_26, 
    'x_navigate__mutmut_27': x_navigate__mutmut_27, 
    'x_navigate__mutmut_28': x_navigate__mutmut_28, 
    'x_navigate__mutmut_29': x_navigate__mutmut_29, 
    'x_navigate__mutmut_30': x_navigate__mutmut_30, 
    'x_navigate__mutmut_31': x_navigate__mutmut_31, 
    'x_navigate__mutmut_32': x_navigate__mutmut_32, 
    'x_navigate__mutmut_33': x_navigate__mutmut_33, 
    'x_navigate__mutmut_34': x_navigate__mutmut_34, 
    'x_navigate__mutmut_35': x_navigate__mutmut_35, 
    'x_navigate__mutmut_36': x_navigate__mutmut_36, 
    'x_navigate__mutmut_37': x_navigate__mutmut_37, 
    'x_navigate__mutmut_38': x_navigate__mutmut_38, 
    'x_navigate__mutmut_39': x_navigate__mutmut_39, 
    'x_navigate__mutmut_40': x_navigate__mutmut_40, 
    'x_navigate__mutmut_41': x_navigate__mutmut_41, 
    'x_navigate__mutmut_42': x_navigate__mutmut_42, 
    'x_navigate__mutmut_43': x_navigate__mutmut_43, 
    'x_navigate__mutmut_44': x_navigate__mutmut_44, 
    'x_navigate__mutmut_45': x_navigate__mutmut_45, 
    'x_navigate__mutmut_46': x_navigate__mutmut_46, 
    'x_navigate__mutmut_47': x_navigate__mutmut_47, 
    'x_navigate__mutmut_48': x_navigate__mutmut_48, 
    'x_navigate__mutmut_49': x_navigate__mutmut_49, 
    'x_navigate__mutmut_50': x_navigate__mutmut_50, 
    'x_navigate__mutmut_51': x_navigate__mutmut_51, 
    'x_navigate__mutmut_52': x_navigate__mutmut_52, 
    'x_navigate__mutmut_53': x_navigate__mutmut_53, 
    'x_navigate__mutmut_54': x_navigate__mutmut_54, 
    'x_navigate__mutmut_55': x_navigate__mutmut_55, 
    'x_navigate__mutmut_56': x_navigate__mutmut_56, 
    'x_navigate__mutmut_57': x_navigate__mutmut_57, 
    'x_navigate__mutmut_58': x_navigate__mutmut_58, 
    'x_navigate__mutmut_59': x_navigate__mutmut_59, 
    'x_navigate__mutmut_60': x_navigate__mutmut_60, 
    'x_navigate__mutmut_61': x_navigate__mutmut_61, 
    'x_navigate__mutmut_62': x_navigate__mutmut_62, 
    'x_navigate__mutmut_63': x_navigate__mutmut_63, 
    'x_navigate__mutmut_64': x_navigate__mutmut_64
}

def navigate(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_navigate__mutmut_orig, x_navigate__mutmut_mutants, args, kwargs)
    return result 

navigate.__signature__ = _mutmut_signature(x_navigate__mutmut_orig)
x_navigate__mutmut_orig.__name__ = 'x_navigate'


def x_navigate_to_history_entry__mutmut_orig(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigateToHistoryEntry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_1(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = None
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigateToHistoryEntry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_2(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigateToHistoryEntry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_3(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["XXentryIdXX"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigateToHistoryEntry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_4(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryid"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigateToHistoryEntry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_5(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["ENTRYID"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigateToHistoryEntry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_6(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["Entryid"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigateToHistoryEntry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_7(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_8(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.navigateToHistoryEntry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_9(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.navigateToHistoryEntry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_10(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.navigateToHistoryEntry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_11(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.navigateToHistoryEntryXX",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_12(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "page.navigatetohistoryentry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_13(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.NAVIGATETOHISTORYENTRY",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_14(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigatetohistoryentry",
        "params": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_15(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigateToHistoryEntry",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_16(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigateToHistoryEntry",
        "PARAMS": params,
    }
    yield cmd_dict


def x_navigate_to_history_entry__mutmut_17(
    entry_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Navigates current page to the given history entry.

    :param entry_id: Unique id of the entry to navigate to.
    """
    params: T_JSON_DICT = {}
    params["entryId"] = entry_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.navigateToHistoryEntry",
        "Params": params,
    }
    yield cmd_dict

x_navigate_to_history_entry__mutmut_mutants : ClassVar[MutantDict] = {
'x_navigate_to_history_entry__mutmut_1': x_navigate_to_history_entry__mutmut_1, 
    'x_navigate_to_history_entry__mutmut_2': x_navigate_to_history_entry__mutmut_2, 
    'x_navigate_to_history_entry__mutmut_3': x_navigate_to_history_entry__mutmut_3, 
    'x_navigate_to_history_entry__mutmut_4': x_navigate_to_history_entry__mutmut_4, 
    'x_navigate_to_history_entry__mutmut_5': x_navigate_to_history_entry__mutmut_5, 
    'x_navigate_to_history_entry__mutmut_6': x_navigate_to_history_entry__mutmut_6, 
    'x_navigate_to_history_entry__mutmut_7': x_navigate_to_history_entry__mutmut_7, 
    'x_navigate_to_history_entry__mutmut_8': x_navigate_to_history_entry__mutmut_8, 
    'x_navigate_to_history_entry__mutmut_9': x_navigate_to_history_entry__mutmut_9, 
    'x_navigate_to_history_entry__mutmut_10': x_navigate_to_history_entry__mutmut_10, 
    'x_navigate_to_history_entry__mutmut_11': x_navigate_to_history_entry__mutmut_11, 
    'x_navigate_to_history_entry__mutmut_12': x_navigate_to_history_entry__mutmut_12, 
    'x_navigate_to_history_entry__mutmut_13': x_navigate_to_history_entry__mutmut_13, 
    'x_navigate_to_history_entry__mutmut_14': x_navigate_to_history_entry__mutmut_14, 
    'x_navigate_to_history_entry__mutmut_15': x_navigate_to_history_entry__mutmut_15, 
    'x_navigate_to_history_entry__mutmut_16': x_navigate_to_history_entry__mutmut_16, 
    'x_navigate_to_history_entry__mutmut_17': x_navigate_to_history_entry__mutmut_17
}

def navigate_to_history_entry(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_navigate_to_history_entry__mutmut_orig, x_navigate_to_history_entry__mutmut_mutants, args, kwargs)
    return result 

navigate_to_history_entry.__signature__ = _mutmut_signature(x_navigate_to_history_entry__mutmut_orig)
x_navigate_to_history_entry__mutmut_orig.__name__ = 'x_navigate_to_history_entry'


def x_print_to_pdf__mutmut_orig(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_1(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = None
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_2(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_3(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = None
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_4(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["XXlandscapeXX"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_5(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["LANDSCAPE"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_6(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["Landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_7(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_8(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = None
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_9(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["XXdisplayHeaderFooterXX"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_10(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayheaderfooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_11(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["DISPLAYHEADERFOOTER"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_12(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["Displayheaderfooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_13(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_14(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = None
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_15(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["XXprintBackgroundXX"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_16(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printbackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_17(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["PRINTBACKGROUND"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_18(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["Printbackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_19(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_20(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = None
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_21(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["XXscaleXX"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_22(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["SCALE"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_23(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["Scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_24(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_25(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = None
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_26(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["XXpaperWidthXX"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_27(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperwidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_28(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["PAPERWIDTH"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_29(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["Paperwidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_30(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_31(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = None
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_32(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["XXpaperHeightXX"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_33(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperheight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_34(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["PAPERHEIGHT"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_35(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["Paperheight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_36(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_37(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = None
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_38(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["XXmarginTopXX"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_39(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["margintop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_40(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["MARGINTOP"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_41(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["Margintop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_42(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_43(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = None
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_44(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["XXmarginBottomXX"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_45(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginbottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_46(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["MARGINBOTTOM"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_47(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["Marginbottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_48(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_49(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = None
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_50(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["XXmarginLeftXX"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_51(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginleft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_52(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["MARGINLEFT"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_53(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["Marginleft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_54(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_55(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = None
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_56(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["XXmarginRightXX"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_57(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginright"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_58(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["MARGINRIGHT"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_59(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["Marginright"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_60(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_61(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = None
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_62(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["XXpageRangesXX"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_63(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageranges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_64(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["PAGERANGES"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_65(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["Pageranges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_66(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_67(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = None
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_68(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["XXheaderTemplateXX"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_69(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headertemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_70(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["HEADERTEMPLATE"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_71(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["Headertemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_72(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_73(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = None
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_74(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["XXfooterTemplateXX"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_75(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footertemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_76(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["FOOTERTEMPLATE"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_77(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["Footertemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_78(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_79(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = None
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_80(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["XXpreferCSSPageSizeXX"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_81(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["prefercsspagesize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_82(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["PREFERCSSPAGESIZE"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_83(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["Prefercsspagesize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_84(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_85(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = None
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_86(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["XXtransferModeXX"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_87(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transfermode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_88(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["TRANSFERMODE"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_89(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["Transfermode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_90(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_91(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = None
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_92(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["XXgenerateTaggedPDFXX"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_93(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generatetaggedpdf"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_94(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["GENERATETAGGEDPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_95(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["Generatetaggedpdf"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_96(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_97(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_98(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["XXgenerateDocumentOutlineXX"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_99(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generatedocumentoutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_100(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["GENERATEDOCUMENTOUTLINE"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_101(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["Generatedocumentoutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_102(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_103(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_104(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_105(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_106(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.printToPDFXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_107(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "page.printtopdf",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_108(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.PRINTTOPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_109(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printtopdf",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_110(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_111(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_112(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_113(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = None
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_114(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(None),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_115(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["XXdataXX"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_116(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["DATA"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_117(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["Data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_118(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(None) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_119(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["XXstreamXX"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_120(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["STREAM"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_121(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["Stream"]) if "stream" in json else None,
    )


def x_print_to_pdf__mutmut_122(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "XXstreamXX" in json else None,
    )


def x_print_to_pdf__mutmut_123(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "STREAM" in json else None,
    )


def x_print_to_pdf__mutmut_124(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "Stream" in json else None,
    )


def x_print_to_pdf__mutmut_125(
    landscape: bool | None = None,
    display_header_footer: bool | None = None,
    print_background: bool | None = None,
    scale: float | None = None,
    paper_width: float | None = None,
    paper_height: float | None = None,
    margin_top: float | None = None,
    margin_bottom: float | None = None,
    margin_left: float | None = None,
    margin_right: float | None = None,
    page_ranges: str | None = None,
    header_template: str | None = None,
    footer_template: str | None = None,
    prefer_css_page_size: bool | None = None,
    transfer_mode: str | None = None,
    generate_tagged_pdf: bool | None = None,
    generate_document_outline: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, io.StreamHandle | None]]:
    """
    Print page as PDF.

    :param landscape: *(Optional)* Paper orientation. Defaults to false.
    :param display_header_footer: *(Optional)* Display header and footer. Defaults to false.
    :param print_background: *(Optional)* Print background graphics. Defaults to false.
    :param scale: *(Optional)* Scale of the webpage rendering. Defaults to 1.
    :param paper_width: *(Optional)* Paper width in inches. Defaults to 8.5 inches.
    :param paper_height: *(Optional)* Paper height in inches. Defaults to 11 inches.
    :param margin_top: *(Optional)* Top margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_bottom: *(Optional)* Bottom margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_left: *(Optional)* Left margin in inches. Defaults to 1cm (~0.4 inches).
    :param margin_right: *(Optional)* Right margin in inches. Defaults to 1cm (~0.4 inches).
    :param page_ranges: *(Optional)* Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
    :param header_template: *(Optional)* HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - ```date````: formatted print date - ````title````: document title - ````url````: document location - ````pageNumber````: current page number - ````totalPages````: total pages in the document  For example, ````<span class=title></span>```` would generate span containing the title.
    :param footer_template: *(Optional)* HTML template for the print footer. Should use the same format as the ````headerTemplate````.
    :param prefer_css_page_size: *(Optional)* Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
    :param transfer_mode: **(EXPERIMENTAL)** *(Optional)* return as stream
    :param generate_tagged_pdf: **(EXPERIMENTAL)** *(Optional)* Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
    :param generate_document_outline: **(EXPERIMENTAL)** *(Optional)* Whether or not to embed the document outline into the PDF.
    :returns: A tuple with the following items:

        0. **data** - Base64-encoded pdf data. Empty if `` returnAsStream` is specified. (Encoded as a base64 string when passed over JSON)
        1. **stream** - *(Optional)* A handle of the stream that holds resulting PDF data.
    """
    params: T_JSON_DICT = {}
    if landscape is not None:
        params["landscape"] = landscape
    if display_header_footer is not None:
        params["displayHeaderFooter"] = display_header_footer
    if print_background is not None:
        params["printBackground"] = print_background
    if scale is not None:
        params["scale"] = scale
    if paper_width is not None:
        params["paperWidth"] = paper_width
    if paper_height is not None:
        params["paperHeight"] = paper_height
    if margin_top is not None:
        params["marginTop"] = margin_top
    if margin_bottom is not None:
        params["marginBottom"] = margin_bottom
    if margin_left is not None:
        params["marginLeft"] = margin_left
    if margin_right is not None:
        params["marginRight"] = margin_right
    if page_ranges is not None:
        params["pageRanges"] = page_ranges
    if header_template is not None:
        params["headerTemplate"] = header_template
    if footer_template is not None:
        params["footerTemplate"] = footer_template
    if prefer_css_page_size is not None:
        params["preferCSSPageSize"] = prefer_css_page_size
    if transfer_mode is not None:
        params["transferMode"] = transfer_mode
    if generate_tagged_pdf is not None:
        params["generateTaggedPDF"] = generate_tagged_pdf
    if generate_document_outline is not None:
        params["generateDocumentOutline"] = generate_document_outline
    cmd_dict: T_JSON_DICT = {
        "method": "Page.printToPDF",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["data"]),
        io.StreamHandle.from_json(json["stream"]) if "stream" not in json else None,
    )

x_print_to_pdf__mutmut_mutants : ClassVar[MutantDict] = {
'x_print_to_pdf__mutmut_1': x_print_to_pdf__mutmut_1, 
    'x_print_to_pdf__mutmut_2': x_print_to_pdf__mutmut_2, 
    'x_print_to_pdf__mutmut_3': x_print_to_pdf__mutmut_3, 
    'x_print_to_pdf__mutmut_4': x_print_to_pdf__mutmut_4, 
    'x_print_to_pdf__mutmut_5': x_print_to_pdf__mutmut_5, 
    'x_print_to_pdf__mutmut_6': x_print_to_pdf__mutmut_6, 
    'x_print_to_pdf__mutmut_7': x_print_to_pdf__mutmut_7, 
    'x_print_to_pdf__mutmut_8': x_print_to_pdf__mutmut_8, 
    'x_print_to_pdf__mutmut_9': x_print_to_pdf__mutmut_9, 
    'x_print_to_pdf__mutmut_10': x_print_to_pdf__mutmut_10, 
    'x_print_to_pdf__mutmut_11': x_print_to_pdf__mutmut_11, 
    'x_print_to_pdf__mutmut_12': x_print_to_pdf__mutmut_12, 
    'x_print_to_pdf__mutmut_13': x_print_to_pdf__mutmut_13, 
    'x_print_to_pdf__mutmut_14': x_print_to_pdf__mutmut_14, 
    'x_print_to_pdf__mutmut_15': x_print_to_pdf__mutmut_15, 
    'x_print_to_pdf__mutmut_16': x_print_to_pdf__mutmut_16, 
    'x_print_to_pdf__mutmut_17': x_print_to_pdf__mutmut_17, 
    'x_print_to_pdf__mutmut_18': x_print_to_pdf__mutmut_18, 
    'x_print_to_pdf__mutmut_19': x_print_to_pdf__mutmut_19, 
    'x_print_to_pdf__mutmut_20': x_print_to_pdf__mutmut_20, 
    'x_print_to_pdf__mutmut_21': x_print_to_pdf__mutmut_21, 
    'x_print_to_pdf__mutmut_22': x_print_to_pdf__mutmut_22, 
    'x_print_to_pdf__mutmut_23': x_print_to_pdf__mutmut_23, 
    'x_print_to_pdf__mutmut_24': x_print_to_pdf__mutmut_24, 
    'x_print_to_pdf__mutmut_25': x_print_to_pdf__mutmut_25, 
    'x_print_to_pdf__mutmut_26': x_print_to_pdf__mutmut_26, 
    'x_print_to_pdf__mutmut_27': x_print_to_pdf__mutmut_27, 
    'x_print_to_pdf__mutmut_28': x_print_to_pdf__mutmut_28, 
    'x_print_to_pdf__mutmut_29': x_print_to_pdf__mutmut_29, 
    'x_print_to_pdf__mutmut_30': x_print_to_pdf__mutmut_30, 
    'x_print_to_pdf__mutmut_31': x_print_to_pdf__mutmut_31, 
    'x_print_to_pdf__mutmut_32': x_print_to_pdf__mutmut_32, 
    'x_print_to_pdf__mutmut_33': x_print_to_pdf__mutmut_33, 
    'x_print_to_pdf__mutmut_34': x_print_to_pdf__mutmut_34, 
    'x_print_to_pdf__mutmut_35': x_print_to_pdf__mutmut_35, 
    'x_print_to_pdf__mutmut_36': x_print_to_pdf__mutmut_36, 
    'x_print_to_pdf__mutmut_37': x_print_to_pdf__mutmut_37, 
    'x_print_to_pdf__mutmut_38': x_print_to_pdf__mutmut_38, 
    'x_print_to_pdf__mutmut_39': x_print_to_pdf__mutmut_39, 
    'x_print_to_pdf__mutmut_40': x_print_to_pdf__mutmut_40, 
    'x_print_to_pdf__mutmut_41': x_print_to_pdf__mutmut_41, 
    'x_print_to_pdf__mutmut_42': x_print_to_pdf__mutmut_42, 
    'x_print_to_pdf__mutmut_43': x_print_to_pdf__mutmut_43, 
    'x_print_to_pdf__mutmut_44': x_print_to_pdf__mutmut_44, 
    'x_print_to_pdf__mutmut_45': x_print_to_pdf__mutmut_45, 
    'x_print_to_pdf__mutmut_46': x_print_to_pdf__mutmut_46, 
    'x_print_to_pdf__mutmut_47': x_print_to_pdf__mutmut_47, 
    'x_print_to_pdf__mutmut_48': x_print_to_pdf__mutmut_48, 
    'x_print_to_pdf__mutmut_49': x_print_to_pdf__mutmut_49, 
    'x_print_to_pdf__mutmut_50': x_print_to_pdf__mutmut_50, 
    'x_print_to_pdf__mutmut_51': x_print_to_pdf__mutmut_51, 
    'x_print_to_pdf__mutmut_52': x_print_to_pdf__mutmut_52, 
    'x_print_to_pdf__mutmut_53': x_print_to_pdf__mutmut_53, 
    'x_print_to_pdf__mutmut_54': x_print_to_pdf__mutmut_54, 
    'x_print_to_pdf__mutmut_55': x_print_to_pdf__mutmut_55, 
    'x_print_to_pdf__mutmut_56': x_print_to_pdf__mutmut_56, 
    'x_print_to_pdf__mutmut_57': x_print_to_pdf__mutmut_57, 
    'x_print_to_pdf__mutmut_58': x_print_to_pdf__mutmut_58, 
    'x_print_to_pdf__mutmut_59': x_print_to_pdf__mutmut_59, 
    'x_print_to_pdf__mutmut_60': x_print_to_pdf__mutmut_60, 
    'x_print_to_pdf__mutmut_61': x_print_to_pdf__mutmut_61, 
    'x_print_to_pdf__mutmut_62': x_print_to_pdf__mutmut_62, 
    'x_print_to_pdf__mutmut_63': x_print_to_pdf__mutmut_63, 
    'x_print_to_pdf__mutmut_64': x_print_to_pdf__mutmut_64, 
    'x_print_to_pdf__mutmut_65': x_print_to_pdf__mutmut_65, 
    'x_print_to_pdf__mutmut_66': x_print_to_pdf__mutmut_66, 
    'x_print_to_pdf__mutmut_67': x_print_to_pdf__mutmut_67, 
    'x_print_to_pdf__mutmut_68': x_print_to_pdf__mutmut_68, 
    'x_print_to_pdf__mutmut_69': x_print_to_pdf__mutmut_69, 
    'x_print_to_pdf__mutmut_70': x_print_to_pdf__mutmut_70, 
    'x_print_to_pdf__mutmut_71': x_print_to_pdf__mutmut_71, 
    'x_print_to_pdf__mutmut_72': x_print_to_pdf__mutmut_72, 
    'x_print_to_pdf__mutmut_73': x_print_to_pdf__mutmut_73, 
    'x_print_to_pdf__mutmut_74': x_print_to_pdf__mutmut_74, 
    'x_print_to_pdf__mutmut_75': x_print_to_pdf__mutmut_75, 
    'x_print_to_pdf__mutmut_76': x_print_to_pdf__mutmut_76, 
    'x_print_to_pdf__mutmut_77': x_print_to_pdf__mutmut_77, 
    'x_print_to_pdf__mutmut_78': x_print_to_pdf__mutmut_78, 
    'x_print_to_pdf__mutmut_79': x_print_to_pdf__mutmut_79, 
    'x_print_to_pdf__mutmut_80': x_print_to_pdf__mutmut_80, 
    'x_print_to_pdf__mutmut_81': x_print_to_pdf__mutmut_81, 
    'x_print_to_pdf__mutmut_82': x_print_to_pdf__mutmut_82, 
    'x_print_to_pdf__mutmut_83': x_print_to_pdf__mutmut_83, 
    'x_print_to_pdf__mutmut_84': x_print_to_pdf__mutmut_84, 
    'x_print_to_pdf__mutmut_85': x_print_to_pdf__mutmut_85, 
    'x_print_to_pdf__mutmut_86': x_print_to_pdf__mutmut_86, 
    'x_print_to_pdf__mutmut_87': x_print_to_pdf__mutmut_87, 
    'x_print_to_pdf__mutmut_88': x_print_to_pdf__mutmut_88, 
    'x_print_to_pdf__mutmut_89': x_print_to_pdf__mutmut_89, 
    'x_print_to_pdf__mutmut_90': x_print_to_pdf__mutmut_90, 
    'x_print_to_pdf__mutmut_91': x_print_to_pdf__mutmut_91, 
    'x_print_to_pdf__mutmut_92': x_print_to_pdf__mutmut_92, 
    'x_print_to_pdf__mutmut_93': x_print_to_pdf__mutmut_93, 
    'x_print_to_pdf__mutmut_94': x_print_to_pdf__mutmut_94, 
    'x_print_to_pdf__mutmut_95': x_print_to_pdf__mutmut_95, 
    'x_print_to_pdf__mutmut_96': x_print_to_pdf__mutmut_96, 
    'x_print_to_pdf__mutmut_97': x_print_to_pdf__mutmut_97, 
    'x_print_to_pdf__mutmut_98': x_print_to_pdf__mutmut_98, 
    'x_print_to_pdf__mutmut_99': x_print_to_pdf__mutmut_99, 
    'x_print_to_pdf__mutmut_100': x_print_to_pdf__mutmut_100, 
    'x_print_to_pdf__mutmut_101': x_print_to_pdf__mutmut_101, 
    'x_print_to_pdf__mutmut_102': x_print_to_pdf__mutmut_102, 
    'x_print_to_pdf__mutmut_103': x_print_to_pdf__mutmut_103, 
    'x_print_to_pdf__mutmut_104': x_print_to_pdf__mutmut_104, 
    'x_print_to_pdf__mutmut_105': x_print_to_pdf__mutmut_105, 
    'x_print_to_pdf__mutmut_106': x_print_to_pdf__mutmut_106, 
    'x_print_to_pdf__mutmut_107': x_print_to_pdf__mutmut_107, 
    'x_print_to_pdf__mutmut_108': x_print_to_pdf__mutmut_108, 
    'x_print_to_pdf__mutmut_109': x_print_to_pdf__mutmut_109, 
    'x_print_to_pdf__mutmut_110': x_print_to_pdf__mutmut_110, 
    'x_print_to_pdf__mutmut_111': x_print_to_pdf__mutmut_111, 
    'x_print_to_pdf__mutmut_112': x_print_to_pdf__mutmut_112, 
    'x_print_to_pdf__mutmut_113': x_print_to_pdf__mutmut_113, 
    'x_print_to_pdf__mutmut_114': x_print_to_pdf__mutmut_114, 
    'x_print_to_pdf__mutmut_115': x_print_to_pdf__mutmut_115, 
    'x_print_to_pdf__mutmut_116': x_print_to_pdf__mutmut_116, 
    'x_print_to_pdf__mutmut_117': x_print_to_pdf__mutmut_117, 
    'x_print_to_pdf__mutmut_118': x_print_to_pdf__mutmut_118, 
    'x_print_to_pdf__mutmut_119': x_print_to_pdf__mutmut_119, 
    'x_print_to_pdf__mutmut_120': x_print_to_pdf__mutmut_120, 
    'x_print_to_pdf__mutmut_121': x_print_to_pdf__mutmut_121, 
    'x_print_to_pdf__mutmut_122': x_print_to_pdf__mutmut_122, 
    'x_print_to_pdf__mutmut_123': x_print_to_pdf__mutmut_123, 
    'x_print_to_pdf__mutmut_124': x_print_to_pdf__mutmut_124, 
    'x_print_to_pdf__mutmut_125': x_print_to_pdf__mutmut_125
}

def print_to_pdf(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_print_to_pdf__mutmut_orig, x_print_to_pdf__mutmut_mutants, args, kwargs)
    return result 

print_to_pdf.__signature__ = _mutmut_signature(x_print_to_pdf__mutmut_orig)
x_print_to_pdf__mutmut_orig.__name__ = 'x_print_to_pdf'


def x_reload__mutmut_orig(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_1(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = None
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_2(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_3(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = None
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_4(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["XXignoreCacheXX"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_5(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignorecache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_6(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["IGNORECACHE"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_7(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["Ignorecache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_8(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_9(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = None
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_10(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["XXscriptToEvaluateOnLoadXX"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_11(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scripttoevaluateonload"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_12(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["SCRIPTTOEVALUATEONLOAD"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_13(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["Scripttoevaluateonload"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_14(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_15(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_16(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["XXloaderIdXX"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_17(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderid"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_18(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["LOADERID"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_19(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["Loaderid"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_20(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_reload__mutmut_21(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_22(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_23(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_24(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.reloadXX",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_25(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "page.reload",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_26(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.RELOAD",
        "params": params,
    }
    yield cmd_dict


def x_reload__mutmut_27(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_reload__mutmut_28(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "PARAMS": params,
    }
    yield cmd_dict


def x_reload__mutmut_29(
    ignore_cache: bool | None = None,
    script_to_evaluate_on_load: str | None = None,
    loader_id: network.LoaderId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Reloads given page optionally ignoring the cache.

    :param ignore_cache: *(Optional)* If true, browser cache is ignored (as if the user pressed Shift+refresh).
    :param script_to_evaluate_on_load: *(Optional)* If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
    :param loader_id: **(EXPERIMENTAL)** *(Optional)* If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
    """
    params: T_JSON_DICT = {}
    if ignore_cache is not None:
        params["ignoreCache"] = ignore_cache
    if script_to_evaluate_on_load is not None:
        params["scriptToEvaluateOnLoad"] = script_to_evaluate_on_load
    if loader_id is not None:
        params["loaderId"] = loader_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.reload",
        "Params": params,
    }
    yield cmd_dict

x_reload__mutmut_mutants : ClassVar[MutantDict] = {
'x_reload__mutmut_1': x_reload__mutmut_1, 
    'x_reload__mutmut_2': x_reload__mutmut_2, 
    'x_reload__mutmut_3': x_reload__mutmut_3, 
    'x_reload__mutmut_4': x_reload__mutmut_4, 
    'x_reload__mutmut_5': x_reload__mutmut_5, 
    'x_reload__mutmut_6': x_reload__mutmut_6, 
    'x_reload__mutmut_7': x_reload__mutmut_7, 
    'x_reload__mutmut_8': x_reload__mutmut_8, 
    'x_reload__mutmut_9': x_reload__mutmut_9, 
    'x_reload__mutmut_10': x_reload__mutmut_10, 
    'x_reload__mutmut_11': x_reload__mutmut_11, 
    'x_reload__mutmut_12': x_reload__mutmut_12, 
    'x_reload__mutmut_13': x_reload__mutmut_13, 
    'x_reload__mutmut_14': x_reload__mutmut_14, 
    'x_reload__mutmut_15': x_reload__mutmut_15, 
    'x_reload__mutmut_16': x_reload__mutmut_16, 
    'x_reload__mutmut_17': x_reload__mutmut_17, 
    'x_reload__mutmut_18': x_reload__mutmut_18, 
    'x_reload__mutmut_19': x_reload__mutmut_19, 
    'x_reload__mutmut_20': x_reload__mutmut_20, 
    'x_reload__mutmut_21': x_reload__mutmut_21, 
    'x_reload__mutmut_22': x_reload__mutmut_22, 
    'x_reload__mutmut_23': x_reload__mutmut_23, 
    'x_reload__mutmut_24': x_reload__mutmut_24, 
    'x_reload__mutmut_25': x_reload__mutmut_25, 
    'x_reload__mutmut_26': x_reload__mutmut_26, 
    'x_reload__mutmut_27': x_reload__mutmut_27, 
    'x_reload__mutmut_28': x_reload__mutmut_28, 
    'x_reload__mutmut_29': x_reload__mutmut_29
}

def reload(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_reload__mutmut_orig, x_reload__mutmut_mutants, args, kwargs)
    return result 

reload.__signature__ = _mutmut_signature(x_reload__mutmut_orig)
x_reload__mutmut_orig.__name__ = 'x_reload'


def x_remove_script_to_evaluate_on_load__mutmut_orig(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnLoad",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_1(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = None
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnLoad",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_2(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnLoad",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_3(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["XXidentifierXX"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnLoad",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_4(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["IDENTIFIER"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnLoad",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_5(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["Identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnLoad",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_6(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_7(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.removeScriptToEvaluateOnLoad",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_8(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.removeScriptToEvaluateOnLoad",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_9(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.removeScriptToEvaluateOnLoad",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_10(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.removeScriptToEvaluateOnLoadXX",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_11(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "page.removescripttoevaluateonload",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_12(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.REMOVESCRIPTTOEVALUATEONLOAD",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_13(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removescripttoevaluateonload",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_14(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnLoad",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_15(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnLoad",
        "PARAMS": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_load__mutmut_16(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Deprecated, please use removeScriptToEvaluateOnNewDocument instead.

    **EXPERIMENTAL**

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnLoad",
        "Params": params,
    }
    yield cmd_dict

x_remove_script_to_evaluate_on_load__mutmut_mutants : ClassVar[MutantDict] = {
'x_remove_script_to_evaluate_on_load__mutmut_1': x_remove_script_to_evaluate_on_load__mutmut_1, 
    'x_remove_script_to_evaluate_on_load__mutmut_2': x_remove_script_to_evaluate_on_load__mutmut_2, 
    'x_remove_script_to_evaluate_on_load__mutmut_3': x_remove_script_to_evaluate_on_load__mutmut_3, 
    'x_remove_script_to_evaluate_on_load__mutmut_4': x_remove_script_to_evaluate_on_load__mutmut_4, 
    'x_remove_script_to_evaluate_on_load__mutmut_5': x_remove_script_to_evaluate_on_load__mutmut_5, 
    'x_remove_script_to_evaluate_on_load__mutmut_6': x_remove_script_to_evaluate_on_load__mutmut_6, 
    'x_remove_script_to_evaluate_on_load__mutmut_7': x_remove_script_to_evaluate_on_load__mutmut_7, 
    'x_remove_script_to_evaluate_on_load__mutmut_8': x_remove_script_to_evaluate_on_load__mutmut_8, 
    'x_remove_script_to_evaluate_on_load__mutmut_9': x_remove_script_to_evaluate_on_load__mutmut_9, 
    'x_remove_script_to_evaluate_on_load__mutmut_10': x_remove_script_to_evaluate_on_load__mutmut_10, 
    'x_remove_script_to_evaluate_on_load__mutmut_11': x_remove_script_to_evaluate_on_load__mutmut_11, 
    'x_remove_script_to_evaluate_on_load__mutmut_12': x_remove_script_to_evaluate_on_load__mutmut_12, 
    'x_remove_script_to_evaluate_on_load__mutmut_13': x_remove_script_to_evaluate_on_load__mutmut_13, 
    'x_remove_script_to_evaluate_on_load__mutmut_14': x_remove_script_to_evaluate_on_load__mutmut_14, 
    'x_remove_script_to_evaluate_on_load__mutmut_15': x_remove_script_to_evaluate_on_load__mutmut_15, 
    'x_remove_script_to_evaluate_on_load__mutmut_16': x_remove_script_to_evaluate_on_load__mutmut_16
}

def remove_script_to_evaluate_on_load(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_remove_script_to_evaluate_on_load__mutmut_orig, x_remove_script_to_evaluate_on_load__mutmut_mutants, args, kwargs)
    return result 

remove_script_to_evaluate_on_load.__signature__ = _mutmut_signature(x_remove_script_to_evaluate_on_load__mutmut_orig)
x_remove_script_to_evaluate_on_load__mutmut_orig.__name__ = 'x_remove_script_to_evaluate_on_load'


def x_remove_script_to_evaluate_on_new_document__mutmut_orig(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnNewDocument",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_1(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = None
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnNewDocument",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_2(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnNewDocument",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_3(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["XXidentifierXX"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnNewDocument",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_4(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["IDENTIFIER"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnNewDocument",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_5(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["Identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnNewDocument",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_6(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_7(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.removeScriptToEvaluateOnNewDocument",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_8(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.removeScriptToEvaluateOnNewDocument",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_9(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.removeScriptToEvaluateOnNewDocument",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_10(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.removeScriptToEvaluateOnNewDocumentXX",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_11(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "page.removescripttoevaluateonnewdocument",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_12(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.REMOVESCRIPTTOEVALUATEONNEWDOCUMENT",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_13(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removescripttoevaluateonnewdocument",
        "params": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_14(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnNewDocument",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_15(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnNewDocument",
        "PARAMS": params,
    }
    yield cmd_dict


def x_remove_script_to_evaluate_on_new_document__mutmut_16(
    identifier: ScriptIdentifier,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes given script from the list.

    :param identifier:
    """
    params: T_JSON_DICT = {}
    params["identifier"] = identifier.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.removeScriptToEvaluateOnNewDocument",
        "Params": params,
    }
    yield cmd_dict

x_remove_script_to_evaluate_on_new_document__mutmut_mutants : ClassVar[MutantDict] = {
'x_remove_script_to_evaluate_on_new_document__mutmut_1': x_remove_script_to_evaluate_on_new_document__mutmut_1, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_2': x_remove_script_to_evaluate_on_new_document__mutmut_2, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_3': x_remove_script_to_evaluate_on_new_document__mutmut_3, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_4': x_remove_script_to_evaluate_on_new_document__mutmut_4, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_5': x_remove_script_to_evaluate_on_new_document__mutmut_5, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_6': x_remove_script_to_evaluate_on_new_document__mutmut_6, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_7': x_remove_script_to_evaluate_on_new_document__mutmut_7, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_8': x_remove_script_to_evaluate_on_new_document__mutmut_8, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_9': x_remove_script_to_evaluate_on_new_document__mutmut_9, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_10': x_remove_script_to_evaluate_on_new_document__mutmut_10, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_11': x_remove_script_to_evaluate_on_new_document__mutmut_11, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_12': x_remove_script_to_evaluate_on_new_document__mutmut_12, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_13': x_remove_script_to_evaluate_on_new_document__mutmut_13, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_14': x_remove_script_to_evaluate_on_new_document__mutmut_14, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_15': x_remove_script_to_evaluate_on_new_document__mutmut_15, 
    'x_remove_script_to_evaluate_on_new_document__mutmut_16': x_remove_script_to_evaluate_on_new_document__mutmut_16
}

def remove_script_to_evaluate_on_new_document(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_remove_script_to_evaluate_on_new_document__mutmut_orig, x_remove_script_to_evaluate_on_new_document__mutmut_mutants, args, kwargs)
    return result 

remove_script_to_evaluate_on_new_document.__signature__ = _mutmut_signature(x_remove_script_to_evaluate_on_new_document__mutmut_orig)
x_remove_script_to_evaluate_on_new_document__mutmut_orig.__name__ = 'x_remove_script_to_evaluate_on_new_document'


def x_screencast_frame_ack__mutmut_orig(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.screencastFrameAck",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_1(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = None
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.screencastFrameAck",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_2(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.screencastFrameAck",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_3(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["XXsessionIdXX"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.screencastFrameAck",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_4(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionid"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.screencastFrameAck",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_5(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["SESSIONID"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.screencastFrameAck",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_6(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["Sessionid"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.screencastFrameAck",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_7(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_screencast_frame_ack__mutmut_8(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.screencastFrameAck",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_9(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.screencastFrameAck",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_10(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.screencastFrameAck",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_11(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.screencastFrameAckXX",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_12(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "page.screencastframeack",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_13(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SCREENCASTFRAMEACK",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_14(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.screencastframeack",
        "params": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_15(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.screencastFrameAck",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_16(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.screencastFrameAck",
        "PARAMS": params,
    }
    yield cmd_dict


def x_screencast_frame_ack__mutmut_17(
    session_id: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Acknowledges that a screencast frame has been received by the frontend.

    **EXPERIMENTAL**

    :param session_id: Frame number.
    """
    params: T_JSON_DICT = {}
    params["sessionId"] = session_id
    cmd_dict: T_JSON_DICT = {
        "method": "Page.screencastFrameAck",
        "Params": params,
    }
    yield cmd_dict

x_screencast_frame_ack__mutmut_mutants : ClassVar[MutantDict] = {
'x_screencast_frame_ack__mutmut_1': x_screencast_frame_ack__mutmut_1, 
    'x_screencast_frame_ack__mutmut_2': x_screencast_frame_ack__mutmut_2, 
    'x_screencast_frame_ack__mutmut_3': x_screencast_frame_ack__mutmut_3, 
    'x_screencast_frame_ack__mutmut_4': x_screencast_frame_ack__mutmut_4, 
    'x_screencast_frame_ack__mutmut_5': x_screencast_frame_ack__mutmut_5, 
    'x_screencast_frame_ack__mutmut_6': x_screencast_frame_ack__mutmut_6, 
    'x_screencast_frame_ack__mutmut_7': x_screencast_frame_ack__mutmut_7, 
    'x_screencast_frame_ack__mutmut_8': x_screencast_frame_ack__mutmut_8, 
    'x_screencast_frame_ack__mutmut_9': x_screencast_frame_ack__mutmut_9, 
    'x_screencast_frame_ack__mutmut_10': x_screencast_frame_ack__mutmut_10, 
    'x_screencast_frame_ack__mutmut_11': x_screencast_frame_ack__mutmut_11, 
    'x_screencast_frame_ack__mutmut_12': x_screencast_frame_ack__mutmut_12, 
    'x_screencast_frame_ack__mutmut_13': x_screencast_frame_ack__mutmut_13, 
    'x_screencast_frame_ack__mutmut_14': x_screencast_frame_ack__mutmut_14, 
    'x_screencast_frame_ack__mutmut_15': x_screencast_frame_ack__mutmut_15, 
    'x_screencast_frame_ack__mutmut_16': x_screencast_frame_ack__mutmut_16, 
    'x_screencast_frame_ack__mutmut_17': x_screencast_frame_ack__mutmut_17
}

def screencast_frame_ack(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_screencast_frame_ack__mutmut_orig, x_screencast_frame_ack__mutmut_mutants, args, kwargs)
    return result 

screencast_frame_ack.__signature__ = _mutmut_signature(x_screencast_frame_ack__mutmut_orig)
x_screencast_frame_ack__mutmut_orig.__name__ = 'x_screencast_frame_ack'


def x_search_in_resource__mutmut_orig(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_1(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = None
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_2(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = None
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_3(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["XXframeIdXX"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_4(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameid"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_5(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["FRAMEID"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_6(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["Frameid"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_7(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = None
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_8(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["XXurlXX"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_9(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["URL"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_10(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["Url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_11(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = None
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_12(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["XXqueryXX"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_13(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["QUERY"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_14(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["Query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_15(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_16(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = None
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_17(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["XXcaseSensitiveXX"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_18(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["casesensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_19(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["CASESENSITIVE"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_20(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["Casesensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_21(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_22(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_23(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["XXisRegexXX"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_24(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isregex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_25(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["ISREGEX"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_26(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["Isregex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_27(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_28(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_29(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_30(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_31(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.searchInResourceXX",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_32(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "page.searchinresource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_33(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SEARCHINRESOURCE",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_34(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchinresource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_35(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_36(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_37(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "Params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_38(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = None
    return [debugger.SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_resource__mutmut_39(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(None) for i in json["result"]]


def x_search_in_resource__mutmut_40(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["XXresultXX"]]


def x_search_in_resource__mutmut_41(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["RESULT"]]


def x_search_in_resource__mutmut_42(
    frame_id: FrameId,
    url: str,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[debugger.SearchMatch]]:
    """
    Searches for given string in resource content.

    **EXPERIMENTAL**

    :param frame_id: Frame id for resource to search in.
    :param url: URL of the resource to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["url"] = url
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Page.searchInResource",
        "params": params,
    }
    json = yield cmd_dict
    return [debugger.SearchMatch.from_json(i) for i in json["Result"]]

x_search_in_resource__mutmut_mutants : ClassVar[MutantDict] = {
'x_search_in_resource__mutmut_1': x_search_in_resource__mutmut_1, 
    'x_search_in_resource__mutmut_2': x_search_in_resource__mutmut_2, 
    'x_search_in_resource__mutmut_3': x_search_in_resource__mutmut_3, 
    'x_search_in_resource__mutmut_4': x_search_in_resource__mutmut_4, 
    'x_search_in_resource__mutmut_5': x_search_in_resource__mutmut_5, 
    'x_search_in_resource__mutmut_6': x_search_in_resource__mutmut_6, 
    'x_search_in_resource__mutmut_7': x_search_in_resource__mutmut_7, 
    'x_search_in_resource__mutmut_8': x_search_in_resource__mutmut_8, 
    'x_search_in_resource__mutmut_9': x_search_in_resource__mutmut_9, 
    'x_search_in_resource__mutmut_10': x_search_in_resource__mutmut_10, 
    'x_search_in_resource__mutmut_11': x_search_in_resource__mutmut_11, 
    'x_search_in_resource__mutmut_12': x_search_in_resource__mutmut_12, 
    'x_search_in_resource__mutmut_13': x_search_in_resource__mutmut_13, 
    'x_search_in_resource__mutmut_14': x_search_in_resource__mutmut_14, 
    'x_search_in_resource__mutmut_15': x_search_in_resource__mutmut_15, 
    'x_search_in_resource__mutmut_16': x_search_in_resource__mutmut_16, 
    'x_search_in_resource__mutmut_17': x_search_in_resource__mutmut_17, 
    'x_search_in_resource__mutmut_18': x_search_in_resource__mutmut_18, 
    'x_search_in_resource__mutmut_19': x_search_in_resource__mutmut_19, 
    'x_search_in_resource__mutmut_20': x_search_in_resource__mutmut_20, 
    'x_search_in_resource__mutmut_21': x_search_in_resource__mutmut_21, 
    'x_search_in_resource__mutmut_22': x_search_in_resource__mutmut_22, 
    'x_search_in_resource__mutmut_23': x_search_in_resource__mutmut_23, 
    'x_search_in_resource__mutmut_24': x_search_in_resource__mutmut_24, 
    'x_search_in_resource__mutmut_25': x_search_in_resource__mutmut_25, 
    'x_search_in_resource__mutmut_26': x_search_in_resource__mutmut_26, 
    'x_search_in_resource__mutmut_27': x_search_in_resource__mutmut_27, 
    'x_search_in_resource__mutmut_28': x_search_in_resource__mutmut_28, 
    'x_search_in_resource__mutmut_29': x_search_in_resource__mutmut_29, 
    'x_search_in_resource__mutmut_30': x_search_in_resource__mutmut_30, 
    'x_search_in_resource__mutmut_31': x_search_in_resource__mutmut_31, 
    'x_search_in_resource__mutmut_32': x_search_in_resource__mutmut_32, 
    'x_search_in_resource__mutmut_33': x_search_in_resource__mutmut_33, 
    'x_search_in_resource__mutmut_34': x_search_in_resource__mutmut_34, 
    'x_search_in_resource__mutmut_35': x_search_in_resource__mutmut_35, 
    'x_search_in_resource__mutmut_36': x_search_in_resource__mutmut_36, 
    'x_search_in_resource__mutmut_37': x_search_in_resource__mutmut_37, 
    'x_search_in_resource__mutmut_38': x_search_in_resource__mutmut_38, 
    'x_search_in_resource__mutmut_39': x_search_in_resource__mutmut_39, 
    'x_search_in_resource__mutmut_40': x_search_in_resource__mutmut_40, 
    'x_search_in_resource__mutmut_41': x_search_in_resource__mutmut_41, 
    'x_search_in_resource__mutmut_42': x_search_in_resource__mutmut_42
}

def search_in_resource(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_search_in_resource__mutmut_orig, x_search_in_resource__mutmut_mutants, args, kwargs)
    return result 

search_in_resource.__signature__ = _mutmut_signature(x_search_in_resource__mutmut_orig)
x_search_in_resource__mutmut_orig.__name__ = 'x_search_in_resource'


def x_set_ad_blocking_enabled__mutmut_orig(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setAdBlockingEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_1(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = None
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setAdBlockingEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_2(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setAdBlockingEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_3(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["XXenabledXX"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setAdBlockingEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_4(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["ENABLED"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setAdBlockingEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_5(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["Enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setAdBlockingEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_6(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_7(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setAdBlockingEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_8(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setAdBlockingEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_9(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setAdBlockingEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_10(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setAdBlockingEnabledXX",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_11(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "page.setadblockingenabled",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_12(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETADBLOCKINGENABLED",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_13(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setadblockingenabled",
        "params": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_14(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setAdBlockingEnabled",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_15(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setAdBlockingEnabled",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_ad_blocking_enabled__mutmut_16(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable Chrome's experimental ad filter on all sites.

    **EXPERIMENTAL**

    :param enabled: Whether to block ads.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setAdBlockingEnabled",
        "Params": params,
    }
    yield cmd_dict

x_set_ad_blocking_enabled__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_ad_blocking_enabled__mutmut_1': x_set_ad_blocking_enabled__mutmut_1, 
    'x_set_ad_blocking_enabled__mutmut_2': x_set_ad_blocking_enabled__mutmut_2, 
    'x_set_ad_blocking_enabled__mutmut_3': x_set_ad_blocking_enabled__mutmut_3, 
    'x_set_ad_blocking_enabled__mutmut_4': x_set_ad_blocking_enabled__mutmut_4, 
    'x_set_ad_blocking_enabled__mutmut_5': x_set_ad_blocking_enabled__mutmut_5, 
    'x_set_ad_blocking_enabled__mutmut_6': x_set_ad_blocking_enabled__mutmut_6, 
    'x_set_ad_blocking_enabled__mutmut_7': x_set_ad_blocking_enabled__mutmut_7, 
    'x_set_ad_blocking_enabled__mutmut_8': x_set_ad_blocking_enabled__mutmut_8, 
    'x_set_ad_blocking_enabled__mutmut_9': x_set_ad_blocking_enabled__mutmut_9, 
    'x_set_ad_blocking_enabled__mutmut_10': x_set_ad_blocking_enabled__mutmut_10, 
    'x_set_ad_blocking_enabled__mutmut_11': x_set_ad_blocking_enabled__mutmut_11, 
    'x_set_ad_blocking_enabled__mutmut_12': x_set_ad_blocking_enabled__mutmut_12, 
    'x_set_ad_blocking_enabled__mutmut_13': x_set_ad_blocking_enabled__mutmut_13, 
    'x_set_ad_blocking_enabled__mutmut_14': x_set_ad_blocking_enabled__mutmut_14, 
    'x_set_ad_blocking_enabled__mutmut_15': x_set_ad_blocking_enabled__mutmut_15, 
    'x_set_ad_blocking_enabled__mutmut_16': x_set_ad_blocking_enabled__mutmut_16
}

def set_ad_blocking_enabled(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_ad_blocking_enabled__mutmut_orig, x_set_ad_blocking_enabled__mutmut_mutants, args, kwargs)
    return result 

set_ad_blocking_enabled.__signature__ = _mutmut_signature(x_set_ad_blocking_enabled__mutmut_orig)
x_set_ad_blocking_enabled__mutmut_orig.__name__ = 'x_set_ad_blocking_enabled'


def x_set_bypass_csp__mutmut_orig(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setBypassCSP",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_1(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = None
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setBypassCSP",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_2(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setBypassCSP",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_3(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["XXenabledXX"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setBypassCSP",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_4(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["ENABLED"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setBypassCSP",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_5(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["Enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setBypassCSP",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_6(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_bypass_csp__mutmut_7(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setBypassCSP",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_8(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setBypassCSP",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_9(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setBypassCSP",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_10(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setBypassCSPXX",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_11(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "page.setbypasscsp",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_12(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETBYPASSCSP",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_13(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setbypasscsp",
        "params": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_14(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setBypassCSP",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_15(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setBypassCSP",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_bypass_csp__mutmut_16(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable page Content Security Policy by-passing.

    :param enabled: Whether to bypass page CSP.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setBypassCSP",
        "Params": params,
    }
    yield cmd_dict

x_set_bypass_csp__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_bypass_csp__mutmut_1': x_set_bypass_csp__mutmut_1, 
    'x_set_bypass_csp__mutmut_2': x_set_bypass_csp__mutmut_2, 
    'x_set_bypass_csp__mutmut_3': x_set_bypass_csp__mutmut_3, 
    'x_set_bypass_csp__mutmut_4': x_set_bypass_csp__mutmut_4, 
    'x_set_bypass_csp__mutmut_5': x_set_bypass_csp__mutmut_5, 
    'x_set_bypass_csp__mutmut_6': x_set_bypass_csp__mutmut_6, 
    'x_set_bypass_csp__mutmut_7': x_set_bypass_csp__mutmut_7, 
    'x_set_bypass_csp__mutmut_8': x_set_bypass_csp__mutmut_8, 
    'x_set_bypass_csp__mutmut_9': x_set_bypass_csp__mutmut_9, 
    'x_set_bypass_csp__mutmut_10': x_set_bypass_csp__mutmut_10, 
    'x_set_bypass_csp__mutmut_11': x_set_bypass_csp__mutmut_11, 
    'x_set_bypass_csp__mutmut_12': x_set_bypass_csp__mutmut_12, 
    'x_set_bypass_csp__mutmut_13': x_set_bypass_csp__mutmut_13, 
    'x_set_bypass_csp__mutmut_14': x_set_bypass_csp__mutmut_14, 
    'x_set_bypass_csp__mutmut_15': x_set_bypass_csp__mutmut_15, 
    'x_set_bypass_csp__mutmut_16': x_set_bypass_csp__mutmut_16
}

def set_bypass_csp(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_bypass_csp__mutmut_orig, x_set_bypass_csp__mutmut_mutants, args, kwargs)
    return result 

set_bypass_csp.__signature__ = _mutmut_signature(x_set_bypass_csp__mutmut_orig)
x_set_bypass_csp__mutmut_orig.__name__ = 'x_set_bypass_csp'


def x_get_permissions_policy_state__mutmut_orig(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_1(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = None
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_2(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_3(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["XXframeIdXX"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_4(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameid"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_5(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["FRAMEID"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_6(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["Frameid"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_7(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_8(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_9(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_10(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_11(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getPermissionsPolicyStateXX",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_12(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "page.getpermissionspolicystate",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_13(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETPERMISSIONSPOLICYSTATE",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_14(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getpermissionspolicystate",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_15(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_16(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_17(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "Params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_18(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = None
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_19(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(None) for i in json["states"]]


def x_get_permissions_policy_state__mutmut_20(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["XXstatesXX"]]


def x_get_permissions_policy_state__mutmut_21(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["STATES"]]


def x_get_permissions_policy_state__mutmut_22(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PermissionsPolicyFeatureState]]:
    """
    Get Permissions Policy state on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getPermissionsPolicyState",
        "params": params,
    }
    json = yield cmd_dict
    return [PermissionsPolicyFeatureState.from_json(i) for i in json["States"]]

x_get_permissions_policy_state__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_permissions_policy_state__mutmut_1': x_get_permissions_policy_state__mutmut_1, 
    'x_get_permissions_policy_state__mutmut_2': x_get_permissions_policy_state__mutmut_2, 
    'x_get_permissions_policy_state__mutmut_3': x_get_permissions_policy_state__mutmut_3, 
    'x_get_permissions_policy_state__mutmut_4': x_get_permissions_policy_state__mutmut_4, 
    'x_get_permissions_policy_state__mutmut_5': x_get_permissions_policy_state__mutmut_5, 
    'x_get_permissions_policy_state__mutmut_6': x_get_permissions_policy_state__mutmut_6, 
    'x_get_permissions_policy_state__mutmut_7': x_get_permissions_policy_state__mutmut_7, 
    'x_get_permissions_policy_state__mutmut_8': x_get_permissions_policy_state__mutmut_8, 
    'x_get_permissions_policy_state__mutmut_9': x_get_permissions_policy_state__mutmut_9, 
    'x_get_permissions_policy_state__mutmut_10': x_get_permissions_policy_state__mutmut_10, 
    'x_get_permissions_policy_state__mutmut_11': x_get_permissions_policy_state__mutmut_11, 
    'x_get_permissions_policy_state__mutmut_12': x_get_permissions_policy_state__mutmut_12, 
    'x_get_permissions_policy_state__mutmut_13': x_get_permissions_policy_state__mutmut_13, 
    'x_get_permissions_policy_state__mutmut_14': x_get_permissions_policy_state__mutmut_14, 
    'x_get_permissions_policy_state__mutmut_15': x_get_permissions_policy_state__mutmut_15, 
    'x_get_permissions_policy_state__mutmut_16': x_get_permissions_policy_state__mutmut_16, 
    'x_get_permissions_policy_state__mutmut_17': x_get_permissions_policy_state__mutmut_17, 
    'x_get_permissions_policy_state__mutmut_18': x_get_permissions_policy_state__mutmut_18, 
    'x_get_permissions_policy_state__mutmut_19': x_get_permissions_policy_state__mutmut_19, 
    'x_get_permissions_policy_state__mutmut_20': x_get_permissions_policy_state__mutmut_20, 
    'x_get_permissions_policy_state__mutmut_21': x_get_permissions_policy_state__mutmut_21, 
    'x_get_permissions_policy_state__mutmut_22': x_get_permissions_policy_state__mutmut_22
}

def get_permissions_policy_state(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_permissions_policy_state__mutmut_orig, x_get_permissions_policy_state__mutmut_mutants, args, kwargs)
    return result 

get_permissions_policy_state.__signature__ = _mutmut_signature(x_get_permissions_policy_state__mutmut_orig)
x_get_permissions_policy_state__mutmut_orig.__name__ = 'x_get_permissions_policy_state'


def x_get_origin_trials__mutmut_orig(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_1(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = None
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_2(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_3(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["XXframeIdXX"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_4(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameid"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_5(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["FRAMEID"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_6(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["Frameid"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_7(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_8(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_9(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_10(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_11(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.getOriginTrialsXX",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_12(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "page.getorigintrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_13(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GETORIGINTRIALS",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_14(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getorigintrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_15(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_16(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_17(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "Params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_18(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = None
    return [OriginTrial.from_json(i) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_19(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(None) for i in json["originTrials"]]


def x_get_origin_trials__mutmut_20(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["XXoriginTrialsXX"]]


def x_get_origin_trials__mutmut_21(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["origintrials"]]


def x_get_origin_trials__mutmut_22(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["ORIGINTRIALS"]]


def x_get_origin_trials__mutmut_23(
    frame_id: FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[OriginTrial]]:
    """
    Get Origin Trials on given frame.

    **EXPERIMENTAL**

    :param frame_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.getOriginTrials",
        "params": params,
    }
    json = yield cmd_dict
    return [OriginTrial.from_json(i) for i in json["Origintrials"]]

x_get_origin_trials__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_origin_trials__mutmut_1': x_get_origin_trials__mutmut_1, 
    'x_get_origin_trials__mutmut_2': x_get_origin_trials__mutmut_2, 
    'x_get_origin_trials__mutmut_3': x_get_origin_trials__mutmut_3, 
    'x_get_origin_trials__mutmut_4': x_get_origin_trials__mutmut_4, 
    'x_get_origin_trials__mutmut_5': x_get_origin_trials__mutmut_5, 
    'x_get_origin_trials__mutmut_6': x_get_origin_trials__mutmut_6, 
    'x_get_origin_trials__mutmut_7': x_get_origin_trials__mutmut_7, 
    'x_get_origin_trials__mutmut_8': x_get_origin_trials__mutmut_8, 
    'x_get_origin_trials__mutmut_9': x_get_origin_trials__mutmut_9, 
    'x_get_origin_trials__mutmut_10': x_get_origin_trials__mutmut_10, 
    'x_get_origin_trials__mutmut_11': x_get_origin_trials__mutmut_11, 
    'x_get_origin_trials__mutmut_12': x_get_origin_trials__mutmut_12, 
    'x_get_origin_trials__mutmut_13': x_get_origin_trials__mutmut_13, 
    'x_get_origin_trials__mutmut_14': x_get_origin_trials__mutmut_14, 
    'x_get_origin_trials__mutmut_15': x_get_origin_trials__mutmut_15, 
    'x_get_origin_trials__mutmut_16': x_get_origin_trials__mutmut_16, 
    'x_get_origin_trials__mutmut_17': x_get_origin_trials__mutmut_17, 
    'x_get_origin_trials__mutmut_18': x_get_origin_trials__mutmut_18, 
    'x_get_origin_trials__mutmut_19': x_get_origin_trials__mutmut_19, 
    'x_get_origin_trials__mutmut_20': x_get_origin_trials__mutmut_20, 
    'x_get_origin_trials__mutmut_21': x_get_origin_trials__mutmut_21, 
    'x_get_origin_trials__mutmut_22': x_get_origin_trials__mutmut_22, 
    'x_get_origin_trials__mutmut_23': x_get_origin_trials__mutmut_23
}

def get_origin_trials(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_origin_trials__mutmut_orig, x_get_origin_trials__mutmut_mutants, args, kwargs)
    return result 

get_origin_trials.__signature__ = _mutmut_signature(x_get_origin_trials__mutmut_orig)
x_get_origin_trials__mutmut_orig.__name__ = 'x_get_origin_trials'


def x_set_device_metrics_override__mutmut_orig(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_1(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = None
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_2(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = None
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_3(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["XXwidthXX"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_4(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["WIDTH"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_5(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["Width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_6(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = None
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_7(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["XXheightXX"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_8(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["HEIGHT"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_9(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["Height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_10(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = None
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_11(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["XXdeviceScaleFactorXX"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_12(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["devicescalefactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_13(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["DEVICESCALEFACTOR"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_14(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["Devicescalefactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_15(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = None
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_16(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["XXmobileXX"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_17(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["MOBILE"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_18(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["Mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_19(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_20(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = None
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_21(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["XXscaleXX"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_22(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["SCALE"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_23(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["Scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_24(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_25(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = None
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_26(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["XXscreenWidthXX"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_27(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenwidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_28(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["SCREENWIDTH"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_29(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["Screenwidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_30(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_31(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = None
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_32(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["XXscreenHeightXX"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_33(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenheight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_34(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["SCREENHEIGHT"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_35(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["Screenheight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_36(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_37(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = None
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_38(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["XXpositionXXX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_39(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionx"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_40(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["POSITIONX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_41(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["Positionx"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_42(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_43(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = None
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_44(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["XXpositionYXX"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_45(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positiony"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_46(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["POSITIONY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_47(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["Positiony"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_48(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_49(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = None
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_50(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["XXdontSetVisibleSizeXX"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_51(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontsetvisiblesize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_52(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["DONTSETVISIBLESIZE"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_53(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["Dontsetvisiblesize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_54(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_55(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = None
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_56(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["XXscreenOrientationXX"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_57(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenorientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_58(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["SCREENORIENTATION"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_59(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["Screenorientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_60(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_61(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_62(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["XXviewportXX"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_63(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["VIEWPORT"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_64(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["Viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_65(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_device_metrics_override__mutmut_66(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_67(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_68(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setDeviceMetricsOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_69(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setDeviceMetricsOverrideXX",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_70(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "page.setdevicemetricsoverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_71(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETDEVICEMETRICSOVERRIDE",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_72(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setdevicemetricsoverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_73(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_74(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_device_metrics_override__mutmut_75(
    width: int,
    height: int,
    device_scale_factor: float,
    mobile: bool,
    scale: float | None = None,
    screen_width: int | None = None,
    screen_height: int | None = None,
    position_x: int | None = None,
    position_y: int | None = None,
    dont_set_visible_size: bool | None = None,
    screen_orientation: emulation.ScreenOrientation | None = None,
    viewport: Viewport | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
    window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
    query results).

    **EXPERIMENTAL**

    :param width: Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param height: Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
    :param device_scale_factor: Overriding device scale factor value. 0 disables the override.
    :param mobile: Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
    :param scale: *(Optional)* Scale to apply to resulting view image.
    :param screen_width: *(Optional)* Overriding screen width value in pixels (minimum 0, maximum 10000000).
    :param screen_height: *(Optional)* Overriding screen height value in pixels (minimum 0, maximum 10000000).
    :param position_x: *(Optional)* Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
    :param position_y: *(Optional)* Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
    :param dont_set_visible_size: *(Optional)* Do not set visible view size, rely upon explicit setVisibleSize call.
    :param screen_orientation: *(Optional)* Screen orientation override.
    :param viewport: *(Optional)* The viewport dimensions and scale. If not set, the override is cleared.
    """
    params: T_JSON_DICT = {}
    params["width"] = width
    params["height"] = height
    params["deviceScaleFactor"] = device_scale_factor
    params["mobile"] = mobile
    if scale is not None:
        params["scale"] = scale
    if screen_width is not None:
        params["screenWidth"] = screen_width
    if screen_height is not None:
        params["screenHeight"] = screen_height
    if position_x is not None:
        params["positionX"] = position_x
    if position_y is not None:
        params["positionY"] = position_y
    if dont_set_visible_size is not None:
        params["dontSetVisibleSize"] = dont_set_visible_size
    if screen_orientation is not None:
        params["screenOrientation"] = screen_orientation.to_json()
    if viewport is not None:
        params["viewport"] = viewport.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceMetricsOverride",
        "Params": params,
    }
    yield cmd_dict

x_set_device_metrics_override__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_device_metrics_override__mutmut_1': x_set_device_metrics_override__mutmut_1, 
    'x_set_device_metrics_override__mutmut_2': x_set_device_metrics_override__mutmut_2, 
    'x_set_device_metrics_override__mutmut_3': x_set_device_metrics_override__mutmut_3, 
    'x_set_device_metrics_override__mutmut_4': x_set_device_metrics_override__mutmut_4, 
    'x_set_device_metrics_override__mutmut_5': x_set_device_metrics_override__mutmut_5, 
    'x_set_device_metrics_override__mutmut_6': x_set_device_metrics_override__mutmut_6, 
    'x_set_device_metrics_override__mutmut_7': x_set_device_metrics_override__mutmut_7, 
    'x_set_device_metrics_override__mutmut_8': x_set_device_metrics_override__mutmut_8, 
    'x_set_device_metrics_override__mutmut_9': x_set_device_metrics_override__mutmut_9, 
    'x_set_device_metrics_override__mutmut_10': x_set_device_metrics_override__mutmut_10, 
    'x_set_device_metrics_override__mutmut_11': x_set_device_metrics_override__mutmut_11, 
    'x_set_device_metrics_override__mutmut_12': x_set_device_metrics_override__mutmut_12, 
    'x_set_device_metrics_override__mutmut_13': x_set_device_metrics_override__mutmut_13, 
    'x_set_device_metrics_override__mutmut_14': x_set_device_metrics_override__mutmut_14, 
    'x_set_device_metrics_override__mutmut_15': x_set_device_metrics_override__mutmut_15, 
    'x_set_device_metrics_override__mutmut_16': x_set_device_metrics_override__mutmut_16, 
    'x_set_device_metrics_override__mutmut_17': x_set_device_metrics_override__mutmut_17, 
    'x_set_device_metrics_override__mutmut_18': x_set_device_metrics_override__mutmut_18, 
    'x_set_device_metrics_override__mutmut_19': x_set_device_metrics_override__mutmut_19, 
    'x_set_device_metrics_override__mutmut_20': x_set_device_metrics_override__mutmut_20, 
    'x_set_device_metrics_override__mutmut_21': x_set_device_metrics_override__mutmut_21, 
    'x_set_device_metrics_override__mutmut_22': x_set_device_metrics_override__mutmut_22, 
    'x_set_device_metrics_override__mutmut_23': x_set_device_metrics_override__mutmut_23, 
    'x_set_device_metrics_override__mutmut_24': x_set_device_metrics_override__mutmut_24, 
    'x_set_device_metrics_override__mutmut_25': x_set_device_metrics_override__mutmut_25, 
    'x_set_device_metrics_override__mutmut_26': x_set_device_metrics_override__mutmut_26, 
    'x_set_device_metrics_override__mutmut_27': x_set_device_metrics_override__mutmut_27, 
    'x_set_device_metrics_override__mutmut_28': x_set_device_metrics_override__mutmut_28, 
    'x_set_device_metrics_override__mutmut_29': x_set_device_metrics_override__mutmut_29, 
    'x_set_device_metrics_override__mutmut_30': x_set_device_metrics_override__mutmut_30, 
    'x_set_device_metrics_override__mutmut_31': x_set_device_metrics_override__mutmut_31, 
    'x_set_device_metrics_override__mutmut_32': x_set_device_metrics_override__mutmut_32, 
    'x_set_device_metrics_override__mutmut_33': x_set_device_metrics_override__mutmut_33, 
    'x_set_device_metrics_override__mutmut_34': x_set_device_metrics_override__mutmut_34, 
    'x_set_device_metrics_override__mutmut_35': x_set_device_metrics_override__mutmut_35, 
    'x_set_device_metrics_override__mutmut_36': x_set_device_metrics_override__mutmut_36, 
    'x_set_device_metrics_override__mutmut_37': x_set_device_metrics_override__mutmut_37, 
    'x_set_device_metrics_override__mutmut_38': x_set_device_metrics_override__mutmut_38, 
    'x_set_device_metrics_override__mutmut_39': x_set_device_metrics_override__mutmut_39, 
    'x_set_device_metrics_override__mutmut_40': x_set_device_metrics_override__mutmut_40, 
    'x_set_device_metrics_override__mutmut_41': x_set_device_metrics_override__mutmut_41, 
    'x_set_device_metrics_override__mutmut_42': x_set_device_metrics_override__mutmut_42, 
    'x_set_device_metrics_override__mutmut_43': x_set_device_metrics_override__mutmut_43, 
    'x_set_device_metrics_override__mutmut_44': x_set_device_metrics_override__mutmut_44, 
    'x_set_device_metrics_override__mutmut_45': x_set_device_metrics_override__mutmut_45, 
    'x_set_device_metrics_override__mutmut_46': x_set_device_metrics_override__mutmut_46, 
    'x_set_device_metrics_override__mutmut_47': x_set_device_metrics_override__mutmut_47, 
    'x_set_device_metrics_override__mutmut_48': x_set_device_metrics_override__mutmut_48, 
    'x_set_device_metrics_override__mutmut_49': x_set_device_metrics_override__mutmut_49, 
    'x_set_device_metrics_override__mutmut_50': x_set_device_metrics_override__mutmut_50, 
    'x_set_device_metrics_override__mutmut_51': x_set_device_metrics_override__mutmut_51, 
    'x_set_device_metrics_override__mutmut_52': x_set_device_metrics_override__mutmut_52, 
    'x_set_device_metrics_override__mutmut_53': x_set_device_metrics_override__mutmut_53, 
    'x_set_device_metrics_override__mutmut_54': x_set_device_metrics_override__mutmut_54, 
    'x_set_device_metrics_override__mutmut_55': x_set_device_metrics_override__mutmut_55, 
    'x_set_device_metrics_override__mutmut_56': x_set_device_metrics_override__mutmut_56, 
    'x_set_device_metrics_override__mutmut_57': x_set_device_metrics_override__mutmut_57, 
    'x_set_device_metrics_override__mutmut_58': x_set_device_metrics_override__mutmut_58, 
    'x_set_device_metrics_override__mutmut_59': x_set_device_metrics_override__mutmut_59, 
    'x_set_device_metrics_override__mutmut_60': x_set_device_metrics_override__mutmut_60, 
    'x_set_device_metrics_override__mutmut_61': x_set_device_metrics_override__mutmut_61, 
    'x_set_device_metrics_override__mutmut_62': x_set_device_metrics_override__mutmut_62, 
    'x_set_device_metrics_override__mutmut_63': x_set_device_metrics_override__mutmut_63, 
    'x_set_device_metrics_override__mutmut_64': x_set_device_metrics_override__mutmut_64, 
    'x_set_device_metrics_override__mutmut_65': x_set_device_metrics_override__mutmut_65, 
    'x_set_device_metrics_override__mutmut_66': x_set_device_metrics_override__mutmut_66, 
    'x_set_device_metrics_override__mutmut_67': x_set_device_metrics_override__mutmut_67, 
    'x_set_device_metrics_override__mutmut_68': x_set_device_metrics_override__mutmut_68, 
    'x_set_device_metrics_override__mutmut_69': x_set_device_metrics_override__mutmut_69, 
    'x_set_device_metrics_override__mutmut_70': x_set_device_metrics_override__mutmut_70, 
    'x_set_device_metrics_override__mutmut_71': x_set_device_metrics_override__mutmut_71, 
    'x_set_device_metrics_override__mutmut_72': x_set_device_metrics_override__mutmut_72, 
    'x_set_device_metrics_override__mutmut_73': x_set_device_metrics_override__mutmut_73, 
    'x_set_device_metrics_override__mutmut_74': x_set_device_metrics_override__mutmut_74, 
    'x_set_device_metrics_override__mutmut_75': x_set_device_metrics_override__mutmut_75
}

def set_device_metrics_override(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_device_metrics_override__mutmut_orig, x_set_device_metrics_override__mutmut_mutants, args, kwargs)
    return result 

set_device_metrics_override.__signature__ = _mutmut_signature(x_set_device_metrics_override__mutmut_orig)
x_set_device_metrics_override__mutmut_orig.__name__ = 'x_set_device_metrics_override'


def x_set_device_orientation_override__mutmut_orig(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_1(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = None
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_2(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = None
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_3(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["XXalphaXX"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_4(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["ALPHA"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_5(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["Alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_6(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = None
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_7(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["XXbetaXX"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_8(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["BETA"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_9(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["Beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_10(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_11(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["XXgammaXX"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_12(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["GAMMA"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_13(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["Gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_14(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_device_orientation_override__mutmut_15(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_16(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_17(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setDeviceOrientationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_18(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setDeviceOrientationOverrideXX",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_19(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "page.setdeviceorientationoverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_20(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETDEVICEORIENTATIONOVERRIDE",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_21(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setdeviceorientationoverride",
        "params": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_22(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_23(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_device_orientation_override__mutmut_24(
    alpha: float,
    beta: float,
    gamma: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Device Orientation.

    **EXPERIMENTAL**

    :param alpha: Mock alpha
    :param beta: Mock beta
    :param gamma: Mock gamma
    """
    params: T_JSON_DICT = {}
    params["alpha"] = alpha
    params["beta"] = beta
    params["gamma"] = gamma
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDeviceOrientationOverride",
        "Params": params,
    }
    yield cmd_dict

x_set_device_orientation_override__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_device_orientation_override__mutmut_1': x_set_device_orientation_override__mutmut_1, 
    'x_set_device_orientation_override__mutmut_2': x_set_device_orientation_override__mutmut_2, 
    'x_set_device_orientation_override__mutmut_3': x_set_device_orientation_override__mutmut_3, 
    'x_set_device_orientation_override__mutmut_4': x_set_device_orientation_override__mutmut_4, 
    'x_set_device_orientation_override__mutmut_5': x_set_device_orientation_override__mutmut_5, 
    'x_set_device_orientation_override__mutmut_6': x_set_device_orientation_override__mutmut_6, 
    'x_set_device_orientation_override__mutmut_7': x_set_device_orientation_override__mutmut_7, 
    'x_set_device_orientation_override__mutmut_8': x_set_device_orientation_override__mutmut_8, 
    'x_set_device_orientation_override__mutmut_9': x_set_device_orientation_override__mutmut_9, 
    'x_set_device_orientation_override__mutmut_10': x_set_device_orientation_override__mutmut_10, 
    'x_set_device_orientation_override__mutmut_11': x_set_device_orientation_override__mutmut_11, 
    'x_set_device_orientation_override__mutmut_12': x_set_device_orientation_override__mutmut_12, 
    'x_set_device_orientation_override__mutmut_13': x_set_device_orientation_override__mutmut_13, 
    'x_set_device_orientation_override__mutmut_14': x_set_device_orientation_override__mutmut_14, 
    'x_set_device_orientation_override__mutmut_15': x_set_device_orientation_override__mutmut_15, 
    'x_set_device_orientation_override__mutmut_16': x_set_device_orientation_override__mutmut_16, 
    'x_set_device_orientation_override__mutmut_17': x_set_device_orientation_override__mutmut_17, 
    'x_set_device_orientation_override__mutmut_18': x_set_device_orientation_override__mutmut_18, 
    'x_set_device_orientation_override__mutmut_19': x_set_device_orientation_override__mutmut_19, 
    'x_set_device_orientation_override__mutmut_20': x_set_device_orientation_override__mutmut_20, 
    'x_set_device_orientation_override__mutmut_21': x_set_device_orientation_override__mutmut_21, 
    'x_set_device_orientation_override__mutmut_22': x_set_device_orientation_override__mutmut_22, 
    'x_set_device_orientation_override__mutmut_23': x_set_device_orientation_override__mutmut_23, 
    'x_set_device_orientation_override__mutmut_24': x_set_device_orientation_override__mutmut_24
}

def set_device_orientation_override(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_device_orientation_override__mutmut_orig, x_set_device_orientation_override__mutmut_mutants, args, kwargs)
    return result 

set_device_orientation_override.__signature__ = _mutmut_signature(x_set_device_orientation_override__mutmut_orig)
x_set_device_orientation_override__mutmut_orig.__name__ = 'x_set_device_orientation_override'


def x_set_font_families__mutmut_orig(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_1(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = None
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_2(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = None
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_3(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["XXfontFamiliesXX"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_4(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontfamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_5(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["FONTFAMILIES"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_6(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["Fontfamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_7(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_8(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_9(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["XXforScriptsXX"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_10(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forscripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_11(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["FORSCRIPTS"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_12(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["Forscripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_13(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_font_families__mutmut_14(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_15(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_16(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setFontFamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_17(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setFontFamiliesXX",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_18(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "page.setfontfamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_19(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETFONTFAMILIES",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_20(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setfontfamilies",
        "params": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_21(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_22(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_font_families__mutmut_23(
    font_families: FontFamilies,
    for_scripts: list[ScriptFontFamilies] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set generic font families.

    **EXPERIMENTAL**

    :param font_families: Specifies font families to set. If a font family is not specified, it won't be changed.
    :param for_scripts: *(Optional)* Specifies font families to set for individual scripts.
    """
    params: T_JSON_DICT = {}
    params["fontFamilies"] = font_families.to_json()
    if for_scripts is not None:
        params["forScripts"] = [i.to_json() for i in for_scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontFamilies",
        "Params": params,
    }
    yield cmd_dict

x_set_font_families__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_font_families__mutmut_1': x_set_font_families__mutmut_1, 
    'x_set_font_families__mutmut_2': x_set_font_families__mutmut_2, 
    'x_set_font_families__mutmut_3': x_set_font_families__mutmut_3, 
    'x_set_font_families__mutmut_4': x_set_font_families__mutmut_4, 
    'x_set_font_families__mutmut_5': x_set_font_families__mutmut_5, 
    'x_set_font_families__mutmut_6': x_set_font_families__mutmut_6, 
    'x_set_font_families__mutmut_7': x_set_font_families__mutmut_7, 
    'x_set_font_families__mutmut_8': x_set_font_families__mutmut_8, 
    'x_set_font_families__mutmut_9': x_set_font_families__mutmut_9, 
    'x_set_font_families__mutmut_10': x_set_font_families__mutmut_10, 
    'x_set_font_families__mutmut_11': x_set_font_families__mutmut_11, 
    'x_set_font_families__mutmut_12': x_set_font_families__mutmut_12, 
    'x_set_font_families__mutmut_13': x_set_font_families__mutmut_13, 
    'x_set_font_families__mutmut_14': x_set_font_families__mutmut_14, 
    'x_set_font_families__mutmut_15': x_set_font_families__mutmut_15, 
    'x_set_font_families__mutmut_16': x_set_font_families__mutmut_16, 
    'x_set_font_families__mutmut_17': x_set_font_families__mutmut_17, 
    'x_set_font_families__mutmut_18': x_set_font_families__mutmut_18, 
    'x_set_font_families__mutmut_19': x_set_font_families__mutmut_19, 
    'x_set_font_families__mutmut_20': x_set_font_families__mutmut_20, 
    'x_set_font_families__mutmut_21': x_set_font_families__mutmut_21, 
    'x_set_font_families__mutmut_22': x_set_font_families__mutmut_22, 
    'x_set_font_families__mutmut_23': x_set_font_families__mutmut_23
}

def set_font_families(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_font_families__mutmut_orig, x_set_font_families__mutmut_mutants, args, kwargs)
    return result 

set_font_families.__signature__ = _mutmut_signature(x_set_font_families__mutmut_orig)
x_set_font_families__mutmut_orig.__name__ = 'x_set_font_families'


def x_set_font_sizes__mutmut_orig(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontSizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_1(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = None
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontSizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_2(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontSizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_3(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["XXfontSizesXX"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontSizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_4(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontsizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontSizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_5(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["FONTSIZES"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontSizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_6(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["Fontsizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontSizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_7(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_font_sizes__mutmut_8(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setFontSizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_9(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setFontSizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_10(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setFontSizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_11(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setFontSizesXX",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_12(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "page.setfontsizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_13(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETFONTSIZES",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_14(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setfontsizes",
        "params": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_15(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontSizes",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_16(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontSizes",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_font_sizes__mutmut_17(
    font_sizes: FontSizes,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set default font sizes.

    **EXPERIMENTAL**

    :param font_sizes: Specifies font sizes to set. If a font size is not specified, it won't be changed.
    """
    params: T_JSON_DICT = {}
    params["fontSizes"] = font_sizes.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setFontSizes",
        "Params": params,
    }
    yield cmd_dict

x_set_font_sizes__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_font_sizes__mutmut_1': x_set_font_sizes__mutmut_1, 
    'x_set_font_sizes__mutmut_2': x_set_font_sizes__mutmut_2, 
    'x_set_font_sizes__mutmut_3': x_set_font_sizes__mutmut_3, 
    'x_set_font_sizes__mutmut_4': x_set_font_sizes__mutmut_4, 
    'x_set_font_sizes__mutmut_5': x_set_font_sizes__mutmut_5, 
    'x_set_font_sizes__mutmut_6': x_set_font_sizes__mutmut_6, 
    'x_set_font_sizes__mutmut_7': x_set_font_sizes__mutmut_7, 
    'x_set_font_sizes__mutmut_8': x_set_font_sizes__mutmut_8, 
    'x_set_font_sizes__mutmut_9': x_set_font_sizes__mutmut_9, 
    'x_set_font_sizes__mutmut_10': x_set_font_sizes__mutmut_10, 
    'x_set_font_sizes__mutmut_11': x_set_font_sizes__mutmut_11, 
    'x_set_font_sizes__mutmut_12': x_set_font_sizes__mutmut_12, 
    'x_set_font_sizes__mutmut_13': x_set_font_sizes__mutmut_13, 
    'x_set_font_sizes__mutmut_14': x_set_font_sizes__mutmut_14, 
    'x_set_font_sizes__mutmut_15': x_set_font_sizes__mutmut_15, 
    'x_set_font_sizes__mutmut_16': x_set_font_sizes__mutmut_16, 
    'x_set_font_sizes__mutmut_17': x_set_font_sizes__mutmut_17
}

def set_font_sizes(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_font_sizes__mutmut_orig, x_set_font_sizes__mutmut_mutants, args, kwargs)
    return result 

set_font_sizes.__signature__ = _mutmut_signature(x_set_font_sizes__mutmut_orig)
x_set_font_sizes__mutmut_orig.__name__ = 'x_set_font_sizes'


def x_set_document_content__mutmut_orig(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_1(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = None
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_2(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = None
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_3(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["XXframeIdXX"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_4(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameid"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_5(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["FRAMEID"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_6(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["Frameid"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_7(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_8(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["XXhtmlXX"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_9(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["HTML"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_10(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["Html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_11(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_document_content__mutmut_12(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_13(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_14(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setDocumentContent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_15(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setDocumentContentXX",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_16(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "page.setdocumentcontent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_17(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETDOCUMENTCONTENT",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_18(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setdocumentcontent",
        "params": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_19(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_20(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_document_content__mutmut_21(
    frame_id: FrameId,
    html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets given markup as the document's HTML.

    :param frame_id: Frame id to set HTML for.
    :param html: HTML content to set.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    params["html"] = html
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDocumentContent",
        "Params": params,
    }
    yield cmd_dict

x_set_document_content__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_document_content__mutmut_1': x_set_document_content__mutmut_1, 
    'x_set_document_content__mutmut_2': x_set_document_content__mutmut_2, 
    'x_set_document_content__mutmut_3': x_set_document_content__mutmut_3, 
    'x_set_document_content__mutmut_4': x_set_document_content__mutmut_4, 
    'x_set_document_content__mutmut_5': x_set_document_content__mutmut_5, 
    'x_set_document_content__mutmut_6': x_set_document_content__mutmut_6, 
    'x_set_document_content__mutmut_7': x_set_document_content__mutmut_7, 
    'x_set_document_content__mutmut_8': x_set_document_content__mutmut_8, 
    'x_set_document_content__mutmut_9': x_set_document_content__mutmut_9, 
    'x_set_document_content__mutmut_10': x_set_document_content__mutmut_10, 
    'x_set_document_content__mutmut_11': x_set_document_content__mutmut_11, 
    'x_set_document_content__mutmut_12': x_set_document_content__mutmut_12, 
    'x_set_document_content__mutmut_13': x_set_document_content__mutmut_13, 
    'x_set_document_content__mutmut_14': x_set_document_content__mutmut_14, 
    'x_set_document_content__mutmut_15': x_set_document_content__mutmut_15, 
    'x_set_document_content__mutmut_16': x_set_document_content__mutmut_16, 
    'x_set_document_content__mutmut_17': x_set_document_content__mutmut_17, 
    'x_set_document_content__mutmut_18': x_set_document_content__mutmut_18, 
    'x_set_document_content__mutmut_19': x_set_document_content__mutmut_19, 
    'x_set_document_content__mutmut_20': x_set_document_content__mutmut_20, 
    'x_set_document_content__mutmut_21': x_set_document_content__mutmut_21
}

def set_document_content(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_document_content__mutmut_orig, x_set_document_content__mutmut_mutants, args, kwargs)
    return result 

set_document_content.__signature__ = _mutmut_signature(x_set_document_content__mutmut_orig)
x_set_document_content__mutmut_orig.__name__ = 'x_set_document_content'


def x_set_download_behavior__mutmut_orig(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_1(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = None
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_2(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = None
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_3(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["XXbehaviorXX"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_4(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["BEHAVIOR"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_5(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["Behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_6(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_7(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_8(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["XXdownloadPathXX"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_9(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadpath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_10(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["DOWNLOADPATH"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_11(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["Downloadpath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_12(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_download_behavior__mutmut_13(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_14(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_15(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setDownloadBehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_16(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setDownloadBehaviorXX",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_17(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "page.setdownloadbehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_18(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETDOWNLOADBEHAVIOR",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_19(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setdownloadbehavior",
        "params": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_20(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_21(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_download_behavior__mutmut_22(
    behavior: str,
    download_path: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Set the behavior when downloading a file.

    **EXPERIMENTAL**

    :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
    :param download_path: *(Optional)* The default path to save downloaded files to. This is required if behavior is set to 'allow'
    """
    params: T_JSON_DICT = {}
    params["behavior"] = behavior
    if download_path is not None:
        params["downloadPath"] = download_path
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setDownloadBehavior",
        "Params": params,
    }
    yield cmd_dict

x_set_download_behavior__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_download_behavior__mutmut_1': x_set_download_behavior__mutmut_1, 
    'x_set_download_behavior__mutmut_2': x_set_download_behavior__mutmut_2, 
    'x_set_download_behavior__mutmut_3': x_set_download_behavior__mutmut_3, 
    'x_set_download_behavior__mutmut_4': x_set_download_behavior__mutmut_4, 
    'x_set_download_behavior__mutmut_5': x_set_download_behavior__mutmut_5, 
    'x_set_download_behavior__mutmut_6': x_set_download_behavior__mutmut_6, 
    'x_set_download_behavior__mutmut_7': x_set_download_behavior__mutmut_7, 
    'x_set_download_behavior__mutmut_8': x_set_download_behavior__mutmut_8, 
    'x_set_download_behavior__mutmut_9': x_set_download_behavior__mutmut_9, 
    'x_set_download_behavior__mutmut_10': x_set_download_behavior__mutmut_10, 
    'x_set_download_behavior__mutmut_11': x_set_download_behavior__mutmut_11, 
    'x_set_download_behavior__mutmut_12': x_set_download_behavior__mutmut_12, 
    'x_set_download_behavior__mutmut_13': x_set_download_behavior__mutmut_13, 
    'x_set_download_behavior__mutmut_14': x_set_download_behavior__mutmut_14, 
    'x_set_download_behavior__mutmut_15': x_set_download_behavior__mutmut_15, 
    'x_set_download_behavior__mutmut_16': x_set_download_behavior__mutmut_16, 
    'x_set_download_behavior__mutmut_17': x_set_download_behavior__mutmut_17, 
    'x_set_download_behavior__mutmut_18': x_set_download_behavior__mutmut_18, 
    'x_set_download_behavior__mutmut_19': x_set_download_behavior__mutmut_19, 
    'x_set_download_behavior__mutmut_20': x_set_download_behavior__mutmut_20, 
    'x_set_download_behavior__mutmut_21': x_set_download_behavior__mutmut_21, 
    'x_set_download_behavior__mutmut_22': x_set_download_behavior__mutmut_22
}

def set_download_behavior(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_download_behavior__mutmut_orig, x_set_download_behavior__mutmut_mutants, args, kwargs)
    return result 

set_download_behavior.__signature__ = _mutmut_signature(x_set_download_behavior__mutmut_orig)
x_set_download_behavior__mutmut_orig.__name__ = 'x_set_download_behavior'


def x_set_geolocation_override__mutmut_orig(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_1(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = None
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_2(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_3(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = None
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_4(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["XXlatitudeXX"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_5(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["LATITUDE"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_6(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["Latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_7(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_8(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = None
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_9(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["XXlongitudeXX"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_10(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["LONGITUDE"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_11(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["Longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_12(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_13(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_14(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["XXaccuracyXX"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_15(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["ACCURACY"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_16(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["Accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_17(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_geolocation_override__mutmut_18(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_19(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_20(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setGeolocationOverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_21(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setGeolocationOverrideXX",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_22(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "page.setgeolocationoverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_23(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETGEOLOCATIONOVERRIDE",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_24(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setgeolocationoverride",
        "params": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_25(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_26(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_geolocation_override__mutmut_27(
    latitude: float | None = None,
    longitude: float | None = None,
    accuracy: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
    unavailable.

    :param latitude: *(Optional)* Mock latitude
    :param longitude: *(Optional)* Mock longitude
    :param accuracy: *(Optional)* Mock accuracy
    """
    params: T_JSON_DICT = {}
    if latitude is not None:
        params["latitude"] = latitude
    if longitude is not None:
        params["longitude"] = longitude
    if accuracy is not None:
        params["accuracy"] = accuracy
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setGeolocationOverride",
        "Params": params,
    }
    yield cmd_dict

x_set_geolocation_override__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_geolocation_override__mutmut_1': x_set_geolocation_override__mutmut_1, 
    'x_set_geolocation_override__mutmut_2': x_set_geolocation_override__mutmut_2, 
    'x_set_geolocation_override__mutmut_3': x_set_geolocation_override__mutmut_3, 
    'x_set_geolocation_override__mutmut_4': x_set_geolocation_override__mutmut_4, 
    'x_set_geolocation_override__mutmut_5': x_set_geolocation_override__mutmut_5, 
    'x_set_geolocation_override__mutmut_6': x_set_geolocation_override__mutmut_6, 
    'x_set_geolocation_override__mutmut_7': x_set_geolocation_override__mutmut_7, 
    'x_set_geolocation_override__mutmut_8': x_set_geolocation_override__mutmut_8, 
    'x_set_geolocation_override__mutmut_9': x_set_geolocation_override__mutmut_9, 
    'x_set_geolocation_override__mutmut_10': x_set_geolocation_override__mutmut_10, 
    'x_set_geolocation_override__mutmut_11': x_set_geolocation_override__mutmut_11, 
    'x_set_geolocation_override__mutmut_12': x_set_geolocation_override__mutmut_12, 
    'x_set_geolocation_override__mutmut_13': x_set_geolocation_override__mutmut_13, 
    'x_set_geolocation_override__mutmut_14': x_set_geolocation_override__mutmut_14, 
    'x_set_geolocation_override__mutmut_15': x_set_geolocation_override__mutmut_15, 
    'x_set_geolocation_override__mutmut_16': x_set_geolocation_override__mutmut_16, 
    'x_set_geolocation_override__mutmut_17': x_set_geolocation_override__mutmut_17, 
    'x_set_geolocation_override__mutmut_18': x_set_geolocation_override__mutmut_18, 
    'x_set_geolocation_override__mutmut_19': x_set_geolocation_override__mutmut_19, 
    'x_set_geolocation_override__mutmut_20': x_set_geolocation_override__mutmut_20, 
    'x_set_geolocation_override__mutmut_21': x_set_geolocation_override__mutmut_21, 
    'x_set_geolocation_override__mutmut_22': x_set_geolocation_override__mutmut_22, 
    'x_set_geolocation_override__mutmut_23': x_set_geolocation_override__mutmut_23, 
    'x_set_geolocation_override__mutmut_24': x_set_geolocation_override__mutmut_24, 
    'x_set_geolocation_override__mutmut_25': x_set_geolocation_override__mutmut_25, 
    'x_set_geolocation_override__mutmut_26': x_set_geolocation_override__mutmut_26, 
    'x_set_geolocation_override__mutmut_27': x_set_geolocation_override__mutmut_27
}

def set_geolocation_override(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_geolocation_override__mutmut_orig, x_set_geolocation_override__mutmut_mutants, args, kwargs)
    return result 

set_geolocation_override.__signature__ = _mutmut_signature(x_set_geolocation_override__mutmut_orig)
x_set_geolocation_override__mutmut_orig.__name__ = 'x_set_geolocation_override'


def x_set_lifecycle_events_enabled__mutmut_orig(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setLifecycleEventsEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_1(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = None
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setLifecycleEventsEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_2(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setLifecycleEventsEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_3(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["XXenabledXX"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setLifecycleEventsEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_4(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["ENABLED"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setLifecycleEventsEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_5(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["Enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setLifecycleEventsEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_6(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_7(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setLifecycleEventsEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_8(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setLifecycleEventsEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_9(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setLifecycleEventsEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_10(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setLifecycleEventsEnabledXX",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_11(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "page.setlifecycleeventsenabled",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_12(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETLIFECYCLEEVENTSENABLED",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_13(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setlifecycleeventsenabled",
        "params": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_14(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setLifecycleEventsEnabled",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_15(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setLifecycleEventsEnabled",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_lifecycle_events_enabled__mutmut_16(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Controls whether page will emit lifecycle events.

    :param enabled: If true, starts emitting lifecycle events.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setLifecycleEventsEnabled",
        "Params": params,
    }
    yield cmd_dict

x_set_lifecycle_events_enabled__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_lifecycle_events_enabled__mutmut_1': x_set_lifecycle_events_enabled__mutmut_1, 
    'x_set_lifecycle_events_enabled__mutmut_2': x_set_lifecycle_events_enabled__mutmut_2, 
    'x_set_lifecycle_events_enabled__mutmut_3': x_set_lifecycle_events_enabled__mutmut_3, 
    'x_set_lifecycle_events_enabled__mutmut_4': x_set_lifecycle_events_enabled__mutmut_4, 
    'x_set_lifecycle_events_enabled__mutmut_5': x_set_lifecycle_events_enabled__mutmut_5, 
    'x_set_lifecycle_events_enabled__mutmut_6': x_set_lifecycle_events_enabled__mutmut_6, 
    'x_set_lifecycle_events_enabled__mutmut_7': x_set_lifecycle_events_enabled__mutmut_7, 
    'x_set_lifecycle_events_enabled__mutmut_8': x_set_lifecycle_events_enabled__mutmut_8, 
    'x_set_lifecycle_events_enabled__mutmut_9': x_set_lifecycle_events_enabled__mutmut_9, 
    'x_set_lifecycle_events_enabled__mutmut_10': x_set_lifecycle_events_enabled__mutmut_10, 
    'x_set_lifecycle_events_enabled__mutmut_11': x_set_lifecycle_events_enabled__mutmut_11, 
    'x_set_lifecycle_events_enabled__mutmut_12': x_set_lifecycle_events_enabled__mutmut_12, 
    'x_set_lifecycle_events_enabled__mutmut_13': x_set_lifecycle_events_enabled__mutmut_13, 
    'x_set_lifecycle_events_enabled__mutmut_14': x_set_lifecycle_events_enabled__mutmut_14, 
    'x_set_lifecycle_events_enabled__mutmut_15': x_set_lifecycle_events_enabled__mutmut_15, 
    'x_set_lifecycle_events_enabled__mutmut_16': x_set_lifecycle_events_enabled__mutmut_16
}

def set_lifecycle_events_enabled(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_lifecycle_events_enabled__mutmut_orig, x_set_lifecycle_events_enabled__mutmut_mutants, args, kwargs)
    return result 

set_lifecycle_events_enabled.__signature__ = _mutmut_signature(x_set_lifecycle_events_enabled__mutmut_orig)
x_set_lifecycle_events_enabled__mutmut_orig.__name__ = 'x_set_lifecycle_events_enabled'


def x_set_touch_emulation_enabled__mutmut_orig(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_1(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = None
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_2(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = None
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_3(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["XXenabledXX"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_4(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["ENABLED"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_5(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["Enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_6(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_7(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_8(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["XXconfigurationXX"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_9(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["CONFIGURATION"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_10(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["Configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_11(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_12(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_13(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_14(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setTouchEmulationEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_15(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setTouchEmulationEnabledXX",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_16(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "page.settouchemulationenabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_17(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETTOUCHEMULATIONENABLED",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_18(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.settouchemulationenabled",
        "params": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_19(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_20(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_touch_emulation_enabled__mutmut_21(
    enabled: bool,
    configuration: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Toggles mouse event-based touch event emulation.

    **EXPERIMENTAL**

    :param enabled: Whether the touch event emulation should be enabled.
    :param configuration: *(Optional)* Touch/gesture events configuration. Default: current platform.
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if configuration is not None:
        params["configuration"] = configuration
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setTouchEmulationEnabled",
        "Params": params,
    }
    yield cmd_dict

x_set_touch_emulation_enabled__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_touch_emulation_enabled__mutmut_1': x_set_touch_emulation_enabled__mutmut_1, 
    'x_set_touch_emulation_enabled__mutmut_2': x_set_touch_emulation_enabled__mutmut_2, 
    'x_set_touch_emulation_enabled__mutmut_3': x_set_touch_emulation_enabled__mutmut_3, 
    'x_set_touch_emulation_enabled__mutmut_4': x_set_touch_emulation_enabled__mutmut_4, 
    'x_set_touch_emulation_enabled__mutmut_5': x_set_touch_emulation_enabled__mutmut_5, 
    'x_set_touch_emulation_enabled__mutmut_6': x_set_touch_emulation_enabled__mutmut_6, 
    'x_set_touch_emulation_enabled__mutmut_7': x_set_touch_emulation_enabled__mutmut_7, 
    'x_set_touch_emulation_enabled__mutmut_8': x_set_touch_emulation_enabled__mutmut_8, 
    'x_set_touch_emulation_enabled__mutmut_9': x_set_touch_emulation_enabled__mutmut_9, 
    'x_set_touch_emulation_enabled__mutmut_10': x_set_touch_emulation_enabled__mutmut_10, 
    'x_set_touch_emulation_enabled__mutmut_11': x_set_touch_emulation_enabled__mutmut_11, 
    'x_set_touch_emulation_enabled__mutmut_12': x_set_touch_emulation_enabled__mutmut_12, 
    'x_set_touch_emulation_enabled__mutmut_13': x_set_touch_emulation_enabled__mutmut_13, 
    'x_set_touch_emulation_enabled__mutmut_14': x_set_touch_emulation_enabled__mutmut_14, 
    'x_set_touch_emulation_enabled__mutmut_15': x_set_touch_emulation_enabled__mutmut_15, 
    'x_set_touch_emulation_enabled__mutmut_16': x_set_touch_emulation_enabled__mutmut_16, 
    'x_set_touch_emulation_enabled__mutmut_17': x_set_touch_emulation_enabled__mutmut_17, 
    'x_set_touch_emulation_enabled__mutmut_18': x_set_touch_emulation_enabled__mutmut_18, 
    'x_set_touch_emulation_enabled__mutmut_19': x_set_touch_emulation_enabled__mutmut_19, 
    'x_set_touch_emulation_enabled__mutmut_20': x_set_touch_emulation_enabled__mutmut_20, 
    'x_set_touch_emulation_enabled__mutmut_21': x_set_touch_emulation_enabled__mutmut_21
}

def set_touch_emulation_enabled(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_touch_emulation_enabled__mutmut_orig, x_set_touch_emulation_enabled__mutmut_mutants, args, kwargs)
    return result 

set_touch_emulation_enabled.__signature__ = _mutmut_signature(x_set_touch_emulation_enabled__mutmut_orig)
x_set_touch_emulation_enabled__mutmut_orig.__name__ = 'x_set_touch_emulation_enabled'


def x_start_screencast__mutmut_orig(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_1(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = None
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_2(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_3(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = None
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_4(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["XXformatXX"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_5(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["FORMAT"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_6(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["Format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_7(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_8(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = None
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_9(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["XXqualityXX"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_10(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["QUALITY"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_11(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["Quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_12(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_13(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = None
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_14(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["XXmaxWidthXX"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_15(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxwidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_16(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["MAXWIDTH"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_17(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["Maxwidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_18(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_19(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = None
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_20(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["XXmaxHeightXX"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_21(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxheight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_22(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["MAXHEIGHT"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_23(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["Maxheight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_24(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_25(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_26(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["XXeveryNthFrameXX"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_27(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everynthframe"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_28(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["EVERYNTHFRAME"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_29(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["Everynthframe"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_30(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_start_screencast__mutmut_31(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_32(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_33(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.startScreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_34(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.startScreencastXX",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_35(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "page.startscreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_36(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.STARTSCREENCAST",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_37(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startscreencast",
        "params": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_38(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_39(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "PARAMS": params,
    }
    yield cmd_dict


def x_start_screencast__mutmut_40(
    format_: str | None = None,
    quality: int | None = None,
    max_width: int | None = None,
    max_height: int | None = None,
    every_nth_frame: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Starts sending each frame using the ``screencastFrame`` event.

    **EXPERIMENTAL**

    :param format_: *(Optional)* Image compression format.
    :param quality: *(Optional)* Compression quality from range [0..100].
    :param max_width: *(Optional)* Maximum screenshot width.
    :param max_height: *(Optional)* Maximum screenshot height.
    :param every_nth_frame: *(Optional)* Send every n-th frame.
    """
    params: T_JSON_DICT = {}
    if format_ is not None:
        params["format"] = format_
    if quality is not None:
        params["quality"] = quality
    if max_width is not None:
        params["maxWidth"] = max_width
    if max_height is not None:
        params["maxHeight"] = max_height
    if every_nth_frame is not None:
        params["everyNthFrame"] = every_nth_frame
    cmd_dict: T_JSON_DICT = {
        "method": "Page.startScreencast",
        "Params": params,
    }
    yield cmd_dict

x_start_screencast__mutmut_mutants : ClassVar[MutantDict] = {
'x_start_screencast__mutmut_1': x_start_screencast__mutmut_1, 
    'x_start_screencast__mutmut_2': x_start_screencast__mutmut_2, 
    'x_start_screencast__mutmut_3': x_start_screencast__mutmut_3, 
    'x_start_screencast__mutmut_4': x_start_screencast__mutmut_4, 
    'x_start_screencast__mutmut_5': x_start_screencast__mutmut_5, 
    'x_start_screencast__mutmut_6': x_start_screencast__mutmut_6, 
    'x_start_screencast__mutmut_7': x_start_screencast__mutmut_7, 
    'x_start_screencast__mutmut_8': x_start_screencast__mutmut_8, 
    'x_start_screencast__mutmut_9': x_start_screencast__mutmut_9, 
    'x_start_screencast__mutmut_10': x_start_screencast__mutmut_10, 
    'x_start_screencast__mutmut_11': x_start_screencast__mutmut_11, 
    'x_start_screencast__mutmut_12': x_start_screencast__mutmut_12, 
    'x_start_screencast__mutmut_13': x_start_screencast__mutmut_13, 
    'x_start_screencast__mutmut_14': x_start_screencast__mutmut_14, 
    'x_start_screencast__mutmut_15': x_start_screencast__mutmut_15, 
    'x_start_screencast__mutmut_16': x_start_screencast__mutmut_16, 
    'x_start_screencast__mutmut_17': x_start_screencast__mutmut_17, 
    'x_start_screencast__mutmut_18': x_start_screencast__mutmut_18, 
    'x_start_screencast__mutmut_19': x_start_screencast__mutmut_19, 
    'x_start_screencast__mutmut_20': x_start_screencast__mutmut_20, 
    'x_start_screencast__mutmut_21': x_start_screencast__mutmut_21, 
    'x_start_screencast__mutmut_22': x_start_screencast__mutmut_22, 
    'x_start_screencast__mutmut_23': x_start_screencast__mutmut_23, 
    'x_start_screencast__mutmut_24': x_start_screencast__mutmut_24, 
    'x_start_screencast__mutmut_25': x_start_screencast__mutmut_25, 
    'x_start_screencast__mutmut_26': x_start_screencast__mutmut_26, 
    'x_start_screencast__mutmut_27': x_start_screencast__mutmut_27, 
    'x_start_screencast__mutmut_28': x_start_screencast__mutmut_28, 
    'x_start_screencast__mutmut_29': x_start_screencast__mutmut_29, 
    'x_start_screencast__mutmut_30': x_start_screencast__mutmut_30, 
    'x_start_screencast__mutmut_31': x_start_screencast__mutmut_31, 
    'x_start_screencast__mutmut_32': x_start_screencast__mutmut_32, 
    'x_start_screencast__mutmut_33': x_start_screencast__mutmut_33, 
    'x_start_screencast__mutmut_34': x_start_screencast__mutmut_34, 
    'x_start_screencast__mutmut_35': x_start_screencast__mutmut_35, 
    'x_start_screencast__mutmut_36': x_start_screencast__mutmut_36, 
    'x_start_screencast__mutmut_37': x_start_screencast__mutmut_37, 
    'x_start_screencast__mutmut_38': x_start_screencast__mutmut_38, 
    'x_start_screencast__mutmut_39': x_start_screencast__mutmut_39, 
    'x_start_screencast__mutmut_40': x_start_screencast__mutmut_40
}

def start_screencast(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_start_screencast__mutmut_orig, x_start_screencast__mutmut_mutants, args, kwargs)
    return result 

start_screencast.__signature__ = _mutmut_signature(x_start_screencast__mutmut_orig)
x_start_screencast__mutmut_orig.__name__ = 'x_start_screencast'


def x_stop_loading__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Force the page stop all navigations and pending resource fetches.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.stopLoading",
    }
    yield cmd_dict


def x_stop_loading__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Force the page stop all navigations and pending resource fetches.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_stop_loading__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Force the page stop all navigations and pending resource fetches.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.stopLoading",
    }
    yield cmd_dict


def x_stop_loading__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Force the page stop all navigations and pending resource fetches.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.stopLoading",
    }
    yield cmd_dict


def x_stop_loading__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Force the page stop all navigations and pending resource fetches.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.stopLoading",
    }
    yield cmd_dict


def x_stop_loading__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Force the page stop all navigations and pending resource fetches.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.stopLoadingXX",
    }
    yield cmd_dict


def x_stop_loading__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Force the page stop all navigations and pending resource fetches.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.stoploading",
    }
    yield cmd_dict


def x_stop_loading__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Force the page stop all navigations and pending resource fetches.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.STOPLOADING",
    }
    yield cmd_dict


def x_stop_loading__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Force the page stop all navigations and pending resource fetches.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.stoploading",
    }
    yield cmd_dict

x_stop_loading__mutmut_mutants : ClassVar[MutantDict] = {
'x_stop_loading__mutmut_1': x_stop_loading__mutmut_1, 
    'x_stop_loading__mutmut_2': x_stop_loading__mutmut_2, 
    'x_stop_loading__mutmut_3': x_stop_loading__mutmut_3, 
    'x_stop_loading__mutmut_4': x_stop_loading__mutmut_4, 
    'x_stop_loading__mutmut_5': x_stop_loading__mutmut_5, 
    'x_stop_loading__mutmut_6': x_stop_loading__mutmut_6, 
    'x_stop_loading__mutmut_7': x_stop_loading__mutmut_7, 
    'x_stop_loading__mutmut_8': x_stop_loading__mutmut_8
}

def stop_loading(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_stop_loading__mutmut_orig, x_stop_loading__mutmut_mutants, args, kwargs)
    return result 

stop_loading.__signature__ = _mutmut_signature(x_stop_loading__mutmut_orig)
x_stop_loading__mutmut_orig.__name__ = 'x_stop_loading'


def x_crash__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Crashes renderer on the IO thread, generates minidumps.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.crash",
    }
    yield cmd_dict


def x_crash__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Crashes renderer on the IO thread, generates minidumps.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_crash__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Crashes renderer on the IO thread, generates minidumps.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.crash",
    }
    yield cmd_dict


def x_crash__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Crashes renderer on the IO thread, generates minidumps.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.crash",
    }
    yield cmd_dict


def x_crash__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Crashes renderer on the IO thread, generates minidumps.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.crash",
    }
    yield cmd_dict


def x_crash__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Crashes renderer on the IO thread, generates minidumps.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.crashXX",
    }
    yield cmd_dict


def x_crash__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Crashes renderer on the IO thread, generates minidumps.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.crash",
    }
    yield cmd_dict


def x_crash__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Crashes renderer on the IO thread, generates minidumps.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.CRASH",
    }
    yield cmd_dict

x_crash__mutmut_mutants : ClassVar[MutantDict] = {
'x_crash__mutmut_1': x_crash__mutmut_1, 
    'x_crash__mutmut_2': x_crash__mutmut_2, 
    'x_crash__mutmut_3': x_crash__mutmut_3, 
    'x_crash__mutmut_4': x_crash__mutmut_4, 
    'x_crash__mutmut_5': x_crash__mutmut_5, 
    'x_crash__mutmut_6': x_crash__mutmut_6, 
    'x_crash__mutmut_7': x_crash__mutmut_7
}

def crash(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_crash__mutmut_orig, x_crash__mutmut_mutants, args, kwargs)
    return result 

crash.__signature__ = _mutmut_signature(x_crash__mutmut_orig)
x_crash__mutmut_orig.__name__ = 'x_crash'


def x_close__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to close page, running its beforeunload hooks, if any.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.close",
    }
    yield cmd_dict


def x_close__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to close page, running its beforeunload hooks, if any.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_close__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to close page, running its beforeunload hooks, if any.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.close",
    }
    yield cmd_dict


def x_close__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to close page, running its beforeunload hooks, if any.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.close",
    }
    yield cmd_dict


def x_close__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to close page, running its beforeunload hooks, if any.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.close",
    }
    yield cmd_dict


def x_close__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to close page, running its beforeunload hooks, if any.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.closeXX",
    }
    yield cmd_dict


def x_close__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to close page, running its beforeunload hooks, if any.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.close",
    }
    yield cmd_dict


def x_close__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to close page, running its beforeunload hooks, if any.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.CLOSE",
    }
    yield cmd_dict

x_close__mutmut_mutants : ClassVar[MutantDict] = {
'x_close__mutmut_1': x_close__mutmut_1, 
    'x_close__mutmut_2': x_close__mutmut_2, 
    'x_close__mutmut_3': x_close__mutmut_3, 
    'x_close__mutmut_4': x_close__mutmut_4, 
    'x_close__mutmut_5': x_close__mutmut_5, 
    'x_close__mutmut_6': x_close__mutmut_6, 
    'x_close__mutmut_7': x_close__mutmut_7
}

def close(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_close__mutmut_orig, x_close__mutmut_mutants, args, kwargs)
    return result 

close.__signature__ = _mutmut_signature(x_close__mutmut_orig)
x_close__mutmut_orig.__name__ = 'x_close'


def x_set_web_lifecycle_state__mutmut_orig(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setWebLifecycleState",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_1(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = None
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setWebLifecycleState",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_2(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setWebLifecycleState",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_3(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["XXstateXX"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setWebLifecycleState",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_4(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["STATE"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setWebLifecycleState",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_5(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["State"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setWebLifecycleState",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_6(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_7(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setWebLifecycleState",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_8(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setWebLifecycleState",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_9(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setWebLifecycleState",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_10(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setWebLifecycleStateXX",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_11(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "page.setweblifecyclestate",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_12(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETWEBLIFECYCLESTATE",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_13(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setweblifecyclestate",
        "params": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_14(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setWebLifecycleState",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_15(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setWebLifecycleState",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_web_lifecycle_state__mutmut_16(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tries to update the web lifecycle state of the page.
    It will transition the page to the given state according to:
    https://github.com/WICG/web-lifecycle/

    **EXPERIMENTAL**

    :param state: Target lifecycle state
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setWebLifecycleState",
        "Params": params,
    }
    yield cmd_dict

x_set_web_lifecycle_state__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_web_lifecycle_state__mutmut_1': x_set_web_lifecycle_state__mutmut_1, 
    'x_set_web_lifecycle_state__mutmut_2': x_set_web_lifecycle_state__mutmut_2, 
    'x_set_web_lifecycle_state__mutmut_3': x_set_web_lifecycle_state__mutmut_3, 
    'x_set_web_lifecycle_state__mutmut_4': x_set_web_lifecycle_state__mutmut_4, 
    'x_set_web_lifecycle_state__mutmut_5': x_set_web_lifecycle_state__mutmut_5, 
    'x_set_web_lifecycle_state__mutmut_6': x_set_web_lifecycle_state__mutmut_6, 
    'x_set_web_lifecycle_state__mutmut_7': x_set_web_lifecycle_state__mutmut_7, 
    'x_set_web_lifecycle_state__mutmut_8': x_set_web_lifecycle_state__mutmut_8, 
    'x_set_web_lifecycle_state__mutmut_9': x_set_web_lifecycle_state__mutmut_9, 
    'x_set_web_lifecycle_state__mutmut_10': x_set_web_lifecycle_state__mutmut_10, 
    'x_set_web_lifecycle_state__mutmut_11': x_set_web_lifecycle_state__mutmut_11, 
    'x_set_web_lifecycle_state__mutmut_12': x_set_web_lifecycle_state__mutmut_12, 
    'x_set_web_lifecycle_state__mutmut_13': x_set_web_lifecycle_state__mutmut_13, 
    'x_set_web_lifecycle_state__mutmut_14': x_set_web_lifecycle_state__mutmut_14, 
    'x_set_web_lifecycle_state__mutmut_15': x_set_web_lifecycle_state__mutmut_15, 
    'x_set_web_lifecycle_state__mutmut_16': x_set_web_lifecycle_state__mutmut_16
}

def set_web_lifecycle_state(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_web_lifecycle_state__mutmut_orig, x_set_web_lifecycle_state__mutmut_mutants, args, kwargs)
    return result 

set_web_lifecycle_state.__signature__ = _mutmut_signature(x_set_web_lifecycle_state__mutmut_orig)
x_set_web_lifecycle_state__mutmut_orig.__name__ = 'x_set_web_lifecycle_state'


def x_stop_screencast__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops sending each frame in the ``screencastFrame``.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.stopScreencast",
    }
    yield cmd_dict


def x_stop_screencast__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops sending each frame in the ``screencastFrame``.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_stop_screencast__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops sending each frame in the ``screencastFrame``.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.stopScreencast",
    }
    yield cmd_dict


def x_stop_screencast__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops sending each frame in the ``screencastFrame``.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.stopScreencast",
    }
    yield cmd_dict


def x_stop_screencast__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops sending each frame in the ``screencastFrame``.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.stopScreencast",
    }
    yield cmd_dict


def x_stop_screencast__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops sending each frame in the ``screencastFrame``.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.stopScreencastXX",
    }
    yield cmd_dict


def x_stop_screencast__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops sending each frame in the ``screencastFrame``.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.stopscreencast",
    }
    yield cmd_dict


def x_stop_screencast__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops sending each frame in the ``screencastFrame``.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.STOPSCREENCAST",
    }
    yield cmd_dict


def x_stop_screencast__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops sending each frame in the ``screencastFrame``.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.stopscreencast",
    }
    yield cmd_dict

x_stop_screencast__mutmut_mutants : ClassVar[MutantDict] = {
'x_stop_screencast__mutmut_1': x_stop_screencast__mutmut_1, 
    'x_stop_screencast__mutmut_2': x_stop_screencast__mutmut_2, 
    'x_stop_screencast__mutmut_3': x_stop_screencast__mutmut_3, 
    'x_stop_screencast__mutmut_4': x_stop_screencast__mutmut_4, 
    'x_stop_screencast__mutmut_5': x_stop_screencast__mutmut_5, 
    'x_stop_screencast__mutmut_6': x_stop_screencast__mutmut_6, 
    'x_stop_screencast__mutmut_7': x_stop_screencast__mutmut_7, 
    'x_stop_screencast__mutmut_8': x_stop_screencast__mutmut_8
}

def stop_screencast(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_stop_screencast__mutmut_orig, x_stop_screencast__mutmut_mutants, args, kwargs)
    return result 

stop_screencast.__signature__ = _mutmut_signature(x_stop_screencast__mutmut_orig)
x_stop_screencast__mutmut_orig.__name__ = 'x_stop_screencast'


def x_produce_compilation_cache__mutmut_orig(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.produceCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_1(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = None
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.produceCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_2(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.produceCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_3(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["XXscriptsXX"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.produceCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_4(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["SCRIPTS"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.produceCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_5(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["Scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.produceCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_6(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_produce_compilation_cache__mutmut_7(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.produceCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_8(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.produceCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_9(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.produceCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_10(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.produceCompilationCacheXX",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_11(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "page.producecompilationcache",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_12(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.PRODUCECOMPILATIONCACHE",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_13(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.producecompilationcache",
        "params": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_14(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.produceCompilationCache",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_15(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.produceCompilationCache",
        "PARAMS": params,
    }
    yield cmd_dict


def x_produce_compilation_cache__mutmut_16(
    scripts: list[CompilationCacheParams],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests backend to produce compilation cache for the specified scripts.
    ``scripts`` are appended to the list of scripts for which the cache
    would be produced. The list may be reset during page navigation.
    When script with a matching URL is encountered, the cache is optionally
    produced upon backend discretion, based on internal heuristics.
    See also: ``Page.compilationCacheProduced``.

    **EXPERIMENTAL**

    :param scripts:
    """
    params: T_JSON_DICT = {}
    params["scripts"] = [i.to_json() for i in scripts]
    cmd_dict: T_JSON_DICT = {
        "method": "Page.produceCompilationCache",
        "Params": params,
    }
    yield cmd_dict

x_produce_compilation_cache__mutmut_mutants : ClassVar[MutantDict] = {
'x_produce_compilation_cache__mutmut_1': x_produce_compilation_cache__mutmut_1, 
    'x_produce_compilation_cache__mutmut_2': x_produce_compilation_cache__mutmut_2, 
    'x_produce_compilation_cache__mutmut_3': x_produce_compilation_cache__mutmut_3, 
    'x_produce_compilation_cache__mutmut_4': x_produce_compilation_cache__mutmut_4, 
    'x_produce_compilation_cache__mutmut_5': x_produce_compilation_cache__mutmut_5, 
    'x_produce_compilation_cache__mutmut_6': x_produce_compilation_cache__mutmut_6, 
    'x_produce_compilation_cache__mutmut_7': x_produce_compilation_cache__mutmut_7, 
    'x_produce_compilation_cache__mutmut_8': x_produce_compilation_cache__mutmut_8, 
    'x_produce_compilation_cache__mutmut_9': x_produce_compilation_cache__mutmut_9, 
    'x_produce_compilation_cache__mutmut_10': x_produce_compilation_cache__mutmut_10, 
    'x_produce_compilation_cache__mutmut_11': x_produce_compilation_cache__mutmut_11, 
    'x_produce_compilation_cache__mutmut_12': x_produce_compilation_cache__mutmut_12, 
    'x_produce_compilation_cache__mutmut_13': x_produce_compilation_cache__mutmut_13, 
    'x_produce_compilation_cache__mutmut_14': x_produce_compilation_cache__mutmut_14, 
    'x_produce_compilation_cache__mutmut_15': x_produce_compilation_cache__mutmut_15, 
    'x_produce_compilation_cache__mutmut_16': x_produce_compilation_cache__mutmut_16
}

def produce_compilation_cache(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_produce_compilation_cache__mutmut_orig, x_produce_compilation_cache__mutmut_mutants, args, kwargs)
    return result 

produce_compilation_cache.__signature__ = _mutmut_signature(x_produce_compilation_cache__mutmut_orig)
x_produce_compilation_cache__mutmut_orig.__name__ = 'x_produce_compilation_cache'


def x_add_compilation_cache__mutmut_orig(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_1(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = None
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_2(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = None
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_3(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["XXurlXX"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_4(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["URL"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_5(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["Url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_6(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_7(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["XXdataXX"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_8(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["DATA"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_9(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["Data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_10(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_add_compilation_cache__mutmut_11(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_12(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_13(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.addCompilationCache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_14(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.addCompilationCacheXX",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_15(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "page.addcompilationcache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_16(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.ADDCOMPILATIONCACHE",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_17(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addcompilationcache",
        "params": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_18(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_19(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "PARAMS": params,
    }
    yield cmd_dict


def x_add_compilation_cache__mutmut_20(
    url: str,
    data: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Seeds compilation cache for given url. Compilation cache does not survive
    cross-process navigation.

    **EXPERIMENTAL**

    :param url:
    :param data: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["url"] = url
    params["data"] = data
    cmd_dict: T_JSON_DICT = {
        "method": "Page.addCompilationCache",
        "Params": params,
    }
    yield cmd_dict

x_add_compilation_cache__mutmut_mutants : ClassVar[MutantDict] = {
'x_add_compilation_cache__mutmut_1': x_add_compilation_cache__mutmut_1, 
    'x_add_compilation_cache__mutmut_2': x_add_compilation_cache__mutmut_2, 
    'x_add_compilation_cache__mutmut_3': x_add_compilation_cache__mutmut_3, 
    'x_add_compilation_cache__mutmut_4': x_add_compilation_cache__mutmut_4, 
    'x_add_compilation_cache__mutmut_5': x_add_compilation_cache__mutmut_5, 
    'x_add_compilation_cache__mutmut_6': x_add_compilation_cache__mutmut_6, 
    'x_add_compilation_cache__mutmut_7': x_add_compilation_cache__mutmut_7, 
    'x_add_compilation_cache__mutmut_8': x_add_compilation_cache__mutmut_8, 
    'x_add_compilation_cache__mutmut_9': x_add_compilation_cache__mutmut_9, 
    'x_add_compilation_cache__mutmut_10': x_add_compilation_cache__mutmut_10, 
    'x_add_compilation_cache__mutmut_11': x_add_compilation_cache__mutmut_11, 
    'x_add_compilation_cache__mutmut_12': x_add_compilation_cache__mutmut_12, 
    'x_add_compilation_cache__mutmut_13': x_add_compilation_cache__mutmut_13, 
    'x_add_compilation_cache__mutmut_14': x_add_compilation_cache__mutmut_14, 
    'x_add_compilation_cache__mutmut_15': x_add_compilation_cache__mutmut_15, 
    'x_add_compilation_cache__mutmut_16': x_add_compilation_cache__mutmut_16, 
    'x_add_compilation_cache__mutmut_17': x_add_compilation_cache__mutmut_17, 
    'x_add_compilation_cache__mutmut_18': x_add_compilation_cache__mutmut_18, 
    'x_add_compilation_cache__mutmut_19': x_add_compilation_cache__mutmut_19, 
    'x_add_compilation_cache__mutmut_20': x_add_compilation_cache__mutmut_20
}

def add_compilation_cache(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_add_compilation_cache__mutmut_orig, x_add_compilation_cache__mutmut_mutants, args, kwargs)
    return result 

add_compilation_cache.__signature__ = _mutmut_signature(x_add_compilation_cache__mutmut_orig)
x_add_compilation_cache__mutmut_orig.__name__ = 'x_add_compilation_cache'


def x_clear_compilation_cache__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears seeded compilation cache.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.clearCompilationCache",
    }
    yield cmd_dict


def x_clear_compilation_cache__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears seeded compilation cache.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_clear_compilation_cache__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears seeded compilation cache.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.clearCompilationCache",
    }
    yield cmd_dict


def x_clear_compilation_cache__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears seeded compilation cache.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.clearCompilationCache",
    }
    yield cmd_dict


def x_clear_compilation_cache__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears seeded compilation cache.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.clearCompilationCache",
    }
    yield cmd_dict


def x_clear_compilation_cache__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears seeded compilation cache.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.clearCompilationCacheXX",
    }
    yield cmd_dict


def x_clear_compilation_cache__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears seeded compilation cache.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.clearcompilationcache",
    }
    yield cmd_dict


def x_clear_compilation_cache__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears seeded compilation cache.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.CLEARCOMPILATIONCACHE",
    }
    yield cmd_dict


def x_clear_compilation_cache__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Clears seeded compilation cache.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.clearcompilationcache",
    }
    yield cmd_dict

x_clear_compilation_cache__mutmut_mutants : ClassVar[MutantDict] = {
'x_clear_compilation_cache__mutmut_1': x_clear_compilation_cache__mutmut_1, 
    'x_clear_compilation_cache__mutmut_2': x_clear_compilation_cache__mutmut_2, 
    'x_clear_compilation_cache__mutmut_3': x_clear_compilation_cache__mutmut_3, 
    'x_clear_compilation_cache__mutmut_4': x_clear_compilation_cache__mutmut_4, 
    'x_clear_compilation_cache__mutmut_5': x_clear_compilation_cache__mutmut_5, 
    'x_clear_compilation_cache__mutmut_6': x_clear_compilation_cache__mutmut_6, 
    'x_clear_compilation_cache__mutmut_7': x_clear_compilation_cache__mutmut_7, 
    'x_clear_compilation_cache__mutmut_8': x_clear_compilation_cache__mutmut_8
}

def clear_compilation_cache(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_clear_compilation_cache__mutmut_orig, x_clear_compilation_cache__mutmut_mutants, args, kwargs)
    return result 

clear_compilation_cache.__signature__ = _mutmut_signature(x_clear_compilation_cache__mutmut_orig)
x_clear_compilation_cache__mutmut_orig.__name__ = 'x_clear_compilation_cache'


def x_set_spc_transaction_mode__mutmut_orig(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setSPCTransactionMode",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_1(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = None
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setSPCTransactionMode",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_2(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setSPCTransactionMode",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_3(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["XXmodeXX"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setSPCTransactionMode",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_4(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["MODE"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setSPCTransactionMode",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_5(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["Mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setSPCTransactionMode",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_6(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_7(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setSPCTransactionMode",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_8(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setSPCTransactionMode",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_9(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setSPCTransactionMode",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_10(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setSPCTransactionModeXX",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_11(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "page.setspctransactionmode",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_12(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETSPCTRANSACTIONMODE",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_13(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setspctransactionmode",
        "params": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_14(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setSPCTransactionMode",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_15(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setSPCTransactionMode",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_spc_transaction_mode__mutmut_16(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets the Secure Payment Confirmation transaction mode.
    https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setSPCTransactionMode",
        "Params": params,
    }
    yield cmd_dict

x_set_spc_transaction_mode__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_spc_transaction_mode__mutmut_1': x_set_spc_transaction_mode__mutmut_1, 
    'x_set_spc_transaction_mode__mutmut_2': x_set_spc_transaction_mode__mutmut_2, 
    'x_set_spc_transaction_mode__mutmut_3': x_set_spc_transaction_mode__mutmut_3, 
    'x_set_spc_transaction_mode__mutmut_4': x_set_spc_transaction_mode__mutmut_4, 
    'x_set_spc_transaction_mode__mutmut_5': x_set_spc_transaction_mode__mutmut_5, 
    'x_set_spc_transaction_mode__mutmut_6': x_set_spc_transaction_mode__mutmut_6, 
    'x_set_spc_transaction_mode__mutmut_7': x_set_spc_transaction_mode__mutmut_7, 
    'x_set_spc_transaction_mode__mutmut_8': x_set_spc_transaction_mode__mutmut_8, 
    'x_set_spc_transaction_mode__mutmut_9': x_set_spc_transaction_mode__mutmut_9, 
    'x_set_spc_transaction_mode__mutmut_10': x_set_spc_transaction_mode__mutmut_10, 
    'x_set_spc_transaction_mode__mutmut_11': x_set_spc_transaction_mode__mutmut_11, 
    'x_set_spc_transaction_mode__mutmut_12': x_set_spc_transaction_mode__mutmut_12, 
    'x_set_spc_transaction_mode__mutmut_13': x_set_spc_transaction_mode__mutmut_13, 
    'x_set_spc_transaction_mode__mutmut_14': x_set_spc_transaction_mode__mutmut_14, 
    'x_set_spc_transaction_mode__mutmut_15': x_set_spc_transaction_mode__mutmut_15, 
    'x_set_spc_transaction_mode__mutmut_16': x_set_spc_transaction_mode__mutmut_16
}

def set_spc_transaction_mode(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_spc_transaction_mode__mutmut_orig, x_set_spc_transaction_mode__mutmut_mutants, args, kwargs)
    return result 

set_spc_transaction_mode.__signature__ = _mutmut_signature(x_set_spc_transaction_mode__mutmut_orig)
x_set_spc_transaction_mode__mutmut_orig.__name__ = 'x_set_spc_transaction_mode'


def x_set_rph_registration_mode__mutmut_orig(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setRPHRegistrationMode",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_1(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = None
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setRPHRegistrationMode",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_2(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setRPHRegistrationMode",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_3(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["XXmodeXX"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setRPHRegistrationMode",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_4(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["MODE"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setRPHRegistrationMode",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_5(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["Mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setRPHRegistrationMode",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_6(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_7(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setRPHRegistrationMode",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_8(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setRPHRegistrationMode",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_9(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setRPHRegistrationMode",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_10(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setRPHRegistrationModeXX",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_11(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "page.setrphregistrationmode",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_12(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETRPHREGISTRATIONMODE",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_13(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setrphregistrationmode",
        "params": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_14(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setRPHRegistrationMode",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_15(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setRPHRegistrationMode",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_rph_registration_mode__mutmut_16(
    mode: AutoResponseMode,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Extensions for Custom Handlers API:
    https://html.spec.whatwg.org/multipage/system-state.html#rph-automation

    **EXPERIMENTAL**

    :param mode:
    """
    params: T_JSON_DICT = {}
    params["mode"] = mode.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setRPHRegistrationMode",
        "Params": params,
    }
    yield cmd_dict

x_set_rph_registration_mode__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_rph_registration_mode__mutmut_1': x_set_rph_registration_mode__mutmut_1, 
    'x_set_rph_registration_mode__mutmut_2': x_set_rph_registration_mode__mutmut_2, 
    'x_set_rph_registration_mode__mutmut_3': x_set_rph_registration_mode__mutmut_3, 
    'x_set_rph_registration_mode__mutmut_4': x_set_rph_registration_mode__mutmut_4, 
    'x_set_rph_registration_mode__mutmut_5': x_set_rph_registration_mode__mutmut_5, 
    'x_set_rph_registration_mode__mutmut_6': x_set_rph_registration_mode__mutmut_6, 
    'x_set_rph_registration_mode__mutmut_7': x_set_rph_registration_mode__mutmut_7, 
    'x_set_rph_registration_mode__mutmut_8': x_set_rph_registration_mode__mutmut_8, 
    'x_set_rph_registration_mode__mutmut_9': x_set_rph_registration_mode__mutmut_9, 
    'x_set_rph_registration_mode__mutmut_10': x_set_rph_registration_mode__mutmut_10, 
    'x_set_rph_registration_mode__mutmut_11': x_set_rph_registration_mode__mutmut_11, 
    'x_set_rph_registration_mode__mutmut_12': x_set_rph_registration_mode__mutmut_12, 
    'x_set_rph_registration_mode__mutmut_13': x_set_rph_registration_mode__mutmut_13, 
    'x_set_rph_registration_mode__mutmut_14': x_set_rph_registration_mode__mutmut_14, 
    'x_set_rph_registration_mode__mutmut_15': x_set_rph_registration_mode__mutmut_15, 
    'x_set_rph_registration_mode__mutmut_16': x_set_rph_registration_mode__mutmut_16
}

def set_rph_registration_mode(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_rph_registration_mode__mutmut_orig, x_set_rph_registration_mode__mutmut_mutants, args, kwargs)
    return result 

set_rph_registration_mode.__signature__ = _mutmut_signature(x_set_rph_registration_mode__mutmut_orig)
x_set_rph_registration_mode__mutmut_orig.__name__ = 'x_set_rph_registration_mode'


def x_generate_test_report__mutmut_orig(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_1(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = None
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_2(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = None
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_3(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["XXmessageXX"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_4(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["MESSAGE"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_5(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["Message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_6(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_7(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_8(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["XXgroupXX"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_9(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["GROUP"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_10(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["Group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_11(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_generate_test_report__mutmut_12(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_13(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_14(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.generateTestReport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_15(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.generateTestReportXX",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_16(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "page.generatetestreport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_17(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.GENERATETESTREPORT",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_18(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generatetestreport",
        "params": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_19(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_20(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "PARAMS": params,
    }
    yield cmd_dict


def x_generate_test_report__mutmut_21(
    message: str,
    group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Generates a report for testing.

    **EXPERIMENTAL**

    :param message: Message to be displayed in the report.
    :param group: *(Optional)* Specifies the endpoint group to deliver the report to.
    """
    params: T_JSON_DICT = {}
    params["message"] = message
    if group is not None:
        params["group"] = group
    cmd_dict: T_JSON_DICT = {
        "method": "Page.generateTestReport",
        "Params": params,
    }
    yield cmd_dict

x_generate_test_report__mutmut_mutants : ClassVar[MutantDict] = {
'x_generate_test_report__mutmut_1': x_generate_test_report__mutmut_1, 
    'x_generate_test_report__mutmut_2': x_generate_test_report__mutmut_2, 
    'x_generate_test_report__mutmut_3': x_generate_test_report__mutmut_3, 
    'x_generate_test_report__mutmut_4': x_generate_test_report__mutmut_4, 
    'x_generate_test_report__mutmut_5': x_generate_test_report__mutmut_5, 
    'x_generate_test_report__mutmut_6': x_generate_test_report__mutmut_6, 
    'x_generate_test_report__mutmut_7': x_generate_test_report__mutmut_7, 
    'x_generate_test_report__mutmut_8': x_generate_test_report__mutmut_8, 
    'x_generate_test_report__mutmut_9': x_generate_test_report__mutmut_9, 
    'x_generate_test_report__mutmut_10': x_generate_test_report__mutmut_10, 
    'x_generate_test_report__mutmut_11': x_generate_test_report__mutmut_11, 
    'x_generate_test_report__mutmut_12': x_generate_test_report__mutmut_12, 
    'x_generate_test_report__mutmut_13': x_generate_test_report__mutmut_13, 
    'x_generate_test_report__mutmut_14': x_generate_test_report__mutmut_14, 
    'x_generate_test_report__mutmut_15': x_generate_test_report__mutmut_15, 
    'x_generate_test_report__mutmut_16': x_generate_test_report__mutmut_16, 
    'x_generate_test_report__mutmut_17': x_generate_test_report__mutmut_17, 
    'x_generate_test_report__mutmut_18': x_generate_test_report__mutmut_18, 
    'x_generate_test_report__mutmut_19': x_generate_test_report__mutmut_19, 
    'x_generate_test_report__mutmut_20': x_generate_test_report__mutmut_20, 
    'x_generate_test_report__mutmut_21': x_generate_test_report__mutmut_21
}

def generate_test_report(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_generate_test_report__mutmut_orig, x_generate_test_report__mutmut_mutants, args, kwargs)
    return result 

generate_test_report.__signature__ = _mutmut_signature(x_generate_test_report__mutmut_orig)
x_generate_test_report__mutmut_orig.__name__ = 'x_generate_test_report'


def x_wait_for_debugger__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.waitForDebugger",
    }
    yield cmd_dict


def x_wait_for_debugger__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_wait_for_debugger__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.waitForDebugger",
    }
    yield cmd_dict


def x_wait_for_debugger__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.waitForDebugger",
    }
    yield cmd_dict


def x_wait_for_debugger__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.waitForDebugger",
    }
    yield cmd_dict


def x_wait_for_debugger__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.waitForDebuggerXX",
    }
    yield cmd_dict


def x_wait_for_debugger__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "page.waitfordebugger",
    }
    yield cmd_dict


def x_wait_for_debugger__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.WAITFORDEBUGGER",
    }
    yield cmd_dict


def x_wait_for_debugger__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Page.waitfordebugger",
    }
    yield cmd_dict

x_wait_for_debugger__mutmut_mutants : ClassVar[MutantDict] = {
'x_wait_for_debugger__mutmut_1': x_wait_for_debugger__mutmut_1, 
    'x_wait_for_debugger__mutmut_2': x_wait_for_debugger__mutmut_2, 
    'x_wait_for_debugger__mutmut_3': x_wait_for_debugger__mutmut_3, 
    'x_wait_for_debugger__mutmut_4': x_wait_for_debugger__mutmut_4, 
    'x_wait_for_debugger__mutmut_5': x_wait_for_debugger__mutmut_5, 
    'x_wait_for_debugger__mutmut_6': x_wait_for_debugger__mutmut_6, 
    'x_wait_for_debugger__mutmut_7': x_wait_for_debugger__mutmut_7, 
    'x_wait_for_debugger__mutmut_8': x_wait_for_debugger__mutmut_8
}

def wait_for_debugger(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_wait_for_debugger__mutmut_orig, x_wait_for_debugger__mutmut_mutants, args, kwargs)
    return result 

wait_for_debugger.__signature__ = _mutmut_signature(x_wait_for_debugger__mutmut_orig)
x_wait_for_debugger__mutmut_orig.__name__ = 'x_wait_for_debugger'


def x_set_intercept_file_chooser_dialog__mutmut_orig(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_1(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = None
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_2(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = None
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_3(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["XXenabledXX"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_4(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["ENABLED"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_5(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["Enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_6(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_7(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_8(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["XXcancelXX"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_9(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["CANCEL"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_10(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["Cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_11(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_12(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_13(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_14(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setInterceptFileChooserDialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_15(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setInterceptFileChooserDialogXX",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_16(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "page.setinterceptfilechooserdialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_17(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETINTERCEPTFILECHOOSERDIALOG",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_18(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setinterceptfilechooserdialog",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_19(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_20(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_intercept_file_chooser_dialog__mutmut_21(
    enabled: bool,
    cancel: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Intercept file chooser requests and transfer control to protocol clients.
    When file chooser interception is enabled, native file chooser dialog is not shown.
    Instead, a protocol event ``Page.fileChooserOpened`` is emitted.

    :param enabled:
    :param cancel: **(EXPERIMENTAL)** *(Optional)* If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    if cancel is not None:
        params["cancel"] = cancel
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setInterceptFileChooserDialog",
        "Params": params,
    }
    yield cmd_dict

x_set_intercept_file_chooser_dialog__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_intercept_file_chooser_dialog__mutmut_1': x_set_intercept_file_chooser_dialog__mutmut_1, 
    'x_set_intercept_file_chooser_dialog__mutmut_2': x_set_intercept_file_chooser_dialog__mutmut_2, 
    'x_set_intercept_file_chooser_dialog__mutmut_3': x_set_intercept_file_chooser_dialog__mutmut_3, 
    'x_set_intercept_file_chooser_dialog__mutmut_4': x_set_intercept_file_chooser_dialog__mutmut_4, 
    'x_set_intercept_file_chooser_dialog__mutmut_5': x_set_intercept_file_chooser_dialog__mutmut_5, 
    'x_set_intercept_file_chooser_dialog__mutmut_6': x_set_intercept_file_chooser_dialog__mutmut_6, 
    'x_set_intercept_file_chooser_dialog__mutmut_7': x_set_intercept_file_chooser_dialog__mutmut_7, 
    'x_set_intercept_file_chooser_dialog__mutmut_8': x_set_intercept_file_chooser_dialog__mutmut_8, 
    'x_set_intercept_file_chooser_dialog__mutmut_9': x_set_intercept_file_chooser_dialog__mutmut_9, 
    'x_set_intercept_file_chooser_dialog__mutmut_10': x_set_intercept_file_chooser_dialog__mutmut_10, 
    'x_set_intercept_file_chooser_dialog__mutmut_11': x_set_intercept_file_chooser_dialog__mutmut_11, 
    'x_set_intercept_file_chooser_dialog__mutmut_12': x_set_intercept_file_chooser_dialog__mutmut_12, 
    'x_set_intercept_file_chooser_dialog__mutmut_13': x_set_intercept_file_chooser_dialog__mutmut_13, 
    'x_set_intercept_file_chooser_dialog__mutmut_14': x_set_intercept_file_chooser_dialog__mutmut_14, 
    'x_set_intercept_file_chooser_dialog__mutmut_15': x_set_intercept_file_chooser_dialog__mutmut_15, 
    'x_set_intercept_file_chooser_dialog__mutmut_16': x_set_intercept_file_chooser_dialog__mutmut_16, 
    'x_set_intercept_file_chooser_dialog__mutmut_17': x_set_intercept_file_chooser_dialog__mutmut_17, 
    'x_set_intercept_file_chooser_dialog__mutmut_18': x_set_intercept_file_chooser_dialog__mutmut_18, 
    'x_set_intercept_file_chooser_dialog__mutmut_19': x_set_intercept_file_chooser_dialog__mutmut_19, 
    'x_set_intercept_file_chooser_dialog__mutmut_20': x_set_intercept_file_chooser_dialog__mutmut_20, 
    'x_set_intercept_file_chooser_dialog__mutmut_21': x_set_intercept_file_chooser_dialog__mutmut_21
}

def set_intercept_file_chooser_dialog(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_intercept_file_chooser_dialog__mutmut_orig, x_set_intercept_file_chooser_dialog__mutmut_mutants, args, kwargs)
    return result 

set_intercept_file_chooser_dialog.__signature__ = _mutmut_signature(x_set_intercept_file_chooser_dialog__mutmut_orig)
x_set_intercept_file_chooser_dialog__mutmut_orig.__name__ = 'x_set_intercept_file_chooser_dialog'


def x_set_prerendering_allowed__mutmut_orig(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setPrerenderingAllowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_1(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = None
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setPrerenderingAllowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_2(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setPrerenderingAllowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_3(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["XXisAllowedXX"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setPrerenderingAllowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_4(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isallowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setPrerenderingAllowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_5(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["ISALLOWED"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setPrerenderingAllowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_6(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["Isallowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setPrerenderingAllowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_7(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_8(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Page.setPrerenderingAllowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_9(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Page.setPrerenderingAllowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_10(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "Method": "Page.setPrerenderingAllowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_11(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "XXPage.setPrerenderingAllowedXX",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_12(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "page.setprerenderingallowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_13(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "PAGE.SETPRERENDERINGALLOWED",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_14(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setprerenderingallowed",
        "params": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_15(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setPrerenderingAllowed",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_16(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setPrerenderingAllowed",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_prerendering_allowed__mutmut_17(
    is_allowed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enable/disable prerendering manually.

    This command is a short-term solution for https://crbug.com/1440085.
    See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
    for more details.

    TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.

    **EXPERIMENTAL**

    :param is_allowed:
    """
    params: T_JSON_DICT = {}
    params["isAllowed"] = is_allowed
    cmd_dict: T_JSON_DICT = {
        "method": "Page.setPrerenderingAllowed",
        "Params": params,
    }
    yield cmd_dict

x_set_prerendering_allowed__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_prerendering_allowed__mutmut_1': x_set_prerendering_allowed__mutmut_1, 
    'x_set_prerendering_allowed__mutmut_2': x_set_prerendering_allowed__mutmut_2, 
    'x_set_prerendering_allowed__mutmut_3': x_set_prerendering_allowed__mutmut_3, 
    'x_set_prerendering_allowed__mutmut_4': x_set_prerendering_allowed__mutmut_4, 
    'x_set_prerendering_allowed__mutmut_5': x_set_prerendering_allowed__mutmut_5, 
    'x_set_prerendering_allowed__mutmut_6': x_set_prerendering_allowed__mutmut_6, 
    'x_set_prerendering_allowed__mutmut_7': x_set_prerendering_allowed__mutmut_7, 
    'x_set_prerendering_allowed__mutmut_8': x_set_prerendering_allowed__mutmut_8, 
    'x_set_prerendering_allowed__mutmut_9': x_set_prerendering_allowed__mutmut_9, 
    'x_set_prerendering_allowed__mutmut_10': x_set_prerendering_allowed__mutmut_10, 
    'x_set_prerendering_allowed__mutmut_11': x_set_prerendering_allowed__mutmut_11, 
    'x_set_prerendering_allowed__mutmut_12': x_set_prerendering_allowed__mutmut_12, 
    'x_set_prerendering_allowed__mutmut_13': x_set_prerendering_allowed__mutmut_13, 
    'x_set_prerendering_allowed__mutmut_14': x_set_prerendering_allowed__mutmut_14, 
    'x_set_prerendering_allowed__mutmut_15': x_set_prerendering_allowed__mutmut_15, 
    'x_set_prerendering_allowed__mutmut_16': x_set_prerendering_allowed__mutmut_16, 
    'x_set_prerendering_allowed__mutmut_17': x_set_prerendering_allowed__mutmut_17
}

def set_prerendering_allowed(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_prerendering_allowed__mutmut_orig, x_set_prerendering_allowed__mutmut_mutants, args, kwargs)
    return result 

set_prerendering_allowed.__signature__ = _mutmut_signature(x_set_prerendering_allowed__mutmut_orig)
x_set_prerendering_allowed__mutmut_orig.__name__ = 'x_set_prerendering_allowed'


@event_class("Page.domContentEventFired")
@dataclass
class DomContentEventFired:
    timestamp: network.MonotonicTime

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DomContentEventFired:
        return cls(
            timestamp=network.MonotonicTime.from_json(json["timestamp"]),
        )


@event_class("Page.fileChooserOpened")
@dataclass
class FileChooserOpened:
    """
    Emitted only when ``page.interceptFileChooser`` is enabled.
    """
    #: Id of the frame containing input node.
    frame_id: FrameId
    #: Input mode.
    mode: str
    #: Input node id. Only present for file choosers opened via an ``<input type="file">`` element.
    backend_node_id: dom.BackendNodeId | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FileChooserOpened:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
            mode=str(json["mode"]),
            backend_node_id=dom.BackendNodeId.from_json(json["backendNodeId"]) if "backendNodeId" in json else None,
        )


@event_class("Page.frameAttached")
@dataclass
class FrameAttached:
    """
    Fired when frame has been attached to its parent.
    """
    #: Id of the frame that has been attached.
    frame_id: FrameId
    #: Parent frame identifier.
    parent_frame_id: FrameId
    #: JavaScript stack trace of when frame was attached, only set if frame initiated from script.
    stack: runtime.StackTrace | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameAttached:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
            parent_frame_id=FrameId.from_json(json["parentFrameId"]),
            stack=runtime.StackTrace.from_json(json["stack"]) if "stack" in json else None,
        )


@event_class("Page.frameClearedScheduledNavigation")
@dataclass
class FrameClearedScheduledNavigation:
    """
    Fired when frame no longer has a scheduled navigation.
    """
    #: Id of the frame that has cleared its scheduled navigation.
    frame_id: FrameId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameClearedScheduledNavigation:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
        )


@event_class("Page.frameDetached")
@dataclass
class FrameDetached:
    """
    Fired when frame has been detached from its parent.
    """
    #: Id of the frame that has been detached.
    frame_id: FrameId
    reason: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameDetached:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
            reason=str(json["reason"]),
        )


@event_class("Page.frameSubtreeWillBeDetached")
@dataclass
class FrameSubtreeWillBeDetached:
    """
    **EXPERIMENTAL**

    Fired before frame subtree is detached. Emitted before any frame of the
    subtree is actually detached.
    """
    #: Id of the frame that is the root of the subtree that will be detached.
    frame_id: FrameId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameSubtreeWillBeDetached:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
        )


@event_class("Page.frameNavigated")
@dataclass
class FrameNavigated:
    """
    Fired once navigation of the frame has completed. Frame is now associated with the new loader.
    """
    #: Frame object.
    frame: Frame
    type_: NavigationType

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameNavigated:
        return cls(
            frame=Frame.from_json(json["frame"]),
            type_=NavigationType.from_json(json["type"]),
        )


@event_class("Page.documentOpened")
@dataclass
class DocumentOpened:
    """
    **EXPERIMENTAL**

    Fired when opening document to write to.
    """
    #: Frame object.
    frame: Frame

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DocumentOpened:
        return cls(
            frame=Frame.from_json(json["frame"]),
        )


@event_class("Page.frameResized")
@dataclass
class FrameResized:
    """
    **EXPERIMENTAL**


    """


    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameResized:
        return cls(

        )


@event_class("Page.frameStartedNavigating")
@dataclass
class FrameStartedNavigating:
    """
    **EXPERIMENTAL**

    Fired when a navigation starts. This event is fired for both
    renderer-initiated and browser-initiated navigations. For renderer-initiated
    navigations, the event is fired after ``frameRequestedNavigation``.
    Navigation may still be cancelled after the event is issued. Multiple events
    can be fired for a single navigation, for example, when a same-document
    navigation becomes a cross-document navigation (such as in the case of a
    frameset).
    """
    #: ID of the frame that is being navigated.
    frame_id: FrameId
    #: The URL the navigation started with. The final URL can be different.
    url: str
    #: Loader identifier. Even though it is present in case of same-document
    #: navigation, the previously committed loaderId would not change unless
    #: the navigation changes from a same-document to a cross-document
    #: navigation.
    loader_id: network.LoaderId
    navigation_type: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameStartedNavigating:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
            url=str(json["url"]),
            loader_id=network.LoaderId.from_json(json["loaderId"]),
            navigation_type=str(json["navigationType"]),
        )


@event_class("Page.frameRequestedNavigation")
@dataclass
class FrameRequestedNavigation:
    """
    **EXPERIMENTAL**

    Fired when a renderer-initiated navigation is requested.
    Navigation may still be cancelled after the event is issued.
    """
    #: Id of the frame that is being navigated.
    frame_id: FrameId
    #: The reason for the navigation.
    reason: ClientNavigationReason
    #: The destination URL for the requested navigation.
    url: str
    #: The disposition for the navigation.
    disposition: ClientNavigationDisposition

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameRequestedNavigation:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
            reason=ClientNavigationReason.from_json(json["reason"]),
            url=str(json["url"]),
            disposition=ClientNavigationDisposition.from_json(json["disposition"]),
        )


@event_class("Page.frameScheduledNavigation")
@dataclass
class FrameScheduledNavigation:
    """
    Fired when frame schedules a potential navigation.
    """
    #: Id of the frame that has scheduled a navigation.
    frame_id: FrameId
    #: Delay (in seconds) until the navigation is scheduled to begin. The navigation is not
    #: guaranteed to start.
    delay: float
    #: The reason for the navigation.
    reason: ClientNavigationReason
    #: The destination URL for the scheduled navigation.
    url: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameScheduledNavigation:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
            delay=float(json["delay"]),
            reason=ClientNavigationReason.from_json(json["reason"]),
            url=str(json["url"]),
        )


@event_class("Page.frameStartedLoading")
@dataclass
class FrameStartedLoading:
    """
    **EXPERIMENTAL**

    Fired when frame has started loading.
    """
    #: Id of the frame that has started loading.
    frame_id: FrameId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameStartedLoading:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
        )


@event_class("Page.frameStoppedLoading")
@dataclass
class FrameStoppedLoading:
    """
    **EXPERIMENTAL**

    Fired when frame has stopped loading.
    """
    #: Id of the frame that has stopped loading.
    frame_id: FrameId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FrameStoppedLoading:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
        )


@event_class("Page.downloadWillBegin")
@dataclass
class DownloadWillBegin:
    """
    **EXPERIMENTAL**

    Fired when page is about to start a download.
    Deprecated. Use Browser.downloadWillBegin instead.
    """
    #: Id of the frame that caused download to begin.
    frame_id: FrameId
    #: Global unique identifier of the download.
    guid: str
    #: URL of the resource being downloaded.
    url: str
    #: Suggested file name of the resource (the actual name of the file saved on disk may differ).
    suggested_filename: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DownloadWillBegin:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
            guid=str(json["guid"]),
            url=str(json["url"]),
            suggested_filename=str(json["suggestedFilename"]),
        )


@event_class("Page.downloadProgress")
@dataclass
class DownloadProgress:
    """
    **EXPERIMENTAL**

    Fired when download makes progress. Last call has ``done`` == true.
    Deprecated. Use Browser.downloadProgress instead.
    """
    #: Global unique identifier of the download.
    guid: str
    #: Total expected bytes to download.
    total_bytes: float
    #: Total bytes received.
    received_bytes: float
    #: Download status.
    state: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DownloadProgress:
        return cls(
            guid=str(json["guid"]),
            total_bytes=float(json["totalBytes"]),
            received_bytes=float(json["receivedBytes"]),
            state=str(json["state"]),
        )


@event_class("Page.interstitialHidden")
@dataclass
class InterstitialHidden:
    """
    Fired when interstitial page was hidden
    """


    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> InterstitialHidden:
        return cls(

        )


@event_class("Page.interstitialShown")
@dataclass
class InterstitialShown:
    """
    Fired when interstitial page was shown
    """


    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> InterstitialShown:
        return cls(

        )


@event_class("Page.javascriptDialogClosed")
@dataclass
class JavascriptDialogClosed:
    """
    Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
    closed.
    """
    #: Whether dialog was confirmed.
    result: bool
    #: User input in case of prompt.
    user_input: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> JavascriptDialogClosed:
        return cls(
            result=bool(json["result"]),
            user_input=str(json["userInput"]),
        )


@event_class("Page.javascriptDialogOpening")
@dataclass
class JavascriptDialogOpening:
    """
    Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
    open.
    """
    #: Frame url.
    url: str
    #: Message that will be displayed by the dialog.
    message: str
    #: Dialog type.
    type_: DialogType
    #: True iff browser is capable showing or acting on the given dialog. When browser has no
    #: dialog handler for given target, calling alert while Page domain is engaged will stall
    #: the page execution. Execution can be resumed via calling Page.handleJavaScriptDialog.
    has_browser_handler: bool
    #: Default dialog prompt.
    default_prompt: str | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> JavascriptDialogOpening:
        return cls(
            url=str(json["url"]),
            message=str(json["message"]),
            type_=DialogType.from_json(json["type"]),
            has_browser_handler=bool(json["hasBrowserHandler"]),
            default_prompt=str(json["defaultPrompt"]) if "defaultPrompt" in json else None,
        )


@event_class("Page.lifecycleEvent")
@dataclass
class LifecycleEvent:
    """
    Fired for lifecycle events (navigation, load, paint, etc) in the current
    target (including local frames).
    """
    #: Id of the frame.
    frame_id: FrameId
    #: Loader identifier. Empty string if the request is fetched from worker.
    loader_id: network.LoaderId
    name: str
    timestamp: network.MonotonicTime

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> LifecycleEvent:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
            loader_id=network.LoaderId.from_json(json["loaderId"]),
            name=str(json["name"]),
            timestamp=network.MonotonicTime.from_json(json["timestamp"]),
        )


@event_class("Page.backForwardCacheNotUsed")
@dataclass
class BackForwardCacheNotUsed:
    """
    **EXPERIMENTAL**

    Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do
    not assume any ordering with the Page.frameNavigated event. This event is fired only for
    main-frame history navigation where the document changes (non-same-document navigations),
    when bfcache navigation fails.
    """
    #: The loader id for the associated navigation.
    loader_id: network.LoaderId
    #: The frame id of the associated frame.
    frame_id: FrameId
    #: Array of reasons why the page could not be cached. This must not be empty.
    not_restored_explanations: list[BackForwardCacheNotRestoredExplanation]
    #: Tree structure of reasons why the page could not be cached for each frame.
    not_restored_explanations_tree: BackForwardCacheNotRestoredExplanationTree | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BackForwardCacheNotUsed:
        return cls(
            loader_id=network.LoaderId.from_json(json["loaderId"]),
            frame_id=FrameId.from_json(json["frameId"]),
            not_restored_explanations=[BackForwardCacheNotRestoredExplanation.from_json(i) for i in json["notRestoredExplanations"]],
            not_restored_explanations_tree=BackForwardCacheNotRestoredExplanationTree.from_json(json["notRestoredExplanationsTree"]) if "notRestoredExplanationsTree" in json else None,
        )


@event_class("Page.loadEventFired")
@dataclass
class LoadEventFired:
    timestamp: network.MonotonicTime

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> LoadEventFired:
        return cls(
            timestamp=network.MonotonicTime.from_json(json["timestamp"]),
        )


@event_class("Page.navigatedWithinDocument")
@dataclass
class NavigatedWithinDocument:
    """
    **EXPERIMENTAL**

    Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
    """
    #: Id of the frame.
    frame_id: FrameId
    #: Frame's new url.
    url: str
    #: Navigation type
    navigation_type: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> NavigatedWithinDocument:
        return cls(
            frame_id=FrameId.from_json(json["frameId"]),
            url=str(json["url"]),
            navigation_type=str(json["navigationType"]),
        )


@event_class("Page.screencastFrame")
@dataclass
class ScreencastFrame:
    """
    **EXPERIMENTAL**

    Compressed image data requested by the ``startScreencast``.
    """
    #: Base64-encoded compressed image. (Encoded as a base64 string when passed over JSON)
    data: str
    #: Screencast frame metadata.
    metadata: ScreencastFrameMetadata
    #: Frame number.
    session_id: int

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScreencastFrame:
        return cls(
            data=str(json["data"]),
            metadata=ScreencastFrameMetadata.from_json(json["metadata"]),
            session_id=int(json["sessionId"]),
        )


@event_class("Page.screencastVisibilityChanged")
@dataclass
class ScreencastVisibilityChanged:
    """
    **EXPERIMENTAL**

    Fired when the page with currently enabled screencast was shown or hidden .
    """
    #: True if the page is visible.
    visible: bool

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScreencastVisibilityChanged:
        return cls(
            visible=bool(json["visible"]),
        )


@event_class("Page.windowOpen")
@dataclass
class WindowOpen:
    """
    Fired when a new window is going to be opened, via window.open(), link click, form submission,
    etc.
    """
    #: The URL for the new window.
    url: str
    #: Window name.
    window_name: str
    #: An array of enabled window features.
    window_features: list[str]
    #: Whether or not it was triggered by user gesture.
    user_gesture: bool

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> WindowOpen:
        return cls(
            url=str(json["url"]),
            window_name=str(json["windowName"]),
            window_features=[str(i) for i in json["windowFeatures"]],
            user_gesture=bool(json["userGesture"]),
        )


@event_class("Page.compilationCacheProduced")
@dataclass
class CompilationCacheProduced:
    """
    **EXPERIMENTAL**

    Issued for every compilation cache generated. Is only available
    if Page.setGenerateCompilationCache is enabled.
    """
    url: str
    #: Base64-encoded data (Encoded as a base64 string when passed over JSON)
    data: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CompilationCacheProduced:
        return cls(
            url=str(json["url"]),
            data=str(json["data"]),
        )
