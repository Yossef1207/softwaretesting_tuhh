# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all modules.
#
# CDP version: v0.0.1438564
# CDP domain: DOM

from __future__ import annotations

import enum
from collections.abc import Generator
from dataclasses import dataclass
from typing import Any

import streamlink.webbrowser.cdp.devtools.page as page
import streamlink.webbrowser.cdp.devtools.runtime as runtime
from streamlink.webbrowser.cdp.devtools.util import T_JSON_DICT, event_class
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


class NodeId(int):
    """
    Unique DOM node identifier.
    """
    def to_json(self) -> int:
        return self

    @classmethod
    def from_json(cls, json: int) -> NodeId:
        return cls(json)

    def __repr__(self):
        return f"NodeId({super().__repr__()})"


class BackendNodeId(int):
    """
    Unique DOM node identifier used to reference a node that may not have been pushed to the
    front-end.
    """
    def to_json(self) -> int:
        return self

    @classmethod
    def from_json(cls, json: int) -> BackendNodeId:
        return cls(json)

    def __repr__(self):
        return f"BackendNodeId({super().__repr__()})"


@dataclass
class BackendNode:
    """
    Backend node with a friendly name.
    """
    #: ``Node``'s nodeType.
    node_type: int

    #: ``Node``'s nodeName.
    node_name: str

    backend_node_id: BackendNodeId

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["nodeType"] = self.node_type
        json["nodeName"] = self.node_name
        json["backendNodeId"] = self.backend_node_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BackendNode:
        return cls(
            node_type=int(json["nodeType"]),
            node_name=str(json["nodeName"]),
            backend_node_id=BackendNodeId.from_json(json["backendNodeId"]),
        )


class PseudoType(enum.Enum):
    """
    Pseudo element type.
    """
    FIRST_LINE = "first-line"
    FIRST_LETTER = "first-letter"
    CHECKMARK = "checkmark"
    BEFORE = "before"
    AFTER = "after"
    PICKER_ICON = "picker-icon"
    MARKER = "marker"
    BACKDROP = "backdrop"
    COLUMN = "column"
    SELECTION = "selection"
    SEARCH_TEXT = "search-text"
    TARGET_TEXT = "target-text"
    SPELLING_ERROR = "spelling-error"
    GRAMMAR_ERROR = "grammar-error"
    HIGHLIGHT = "highlight"
    FIRST_LINE_INHERITED = "first-line-inherited"
    SCROLL_MARKER = "scroll-marker"
    SCROLL_MARKER_GROUP = "scroll-marker-group"
    SCROLL_BUTTON = "scroll-button"
    SCROLLBAR = "scrollbar"
    SCROLLBAR_THUMB = "scrollbar-thumb"
    SCROLLBAR_BUTTON = "scrollbar-button"
    SCROLLBAR_TRACK = "scrollbar-track"
    SCROLLBAR_TRACK_PIECE = "scrollbar-track-piece"
    SCROLLBAR_CORNER = "scrollbar-corner"
    RESIZER = "resizer"
    INPUT_LIST_BUTTON = "input-list-button"
    VIEW_TRANSITION = "view-transition"
    VIEW_TRANSITION_GROUP = "view-transition-group"
    VIEW_TRANSITION_IMAGE_PAIR = "view-transition-image-pair"
    VIEW_TRANSITION_OLD = "view-transition-old"
    VIEW_TRANSITION_NEW = "view-transition-new"
    PLACEHOLDER = "placeholder"
    FILE_SELECTOR_BUTTON = "file-selector-button"
    DETAILS_CONTENT = "details-content"
    PICKER = "picker"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> PseudoType:
        return cls(json)


class ShadowRootType(enum.Enum):
    """
    Shadow root type.
    """
    USER_AGENT = "user-agent"
    OPEN_ = "open"
    CLOSED = "closed"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> ShadowRootType:
        return cls(json)


class CompatibilityMode(enum.Enum):
    """
    Document compatibility mode.
    """
    QUIRKS_MODE = "QuirksMode"
    LIMITED_QUIRKS_MODE = "LimitedQuirksMode"
    NO_QUIRKS_MODE = "NoQuirksMode"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> CompatibilityMode:
        return cls(json)


class PhysicalAxes(enum.Enum):
    """
    ContainerSelector physical axes
    """
    HORIZONTAL = "Horizontal"
    VERTICAL = "Vertical"
    BOTH = "Both"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> PhysicalAxes:
        return cls(json)


class LogicalAxes(enum.Enum):
    """
    ContainerSelector logical axes
    """
    INLINE = "Inline"
    BLOCK = "Block"
    BOTH = "Both"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> LogicalAxes:
        return cls(json)


class ScrollOrientation(enum.Enum):
    """
    Physical scroll orientation
    """
    HORIZONTAL = "horizontal"
    VERTICAL = "vertical"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> ScrollOrientation:
        return cls(json)


@dataclass
class Node:
    """
    DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
    DOMNode is a base node mirror type.
    """
    #: Node identifier that is passed into the rest of the DOM messages as the ``nodeId``. Backend
    #: will only push node with given ``id`` once. It is aware of all requested nodes and will only
    #: fire DOM events for nodes known to the client.
    node_id: NodeId

    #: The BackendNodeId for this node.
    backend_node_id: BackendNodeId

    #: ``Node``'s nodeType.
    node_type: int

    #: ``Node``'s nodeName.
    node_name: str

    #: ``Node``'s localName.
    local_name: str

    #: ``Node``'s nodeValue.
    node_value: str

    #: The id of the parent node if any.
    parent_id: NodeId | None = None

    #: Child count for ``Container`` nodes.
    child_node_count: int | None = None

    #: Child nodes of this node when requested with children.
    children: list[Node] | None = None

    #: Attributes of the ``Element`` node in the form of flat array ``[name1, value1, name2, value2]``.
    attributes: list[str] | None = None

    #: Document URL that ``Document`` or ``FrameOwner`` node points to.
    document_url: str | None = None

    #: Base URL that ``Document`` or ``FrameOwner`` node uses for URL completion.
    base_url: str | None = None

    #: ``DocumentType``'s publicId.
    public_id: str | None = None

    #: ``DocumentType``'s systemId.
    system_id: str | None = None

    #: ``DocumentType``'s internalSubset.
    internal_subset: str | None = None

    #: ``Document``'s XML version in case of XML documents.
    xml_version: str | None = None

    #: ``Attr``'s name.
    name: str | None = None

    #: ``Attr``'s value.
    value: str | None = None

    #: Pseudo element type for this node.
    pseudo_type: PseudoType | None = None

    #: Pseudo element identifier for this node. Only present if there is a
    #: valid pseudoType.
    pseudo_identifier: str | None = None

    #: Shadow root type.
    shadow_root_type: ShadowRootType | None = None

    #: Frame ID for frame owner elements.
    frame_id: page.FrameId | None = None

    #: Content document for frame owner elements.
    content_document: Node | None = None

    #: Shadow root list for given element host.
    shadow_roots: list[Node] | None = None

    #: Content document fragment for template elements.
    template_content: Node | None = None

    #: Pseudo elements associated with this node.
    pseudo_elements: list[Node] | None = None

    #: Deprecated, as the HTML Imports API has been removed (crbug.com/937746).
    #: This property used to return the imported document for the HTMLImport links.
    #: The property is always undefined now.
    imported_document: Node | None = None

    #: Distributed nodes for given insertion point.
    distributed_nodes: list[BackendNode] | None = None

    #: Whether the node is SVG.
    is_svg: bool | None = None

    compatibility_mode: CompatibilityMode | None = None

    assigned_slot: BackendNode | None = None

    is_scrollable: bool | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["nodeId"] = self.node_id.to_json()
        json["backendNodeId"] = self.backend_node_id.to_json()
        json["nodeType"] = self.node_type
        json["nodeName"] = self.node_name
        json["localName"] = self.local_name
        json["nodeValue"] = self.node_value
        if self.parent_id is not None:
            json["parentId"] = self.parent_id.to_json()
        if self.child_node_count is not None:
            json["childNodeCount"] = self.child_node_count
        if self.children is not None:
            json["children"] = [i.to_json() for i in self.children]
        if self.attributes is not None:
            json["attributes"] = list(self.attributes)
        if self.document_url is not None:
            json["documentURL"] = self.document_url
        if self.base_url is not None:
            json["baseURL"] = self.base_url
        if self.public_id is not None:
            json["publicId"] = self.public_id
        if self.system_id is not None:
            json["systemId"] = self.system_id
        if self.internal_subset is not None:
            json["internalSubset"] = self.internal_subset
        if self.xml_version is not None:
            json["xmlVersion"] = self.xml_version
        if self.name is not None:
            json["name"] = self.name
        if self.value is not None:
            json["value"] = self.value
        if self.pseudo_type is not None:
            json["pseudoType"] = self.pseudo_type.to_json()
        if self.pseudo_identifier is not None:
            json["pseudoIdentifier"] = self.pseudo_identifier
        if self.shadow_root_type is not None:
            json["shadowRootType"] = self.shadow_root_type.to_json()
        if self.frame_id is not None:
            json["frameId"] = self.frame_id.to_json()
        if self.content_document is not None:
            json["contentDocument"] = self.content_document.to_json()
        if self.shadow_roots is not None:
            json["shadowRoots"] = [i.to_json() for i in self.shadow_roots]
        if self.template_content is not None:
            json["templateContent"] = self.template_content.to_json()
        if self.pseudo_elements is not None:
            json["pseudoElements"] = [i.to_json() for i in self.pseudo_elements]
        if self.imported_document is not None:
            json["importedDocument"] = self.imported_document.to_json()
        if self.distributed_nodes is not None:
            json["distributedNodes"] = [i.to_json() for i in self.distributed_nodes]
        if self.is_svg is not None:
            json["isSVG"] = self.is_svg
        if self.compatibility_mode is not None:
            json["compatibilityMode"] = self.compatibility_mode.to_json()
        if self.assigned_slot is not None:
            json["assignedSlot"] = self.assigned_slot.to_json()
        if self.is_scrollable is not None:
            json["isScrollable"] = self.is_scrollable
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Node:
        return cls(
            node_id=NodeId.from_json(json["nodeId"]),
            backend_node_id=BackendNodeId.from_json(json["backendNodeId"]),
            node_type=int(json["nodeType"]),
            node_name=str(json["nodeName"]),
            local_name=str(json["localName"]),
            node_value=str(json["nodeValue"]),
            parent_id=NodeId.from_json(json["parentId"]) if "parentId" in json else None,
            child_node_count=int(json["childNodeCount"]) if "childNodeCount" in json else None,
            children=[Node.from_json(i) for i in json["children"]] if "children" in json else None,
            attributes=[str(i) for i in json["attributes"]] if "attributes" in json else None,
            document_url=str(json["documentURL"]) if "documentURL" in json else None,
            base_url=str(json["baseURL"]) if "baseURL" in json else None,
            public_id=str(json["publicId"]) if "publicId" in json else None,
            system_id=str(json["systemId"]) if "systemId" in json else None,
            internal_subset=str(json["internalSubset"]) if "internalSubset" in json else None,
            xml_version=str(json["xmlVersion"]) if "xmlVersion" in json else None,
            name=str(json["name"]) if "name" in json else None,
            value=str(json["value"]) if "value" in json else None,
            pseudo_type=PseudoType.from_json(json["pseudoType"]) if "pseudoType" in json else None,
            pseudo_identifier=str(json["pseudoIdentifier"]) if "pseudoIdentifier" in json else None,
            shadow_root_type=ShadowRootType.from_json(json["shadowRootType"]) if "shadowRootType" in json else None,
            frame_id=page.FrameId.from_json(json["frameId"]) if "frameId" in json else None,
            content_document=Node.from_json(json["contentDocument"]) if "contentDocument" in json else None,
            shadow_roots=[Node.from_json(i) for i in json["shadowRoots"]] if "shadowRoots" in json else None,
            template_content=Node.from_json(json["templateContent"]) if "templateContent" in json else None,
            pseudo_elements=[Node.from_json(i) for i in json["pseudoElements"]] if "pseudoElements" in json else None,
            imported_document=Node.from_json(json["importedDocument"]) if "importedDocument" in json else None,
            distributed_nodes=[BackendNode.from_json(i) for i in json["distributedNodes"]] if "distributedNodes" in json else None,
            is_svg=bool(json["isSVG"]) if "isSVG" in json else None,
            compatibility_mode=CompatibilityMode.from_json(json["compatibilityMode"]) if "compatibilityMode" in json else None,
            assigned_slot=BackendNode.from_json(json["assignedSlot"]) if "assignedSlot" in json else None,
            is_scrollable=bool(json["isScrollable"]) if "isScrollable" in json else None,
        )


@dataclass
class DetachedElementInfo:
    """
    A structure to hold the top-level node of a detached tree and an array of its retained descendants.
    """
    tree_node: Node

    retained_node_ids: list[NodeId]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["treeNode"] = self.tree_node.to_json()
        json["retainedNodeIds"] = [i.to_json() for i in self.retained_node_ids]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DetachedElementInfo:
        return cls(
            tree_node=Node.from_json(json["treeNode"]),
            retained_node_ids=[NodeId.from_json(i) for i in json["retainedNodeIds"]],
        )


@dataclass
class RGBA:
    """
    A structure holding an RGBA color.
    """
    #: The red component, in the [0-255] range.
    r: int

    #: The green component, in the [0-255] range.
    g: int

    #: The blue component, in the [0-255] range.
    b: int

    #: The alpha component, in the [0-1] range (default: 1).
    a: float | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["r"] = self.r
        json["g"] = self.g
        json["b"] = self.b
        if self.a is not None:
            json["a"] = self.a
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> RGBA:
        return cls(
            r=int(json["r"]),
            g=int(json["g"]),
            b=int(json["b"]),
            a=float(json["a"]) if "a" in json else None,
        )


class Quad(list):
    """
    An array of quad vertices, x immediately followed by y for each point, points clock-wise.
    """
    def to_json(self) -> list[float]:
        return self

    @classmethod
    def from_json(cls, json: list[float]) -> Quad:
        return cls(json)

    def __repr__(self):
        return f"Quad({super().__repr__()})"


@dataclass
class BoxModel:
    """
    Box model.
    """
    #: Content box
    content: Quad

    #: Padding box
    padding: Quad

    #: Border box
    border: Quad

    #: Margin box
    margin: Quad

    #: Node width
    width: int

    #: Node height
    height: int

    #: Shape outside coordinates
    shape_outside: ShapeOutsideInfo | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["content"] = self.content.to_json()
        json["padding"] = self.padding.to_json()
        json["border"] = self.border.to_json()
        json["margin"] = self.margin.to_json()
        json["width"] = self.width
        json["height"] = self.height
        if self.shape_outside is not None:
            json["shapeOutside"] = self.shape_outside.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BoxModel:
        return cls(
            content=Quad.from_json(json["content"]),
            padding=Quad.from_json(json["padding"]),
            border=Quad.from_json(json["border"]),
            margin=Quad.from_json(json["margin"]),
            width=int(json["width"]),
            height=int(json["height"]),
            shape_outside=ShapeOutsideInfo.from_json(json["shapeOutside"]) if "shapeOutside" in json else None,
        )


@dataclass
class ShapeOutsideInfo:
    """
    CSS Shape Outside details.
    """
    #: Shape bounds
    bounds: Quad

    #: Shape coordinate details
    shape: list[Any]

    #: Margin shape bounds
    margin_shape: list[Any]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["bounds"] = self.bounds.to_json()
        json["shape"] = list(self.shape)
        json["marginShape"] = list(self.margin_shape)
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ShapeOutsideInfo:
        return cls(
            bounds=Quad.from_json(json["bounds"]),
            shape=list(json["shape"]),
            margin_shape=list(json["marginShape"]),
        )


@dataclass
class Rect:
    """
    Rectangle.
    """
    #: X coordinate
    x: float

    #: Y coordinate
    y: float

    #: Rectangle width
    width: float

    #: Rectangle height
    height: float

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["x"] = self.x
        json["y"] = self.y
        json["width"] = self.width
        json["height"] = self.height
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Rect:
        return cls(
            x=float(json["x"]),
            y=float(json["y"]),
            width=float(json["width"]),
            height=float(json["height"]),
        )


@dataclass
class CSSComputedStyleProperty:
    #: Computed style property name.
    name: str

    #: Computed style property value.
    value: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["name"] = self.name
        json["value"] = self.value
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSComputedStyleProperty:
        return cls(
            name=str(json["name"]),
            value=str(json["value"]),
        )


def x_collect_class_names_from_subtree__mutmut_orig(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_1(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_2(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_3(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_4(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_5(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_6(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_7(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_8(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_9(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_10(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_11(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.collectClassNamesFromSubtreeXX",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_12(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.collectclassnamesfromsubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_13(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.COLLECTCLASSNAMESFROMSUBTREE",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_14(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.collectclassnamesfromsubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_15(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_16(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_17(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "Params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_18(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = None
    return [str(i) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_19(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(None) for i in json["classNames"]]


def x_collect_class_names_from_subtree__mutmut_20(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["XXclassNamesXX"]]


def x_collect_class_names_from_subtree__mutmut_21(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["classnames"]]


def x_collect_class_names_from_subtree__mutmut_22(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["CLASSNAMES"]]


def x_collect_class_names_from_subtree__mutmut_23(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Collects class names for the node with given id and all of it's child nodes.

    **EXPERIMENTAL**

    :param node_id: Id of the node to collect class names.
    :returns: Class name list.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.collectClassNamesFromSubtree",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["Classnames"]]

x_collect_class_names_from_subtree__mutmut_mutants : ClassVar[MutantDict] = {
'x_collect_class_names_from_subtree__mutmut_1': x_collect_class_names_from_subtree__mutmut_1, 
    'x_collect_class_names_from_subtree__mutmut_2': x_collect_class_names_from_subtree__mutmut_2, 
    'x_collect_class_names_from_subtree__mutmut_3': x_collect_class_names_from_subtree__mutmut_3, 
    'x_collect_class_names_from_subtree__mutmut_4': x_collect_class_names_from_subtree__mutmut_4, 
    'x_collect_class_names_from_subtree__mutmut_5': x_collect_class_names_from_subtree__mutmut_5, 
    'x_collect_class_names_from_subtree__mutmut_6': x_collect_class_names_from_subtree__mutmut_6, 
    'x_collect_class_names_from_subtree__mutmut_7': x_collect_class_names_from_subtree__mutmut_7, 
    'x_collect_class_names_from_subtree__mutmut_8': x_collect_class_names_from_subtree__mutmut_8, 
    'x_collect_class_names_from_subtree__mutmut_9': x_collect_class_names_from_subtree__mutmut_9, 
    'x_collect_class_names_from_subtree__mutmut_10': x_collect_class_names_from_subtree__mutmut_10, 
    'x_collect_class_names_from_subtree__mutmut_11': x_collect_class_names_from_subtree__mutmut_11, 
    'x_collect_class_names_from_subtree__mutmut_12': x_collect_class_names_from_subtree__mutmut_12, 
    'x_collect_class_names_from_subtree__mutmut_13': x_collect_class_names_from_subtree__mutmut_13, 
    'x_collect_class_names_from_subtree__mutmut_14': x_collect_class_names_from_subtree__mutmut_14, 
    'x_collect_class_names_from_subtree__mutmut_15': x_collect_class_names_from_subtree__mutmut_15, 
    'x_collect_class_names_from_subtree__mutmut_16': x_collect_class_names_from_subtree__mutmut_16, 
    'x_collect_class_names_from_subtree__mutmut_17': x_collect_class_names_from_subtree__mutmut_17, 
    'x_collect_class_names_from_subtree__mutmut_18': x_collect_class_names_from_subtree__mutmut_18, 
    'x_collect_class_names_from_subtree__mutmut_19': x_collect_class_names_from_subtree__mutmut_19, 
    'x_collect_class_names_from_subtree__mutmut_20': x_collect_class_names_from_subtree__mutmut_20, 
    'x_collect_class_names_from_subtree__mutmut_21': x_collect_class_names_from_subtree__mutmut_21, 
    'x_collect_class_names_from_subtree__mutmut_22': x_collect_class_names_from_subtree__mutmut_22, 
    'x_collect_class_names_from_subtree__mutmut_23': x_collect_class_names_from_subtree__mutmut_23
}

def collect_class_names_from_subtree(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_collect_class_names_from_subtree__mutmut_orig, x_collect_class_names_from_subtree__mutmut_mutants, args, kwargs)
    return result 

collect_class_names_from_subtree.__signature__ = _mutmut_signature(x_collect_class_names_from_subtree__mutmut_orig)
x_collect_class_names_from_subtree__mutmut_orig.__name__ = 'x_collect_class_names_from_subtree'


def x_copy_to__mutmut_orig(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_1(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_2(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_3(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_4(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_5(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_6(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_7(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = None
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_8(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXtargetNodeIdXX"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_9(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetnodeid"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_10(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["TARGETNODEID"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_11(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Targetnodeid"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_12(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_13(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_14(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["XXinsertBeforeNodeIdXX"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_15(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertbeforenodeid"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_16(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["INSERTBEFORENODEID"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_17(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["Insertbeforenodeid"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_18(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_19(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_20(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_21(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_22(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.copyToXX",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_23(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.copyto",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_24(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.COPYTO",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_25(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.copyto",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_26(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_27(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_28(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "Params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_29(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = None
    return NodeId.from_json(json["nodeId"])


def x_copy_to__mutmut_30(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(None)


def x_copy_to__mutmut_31(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["XXnodeIdXX"])


def x_copy_to__mutmut_32(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeid"])


def x_copy_to__mutmut_33(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["NODEID"])


def x_copy_to__mutmut_34(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Creates a deep copy of the specified node and places it into the target container before the
    given anchor.

    **EXPERIMENTAL**

    :param node_id: Id of the node to copy.
    :param target_node_id: Id of the element to drop the copy into.
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```).
    :returns: Id of the node clone.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.copyTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["Nodeid"])

x_copy_to__mutmut_mutants : ClassVar[MutantDict] = {
'x_copy_to__mutmut_1': x_copy_to__mutmut_1, 
    'x_copy_to__mutmut_2': x_copy_to__mutmut_2, 
    'x_copy_to__mutmut_3': x_copy_to__mutmut_3, 
    'x_copy_to__mutmut_4': x_copy_to__mutmut_4, 
    'x_copy_to__mutmut_5': x_copy_to__mutmut_5, 
    'x_copy_to__mutmut_6': x_copy_to__mutmut_6, 
    'x_copy_to__mutmut_7': x_copy_to__mutmut_7, 
    'x_copy_to__mutmut_8': x_copy_to__mutmut_8, 
    'x_copy_to__mutmut_9': x_copy_to__mutmut_9, 
    'x_copy_to__mutmut_10': x_copy_to__mutmut_10, 
    'x_copy_to__mutmut_11': x_copy_to__mutmut_11, 
    'x_copy_to__mutmut_12': x_copy_to__mutmut_12, 
    'x_copy_to__mutmut_13': x_copy_to__mutmut_13, 
    'x_copy_to__mutmut_14': x_copy_to__mutmut_14, 
    'x_copy_to__mutmut_15': x_copy_to__mutmut_15, 
    'x_copy_to__mutmut_16': x_copy_to__mutmut_16, 
    'x_copy_to__mutmut_17': x_copy_to__mutmut_17, 
    'x_copy_to__mutmut_18': x_copy_to__mutmut_18, 
    'x_copy_to__mutmut_19': x_copy_to__mutmut_19, 
    'x_copy_to__mutmut_20': x_copy_to__mutmut_20, 
    'x_copy_to__mutmut_21': x_copy_to__mutmut_21, 
    'x_copy_to__mutmut_22': x_copy_to__mutmut_22, 
    'x_copy_to__mutmut_23': x_copy_to__mutmut_23, 
    'x_copy_to__mutmut_24': x_copy_to__mutmut_24, 
    'x_copy_to__mutmut_25': x_copy_to__mutmut_25, 
    'x_copy_to__mutmut_26': x_copy_to__mutmut_26, 
    'x_copy_to__mutmut_27': x_copy_to__mutmut_27, 
    'x_copy_to__mutmut_28': x_copy_to__mutmut_28, 
    'x_copy_to__mutmut_29': x_copy_to__mutmut_29, 
    'x_copy_to__mutmut_30': x_copy_to__mutmut_30, 
    'x_copy_to__mutmut_31': x_copy_to__mutmut_31, 
    'x_copy_to__mutmut_32': x_copy_to__mutmut_32, 
    'x_copy_to__mutmut_33': x_copy_to__mutmut_33, 
    'x_copy_to__mutmut_34': x_copy_to__mutmut_34
}

def copy_to(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_copy_to__mutmut_orig, x_copy_to__mutmut_mutants, args, kwargs)
    return result 

copy_to.__signature__ = _mutmut_signature(x_copy_to__mutmut_orig)
x_copy_to__mutmut_orig.__name__ = 'x_copy_to'


def x_describe_node__mutmut_orig(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_1(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = None
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_2(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_3(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = None
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_4(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["XXnodeIdXX"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_5(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_6(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["NODEID"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_7(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["Nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_8(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_9(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = None
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_10(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["XXbackendNodeIdXX"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_11(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_12(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["BACKENDNODEID"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_13(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["Backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_14(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_15(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = None
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_16(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["XXobjectIdXX"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_17(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectid"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_18(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["OBJECTID"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_19(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["Objectid"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_20(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_21(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = None
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_22(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["XXdepthXX"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_23(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["DEPTH"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_24(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["Depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_25(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_26(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_27(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["XXpierceXX"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_28(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["PIERCE"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_29(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["Pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_30(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_31(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_32(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_33(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_34(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.describeNodeXX",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_35(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "dom.describenode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_36(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.DESCRIBENODE",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_37(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.describenode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_38(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_39(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_40(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "Params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["node"])


def x_describe_node__mutmut_41(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = None
    return Node.from_json(json["node"])


def x_describe_node__mutmut_42(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(None)


def x_describe_node__mutmut_43(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["XXnodeXX"])


def x_describe_node__mutmut_44(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["NODE"])


def x_describe_node__mutmut_45(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Describes node given its id, does not require domain to be enabled. Does not start tracking any
    objects, can be used for automation.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Node description.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.describeNode",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["Node"])

x_describe_node__mutmut_mutants : ClassVar[MutantDict] = {
'x_describe_node__mutmut_1': x_describe_node__mutmut_1, 
    'x_describe_node__mutmut_2': x_describe_node__mutmut_2, 
    'x_describe_node__mutmut_3': x_describe_node__mutmut_3, 
    'x_describe_node__mutmut_4': x_describe_node__mutmut_4, 
    'x_describe_node__mutmut_5': x_describe_node__mutmut_5, 
    'x_describe_node__mutmut_6': x_describe_node__mutmut_6, 
    'x_describe_node__mutmut_7': x_describe_node__mutmut_7, 
    'x_describe_node__mutmut_8': x_describe_node__mutmut_8, 
    'x_describe_node__mutmut_9': x_describe_node__mutmut_9, 
    'x_describe_node__mutmut_10': x_describe_node__mutmut_10, 
    'x_describe_node__mutmut_11': x_describe_node__mutmut_11, 
    'x_describe_node__mutmut_12': x_describe_node__mutmut_12, 
    'x_describe_node__mutmut_13': x_describe_node__mutmut_13, 
    'x_describe_node__mutmut_14': x_describe_node__mutmut_14, 
    'x_describe_node__mutmut_15': x_describe_node__mutmut_15, 
    'x_describe_node__mutmut_16': x_describe_node__mutmut_16, 
    'x_describe_node__mutmut_17': x_describe_node__mutmut_17, 
    'x_describe_node__mutmut_18': x_describe_node__mutmut_18, 
    'x_describe_node__mutmut_19': x_describe_node__mutmut_19, 
    'x_describe_node__mutmut_20': x_describe_node__mutmut_20, 
    'x_describe_node__mutmut_21': x_describe_node__mutmut_21, 
    'x_describe_node__mutmut_22': x_describe_node__mutmut_22, 
    'x_describe_node__mutmut_23': x_describe_node__mutmut_23, 
    'x_describe_node__mutmut_24': x_describe_node__mutmut_24, 
    'x_describe_node__mutmut_25': x_describe_node__mutmut_25, 
    'x_describe_node__mutmut_26': x_describe_node__mutmut_26, 
    'x_describe_node__mutmut_27': x_describe_node__mutmut_27, 
    'x_describe_node__mutmut_28': x_describe_node__mutmut_28, 
    'x_describe_node__mutmut_29': x_describe_node__mutmut_29, 
    'x_describe_node__mutmut_30': x_describe_node__mutmut_30, 
    'x_describe_node__mutmut_31': x_describe_node__mutmut_31, 
    'x_describe_node__mutmut_32': x_describe_node__mutmut_32, 
    'x_describe_node__mutmut_33': x_describe_node__mutmut_33, 
    'x_describe_node__mutmut_34': x_describe_node__mutmut_34, 
    'x_describe_node__mutmut_35': x_describe_node__mutmut_35, 
    'x_describe_node__mutmut_36': x_describe_node__mutmut_36, 
    'x_describe_node__mutmut_37': x_describe_node__mutmut_37, 
    'x_describe_node__mutmut_38': x_describe_node__mutmut_38, 
    'x_describe_node__mutmut_39': x_describe_node__mutmut_39, 
    'x_describe_node__mutmut_40': x_describe_node__mutmut_40, 
    'x_describe_node__mutmut_41': x_describe_node__mutmut_41, 
    'x_describe_node__mutmut_42': x_describe_node__mutmut_42, 
    'x_describe_node__mutmut_43': x_describe_node__mutmut_43, 
    'x_describe_node__mutmut_44': x_describe_node__mutmut_44, 
    'x_describe_node__mutmut_45': x_describe_node__mutmut_45
}

def describe_node(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_describe_node__mutmut_orig, x_describe_node__mutmut_mutants, args, kwargs)
    return result 

describe_node.__signature__ = _mutmut_signature(x_describe_node__mutmut_orig)
x_describe_node__mutmut_orig.__name__ = 'x_describe_node'


def x_scroll_into_view_if_needed__mutmut_orig(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_1(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = None
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_2(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_3(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = None
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_4(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["XXnodeIdXX"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_5(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_6(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["NODEID"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_7(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["Nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_8(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_9(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = None
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_10(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["XXbackendNodeIdXX"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_11(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_12(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["BACKENDNODEID"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_13(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["Backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_14(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_15(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = None
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_16(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["XXobjectIdXX"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_17(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectid"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_18(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["OBJECTID"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_19(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["Objectid"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_20(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_21(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_22(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["XXrectXX"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_23(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["RECT"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_24(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["Rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_25(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_26(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_27(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_28(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.scrollIntoViewIfNeeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_29(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.scrollIntoViewIfNeededXX",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_30(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.scrollintoviewifneeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_31(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.SCROLLINTOVIEWIFNEEDED",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_32(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.scrollintoviewifneeded",
        "params": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_33(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_34(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "PARAMS": params,
    }
    yield cmd_dict


def x_scroll_into_view_if_needed__mutmut_35(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
    rect: Rect | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Scrolls the specified rect of the given node into view if not already visible.
    Note: exactly one between nodeId, backendNodeId and objectId should be passed
    to identify the node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if rect is not None:
        params["rect"] = rect.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.scrollIntoViewIfNeeded",
        "Params": params,
    }
    yield cmd_dict

x_scroll_into_view_if_needed__mutmut_mutants : ClassVar[MutantDict] = {
'x_scroll_into_view_if_needed__mutmut_1': x_scroll_into_view_if_needed__mutmut_1, 
    'x_scroll_into_view_if_needed__mutmut_2': x_scroll_into_view_if_needed__mutmut_2, 
    'x_scroll_into_view_if_needed__mutmut_3': x_scroll_into_view_if_needed__mutmut_3, 
    'x_scroll_into_view_if_needed__mutmut_4': x_scroll_into_view_if_needed__mutmut_4, 
    'x_scroll_into_view_if_needed__mutmut_5': x_scroll_into_view_if_needed__mutmut_5, 
    'x_scroll_into_view_if_needed__mutmut_6': x_scroll_into_view_if_needed__mutmut_6, 
    'x_scroll_into_view_if_needed__mutmut_7': x_scroll_into_view_if_needed__mutmut_7, 
    'x_scroll_into_view_if_needed__mutmut_8': x_scroll_into_view_if_needed__mutmut_8, 
    'x_scroll_into_view_if_needed__mutmut_9': x_scroll_into_view_if_needed__mutmut_9, 
    'x_scroll_into_view_if_needed__mutmut_10': x_scroll_into_view_if_needed__mutmut_10, 
    'x_scroll_into_view_if_needed__mutmut_11': x_scroll_into_view_if_needed__mutmut_11, 
    'x_scroll_into_view_if_needed__mutmut_12': x_scroll_into_view_if_needed__mutmut_12, 
    'x_scroll_into_view_if_needed__mutmut_13': x_scroll_into_view_if_needed__mutmut_13, 
    'x_scroll_into_view_if_needed__mutmut_14': x_scroll_into_view_if_needed__mutmut_14, 
    'x_scroll_into_view_if_needed__mutmut_15': x_scroll_into_view_if_needed__mutmut_15, 
    'x_scroll_into_view_if_needed__mutmut_16': x_scroll_into_view_if_needed__mutmut_16, 
    'x_scroll_into_view_if_needed__mutmut_17': x_scroll_into_view_if_needed__mutmut_17, 
    'x_scroll_into_view_if_needed__mutmut_18': x_scroll_into_view_if_needed__mutmut_18, 
    'x_scroll_into_view_if_needed__mutmut_19': x_scroll_into_view_if_needed__mutmut_19, 
    'x_scroll_into_view_if_needed__mutmut_20': x_scroll_into_view_if_needed__mutmut_20, 
    'x_scroll_into_view_if_needed__mutmut_21': x_scroll_into_view_if_needed__mutmut_21, 
    'x_scroll_into_view_if_needed__mutmut_22': x_scroll_into_view_if_needed__mutmut_22, 
    'x_scroll_into_view_if_needed__mutmut_23': x_scroll_into_view_if_needed__mutmut_23, 
    'x_scroll_into_view_if_needed__mutmut_24': x_scroll_into_view_if_needed__mutmut_24, 
    'x_scroll_into_view_if_needed__mutmut_25': x_scroll_into_view_if_needed__mutmut_25, 
    'x_scroll_into_view_if_needed__mutmut_26': x_scroll_into_view_if_needed__mutmut_26, 
    'x_scroll_into_view_if_needed__mutmut_27': x_scroll_into_view_if_needed__mutmut_27, 
    'x_scroll_into_view_if_needed__mutmut_28': x_scroll_into_view_if_needed__mutmut_28, 
    'x_scroll_into_view_if_needed__mutmut_29': x_scroll_into_view_if_needed__mutmut_29, 
    'x_scroll_into_view_if_needed__mutmut_30': x_scroll_into_view_if_needed__mutmut_30, 
    'x_scroll_into_view_if_needed__mutmut_31': x_scroll_into_view_if_needed__mutmut_31, 
    'x_scroll_into_view_if_needed__mutmut_32': x_scroll_into_view_if_needed__mutmut_32, 
    'x_scroll_into_view_if_needed__mutmut_33': x_scroll_into_view_if_needed__mutmut_33, 
    'x_scroll_into_view_if_needed__mutmut_34': x_scroll_into_view_if_needed__mutmut_34, 
    'x_scroll_into_view_if_needed__mutmut_35': x_scroll_into_view_if_needed__mutmut_35
}

def scroll_into_view_if_needed(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_scroll_into_view_if_needed__mutmut_orig, x_scroll_into_view_if_needed__mutmut_mutants, args, kwargs)
    return result 

scroll_into_view_if_needed.__signature__ = _mutmut_signature(x_scroll_into_view_if_needed__mutmut_orig)
x_scroll_into_view_if_needed__mutmut_orig.__name__ = 'x_scroll_into_view_if_needed'


def x_disable__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables DOM agent for the given page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.disable",
    }
    yield cmd_dict


def x_disable__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables DOM agent for the given page.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_disable__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables DOM agent for the given page.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.disable",
    }
    yield cmd_dict


def x_disable__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables DOM agent for the given page.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.disable",
    }
    yield cmd_dict


def x_disable__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables DOM agent for the given page.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.disable",
    }
    yield cmd_dict


def x_disable__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables DOM agent for the given page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.disableXX",
    }
    yield cmd_dict


def x_disable__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables DOM agent for the given page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "dom.disable",
    }
    yield cmd_dict


def x_disable__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables DOM agent for the given page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.DISABLE",
    }
    yield cmd_dict


def x_disable__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables DOM agent for the given page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.disable",
    }
    yield cmd_dict

x_disable__mutmut_mutants : ClassVar[MutantDict] = {
'x_disable__mutmut_1': x_disable__mutmut_1, 
    'x_disable__mutmut_2': x_disable__mutmut_2, 
    'x_disable__mutmut_3': x_disable__mutmut_3, 
    'x_disable__mutmut_4': x_disable__mutmut_4, 
    'x_disable__mutmut_5': x_disable__mutmut_5, 
    'x_disable__mutmut_6': x_disable__mutmut_6, 
    'x_disable__mutmut_7': x_disable__mutmut_7, 
    'x_disable__mutmut_8': x_disable__mutmut_8
}

def disable(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_disable__mutmut_orig, x_disable__mutmut_mutants, args, kwargs)
    return result 

disable.__signature__ = _mutmut_signature(x_disable__mutmut_orig)
x_disable__mutmut_orig.__name__ = 'x_disable'


def x_discard_search_results__mutmut_orig(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.discardSearchResults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_1(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = None
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.discardSearchResults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_2(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.discardSearchResults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_3(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["XXsearchIdXX"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.discardSearchResults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_4(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchid"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.discardSearchResults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_5(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["SEARCHID"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.discardSearchResults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_6(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["Searchid"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.discardSearchResults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_7(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_discard_search_results__mutmut_8(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.discardSearchResults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_9(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.discardSearchResults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_10(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.discardSearchResults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_11(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.discardSearchResultsXX",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_12(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "dom.discardsearchresults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_13(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.DISCARDSEARCHRESULTS",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_14(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.discardsearchresults",
        "params": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_15(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.discardSearchResults",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_16(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.discardSearchResults",
        "PARAMS": params,
    }
    yield cmd_dict


def x_discard_search_results__mutmut_17(
    search_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards search results from the session with the given id. ``getSearchResults`` should no longer
    be called for that search.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.discardSearchResults",
        "Params": params,
    }
    yield cmd_dict

x_discard_search_results__mutmut_mutants : ClassVar[MutantDict] = {
'x_discard_search_results__mutmut_1': x_discard_search_results__mutmut_1, 
    'x_discard_search_results__mutmut_2': x_discard_search_results__mutmut_2, 
    'x_discard_search_results__mutmut_3': x_discard_search_results__mutmut_3, 
    'x_discard_search_results__mutmut_4': x_discard_search_results__mutmut_4, 
    'x_discard_search_results__mutmut_5': x_discard_search_results__mutmut_5, 
    'x_discard_search_results__mutmut_6': x_discard_search_results__mutmut_6, 
    'x_discard_search_results__mutmut_7': x_discard_search_results__mutmut_7, 
    'x_discard_search_results__mutmut_8': x_discard_search_results__mutmut_8, 
    'x_discard_search_results__mutmut_9': x_discard_search_results__mutmut_9, 
    'x_discard_search_results__mutmut_10': x_discard_search_results__mutmut_10, 
    'x_discard_search_results__mutmut_11': x_discard_search_results__mutmut_11, 
    'x_discard_search_results__mutmut_12': x_discard_search_results__mutmut_12, 
    'x_discard_search_results__mutmut_13': x_discard_search_results__mutmut_13, 
    'x_discard_search_results__mutmut_14': x_discard_search_results__mutmut_14, 
    'x_discard_search_results__mutmut_15': x_discard_search_results__mutmut_15, 
    'x_discard_search_results__mutmut_16': x_discard_search_results__mutmut_16, 
    'x_discard_search_results__mutmut_17': x_discard_search_results__mutmut_17
}

def discard_search_results(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_discard_search_results__mutmut_orig, x_discard_search_results__mutmut_mutants, args, kwargs)
    return result 

discard_search_results.__signature__ = _mutmut_signature(x_discard_search_results__mutmut_orig)
x_discard_search_results__mutmut_orig.__name__ = 'x_discard_search_results'


def x_enable__mutmut_orig(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_1(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = None
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_2(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_3(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_4(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["XXincludeWhitespaceXX"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_5(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includewhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_6(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["INCLUDEWHITESPACE"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_7(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["Includewhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_8(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_enable__mutmut_9(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_10(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_11(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_12(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.enableXX",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_13(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "dom.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_14(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.ENABLE",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_15(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.enable",
        "params": params,
    }
    yield cmd_dict


def x_enable__mutmut_16(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.enable",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_enable__mutmut_17(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.enable",
        "PARAMS": params,
    }
    yield cmd_dict


def x_enable__mutmut_18(
    include_whitespace: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables DOM agent for the given page.

    :param include_whitespace: **(EXPERIMENTAL)** *(Optional)* Whether to include whitespaces in the children array of returned Nodes.
    """
    params: T_JSON_DICT = {}
    if include_whitespace is not None:
        params["includeWhitespace"] = include_whitespace
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.enable",
        "Params": params,
    }
    yield cmd_dict

x_enable__mutmut_mutants : ClassVar[MutantDict] = {
'x_enable__mutmut_1': x_enable__mutmut_1, 
    'x_enable__mutmut_2': x_enable__mutmut_2, 
    'x_enable__mutmut_3': x_enable__mutmut_3, 
    'x_enable__mutmut_4': x_enable__mutmut_4, 
    'x_enable__mutmut_5': x_enable__mutmut_5, 
    'x_enable__mutmut_6': x_enable__mutmut_6, 
    'x_enable__mutmut_7': x_enable__mutmut_7, 
    'x_enable__mutmut_8': x_enable__mutmut_8, 
    'x_enable__mutmut_9': x_enable__mutmut_9, 
    'x_enable__mutmut_10': x_enable__mutmut_10, 
    'x_enable__mutmut_11': x_enable__mutmut_11, 
    'x_enable__mutmut_12': x_enable__mutmut_12, 
    'x_enable__mutmut_13': x_enable__mutmut_13, 
    'x_enable__mutmut_14': x_enable__mutmut_14, 
    'x_enable__mutmut_15': x_enable__mutmut_15, 
    'x_enable__mutmut_16': x_enable__mutmut_16, 
    'x_enable__mutmut_17': x_enable__mutmut_17, 
    'x_enable__mutmut_18': x_enable__mutmut_18
}

def enable(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_enable__mutmut_orig, x_enable__mutmut_mutants, args, kwargs)
    return result 

enable.__signature__ = _mutmut_signature(x_enable__mutmut_orig)
x_enable__mutmut_orig.__name__ = 'x_enable'


def x_focus__mutmut_orig(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_1(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = None
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_2(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_3(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = None
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_4(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["XXnodeIdXX"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_5(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_6(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["NODEID"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_7(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["Nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_8(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_9(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = None
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_10(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["XXbackendNodeIdXX"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_11(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_12(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["BACKENDNODEID"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_13(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["Backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_14(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_15(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_16(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["XXobjectIdXX"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_17(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_18(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["OBJECTID"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_19(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["Objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_20(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_focus__mutmut_21(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_22(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_23(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_24(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.focusXX",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_25(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_26(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.FOCUS",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_27(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.focus",
        "params": params,
    }
    yield cmd_dict


def x_focus__mutmut_28(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_focus__mutmut_29(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "PARAMS": params,
    }
    yield cmd_dict


def x_focus__mutmut_30(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Focuses the given element.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.focus",
        "Params": params,
    }
    yield cmd_dict

x_focus__mutmut_mutants : ClassVar[MutantDict] = {
'x_focus__mutmut_1': x_focus__mutmut_1, 
    'x_focus__mutmut_2': x_focus__mutmut_2, 
    'x_focus__mutmut_3': x_focus__mutmut_3, 
    'x_focus__mutmut_4': x_focus__mutmut_4, 
    'x_focus__mutmut_5': x_focus__mutmut_5, 
    'x_focus__mutmut_6': x_focus__mutmut_6, 
    'x_focus__mutmut_7': x_focus__mutmut_7, 
    'x_focus__mutmut_8': x_focus__mutmut_8, 
    'x_focus__mutmut_9': x_focus__mutmut_9, 
    'x_focus__mutmut_10': x_focus__mutmut_10, 
    'x_focus__mutmut_11': x_focus__mutmut_11, 
    'x_focus__mutmut_12': x_focus__mutmut_12, 
    'x_focus__mutmut_13': x_focus__mutmut_13, 
    'x_focus__mutmut_14': x_focus__mutmut_14, 
    'x_focus__mutmut_15': x_focus__mutmut_15, 
    'x_focus__mutmut_16': x_focus__mutmut_16, 
    'x_focus__mutmut_17': x_focus__mutmut_17, 
    'x_focus__mutmut_18': x_focus__mutmut_18, 
    'x_focus__mutmut_19': x_focus__mutmut_19, 
    'x_focus__mutmut_20': x_focus__mutmut_20, 
    'x_focus__mutmut_21': x_focus__mutmut_21, 
    'x_focus__mutmut_22': x_focus__mutmut_22, 
    'x_focus__mutmut_23': x_focus__mutmut_23, 
    'x_focus__mutmut_24': x_focus__mutmut_24, 
    'x_focus__mutmut_25': x_focus__mutmut_25, 
    'x_focus__mutmut_26': x_focus__mutmut_26, 
    'x_focus__mutmut_27': x_focus__mutmut_27, 
    'x_focus__mutmut_28': x_focus__mutmut_28, 
    'x_focus__mutmut_29': x_focus__mutmut_29, 
    'x_focus__mutmut_30': x_focus__mutmut_30
}

def focus(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_focus__mutmut_orig, x_focus__mutmut_mutants, args, kwargs)
    return result 

focus.__signature__ = _mutmut_signature(x_focus__mutmut_orig)
x_focus__mutmut_orig.__name__ = 'x_focus'


def x_get_attributes__mutmut_orig(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_1(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_2(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_3(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_4(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_5(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_6(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_7(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_8(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_9(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_10(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_11(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getAttributesXX",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_12(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getattributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_13(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETATTRIBUTES",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_14(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getattributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_15(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_16(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_17(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "Params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_18(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = None
    return [str(i) for i in json["attributes"]]


def x_get_attributes__mutmut_19(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(None) for i in json["attributes"]]


def x_get_attributes__mutmut_20(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["XXattributesXX"]]


def x_get_attributes__mutmut_21(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["ATTRIBUTES"]]


def x_get_attributes__mutmut_22(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns attributes for the specified node.

    :param node_id: Id of the node to retrieve attributes for.
    :returns: An interleaved array of node attribute names and values.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAttributes",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["Attributes"]]

x_get_attributes__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_attributes__mutmut_1': x_get_attributes__mutmut_1, 
    'x_get_attributes__mutmut_2': x_get_attributes__mutmut_2, 
    'x_get_attributes__mutmut_3': x_get_attributes__mutmut_3, 
    'x_get_attributes__mutmut_4': x_get_attributes__mutmut_4, 
    'x_get_attributes__mutmut_5': x_get_attributes__mutmut_5, 
    'x_get_attributes__mutmut_6': x_get_attributes__mutmut_6, 
    'x_get_attributes__mutmut_7': x_get_attributes__mutmut_7, 
    'x_get_attributes__mutmut_8': x_get_attributes__mutmut_8, 
    'x_get_attributes__mutmut_9': x_get_attributes__mutmut_9, 
    'x_get_attributes__mutmut_10': x_get_attributes__mutmut_10, 
    'x_get_attributes__mutmut_11': x_get_attributes__mutmut_11, 
    'x_get_attributes__mutmut_12': x_get_attributes__mutmut_12, 
    'x_get_attributes__mutmut_13': x_get_attributes__mutmut_13, 
    'x_get_attributes__mutmut_14': x_get_attributes__mutmut_14, 
    'x_get_attributes__mutmut_15': x_get_attributes__mutmut_15, 
    'x_get_attributes__mutmut_16': x_get_attributes__mutmut_16, 
    'x_get_attributes__mutmut_17': x_get_attributes__mutmut_17, 
    'x_get_attributes__mutmut_18': x_get_attributes__mutmut_18, 
    'x_get_attributes__mutmut_19': x_get_attributes__mutmut_19, 
    'x_get_attributes__mutmut_20': x_get_attributes__mutmut_20, 
    'x_get_attributes__mutmut_21': x_get_attributes__mutmut_21, 
    'x_get_attributes__mutmut_22': x_get_attributes__mutmut_22
}

def get_attributes(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_attributes__mutmut_orig, x_get_attributes__mutmut_mutants, args, kwargs)
    return result 

get_attributes.__signature__ = _mutmut_signature(x_get_attributes__mutmut_orig)
x_get_attributes__mutmut_orig.__name__ = 'x_get_attributes'


def x_get_box_model__mutmut_orig(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_1(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = None
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_2(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_3(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = None
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_4(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["XXnodeIdXX"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_5(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_6(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["NODEID"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_7(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["Nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_8(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_9(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = None
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_10(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["XXbackendNodeIdXX"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_11(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_12(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["BACKENDNODEID"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_13(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["Backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_14(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_15(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_16(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["XXobjectIdXX"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_17(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_18(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["OBJECTID"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_19(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["Objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_20(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_21(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_22(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_23(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_24(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getBoxModelXX",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_25(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getboxmodel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_26(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETBOXMODEL",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_27(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getboxmodel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_28(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_29(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_30(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "Params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_31(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = None
    return BoxModel.from_json(json["model"])


def x_get_box_model__mutmut_32(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(None)


def x_get_box_model__mutmut_33(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["XXmodelXX"])


def x_get_box_model__mutmut_34(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["MODEL"])


def x_get_box_model__mutmut_35(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BoxModel]:
    """
    Returns boxes for the given node.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Box model for the node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getBoxModel",
        "params": params,
    }
    json = yield cmd_dict
    return BoxModel.from_json(json["Model"])

x_get_box_model__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_box_model__mutmut_1': x_get_box_model__mutmut_1, 
    'x_get_box_model__mutmut_2': x_get_box_model__mutmut_2, 
    'x_get_box_model__mutmut_3': x_get_box_model__mutmut_3, 
    'x_get_box_model__mutmut_4': x_get_box_model__mutmut_4, 
    'x_get_box_model__mutmut_5': x_get_box_model__mutmut_5, 
    'x_get_box_model__mutmut_6': x_get_box_model__mutmut_6, 
    'x_get_box_model__mutmut_7': x_get_box_model__mutmut_7, 
    'x_get_box_model__mutmut_8': x_get_box_model__mutmut_8, 
    'x_get_box_model__mutmut_9': x_get_box_model__mutmut_9, 
    'x_get_box_model__mutmut_10': x_get_box_model__mutmut_10, 
    'x_get_box_model__mutmut_11': x_get_box_model__mutmut_11, 
    'x_get_box_model__mutmut_12': x_get_box_model__mutmut_12, 
    'x_get_box_model__mutmut_13': x_get_box_model__mutmut_13, 
    'x_get_box_model__mutmut_14': x_get_box_model__mutmut_14, 
    'x_get_box_model__mutmut_15': x_get_box_model__mutmut_15, 
    'x_get_box_model__mutmut_16': x_get_box_model__mutmut_16, 
    'x_get_box_model__mutmut_17': x_get_box_model__mutmut_17, 
    'x_get_box_model__mutmut_18': x_get_box_model__mutmut_18, 
    'x_get_box_model__mutmut_19': x_get_box_model__mutmut_19, 
    'x_get_box_model__mutmut_20': x_get_box_model__mutmut_20, 
    'x_get_box_model__mutmut_21': x_get_box_model__mutmut_21, 
    'x_get_box_model__mutmut_22': x_get_box_model__mutmut_22, 
    'x_get_box_model__mutmut_23': x_get_box_model__mutmut_23, 
    'x_get_box_model__mutmut_24': x_get_box_model__mutmut_24, 
    'x_get_box_model__mutmut_25': x_get_box_model__mutmut_25, 
    'x_get_box_model__mutmut_26': x_get_box_model__mutmut_26, 
    'x_get_box_model__mutmut_27': x_get_box_model__mutmut_27, 
    'x_get_box_model__mutmut_28': x_get_box_model__mutmut_28, 
    'x_get_box_model__mutmut_29': x_get_box_model__mutmut_29, 
    'x_get_box_model__mutmut_30': x_get_box_model__mutmut_30, 
    'x_get_box_model__mutmut_31': x_get_box_model__mutmut_31, 
    'x_get_box_model__mutmut_32': x_get_box_model__mutmut_32, 
    'x_get_box_model__mutmut_33': x_get_box_model__mutmut_33, 
    'x_get_box_model__mutmut_34': x_get_box_model__mutmut_34, 
    'x_get_box_model__mutmut_35': x_get_box_model__mutmut_35
}

def get_box_model(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_box_model__mutmut_orig, x_get_box_model__mutmut_mutants, args, kwargs)
    return result 

get_box_model.__signature__ = _mutmut_signature(x_get_box_model__mutmut_orig)
x_get_box_model__mutmut_orig.__name__ = 'x_get_box_model'


def x_get_content_quads__mutmut_orig(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_1(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = None
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_2(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_3(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = None
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_4(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["XXnodeIdXX"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_5(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_6(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["NODEID"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_7(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["Nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_8(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_9(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = None
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_10(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["XXbackendNodeIdXX"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_11(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_12(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["BACKENDNODEID"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_13(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["Backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_14(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_15(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_16(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["XXobjectIdXX"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_17(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_18(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["OBJECTID"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_19(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["Objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_20(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_21(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_22(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_23(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_24(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getContentQuadsXX",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_25(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getcontentquads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_26(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETCONTENTQUADS",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_27(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getcontentquads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_28(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_29(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_30(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "Params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_31(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = None
    return [Quad.from_json(i) for i in json["quads"]]


def x_get_content_quads__mutmut_32(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(None) for i in json["quads"]]


def x_get_content_quads__mutmut_33(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["XXquadsXX"]]


def x_get_content_quads__mutmut_34(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["QUADS"]]


def x_get_content_quads__mutmut_35(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Quad]]:
    """
    Returns quads that describe node position on the page. This method
    might return multiple quads for inline nodes.

    **EXPERIMENTAL**

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Quads that describe node layout relative to viewport.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContentQuads",
        "params": params,
    }
    json = yield cmd_dict
    return [Quad.from_json(i) for i in json["Quads"]]

x_get_content_quads__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_content_quads__mutmut_1': x_get_content_quads__mutmut_1, 
    'x_get_content_quads__mutmut_2': x_get_content_quads__mutmut_2, 
    'x_get_content_quads__mutmut_3': x_get_content_quads__mutmut_3, 
    'x_get_content_quads__mutmut_4': x_get_content_quads__mutmut_4, 
    'x_get_content_quads__mutmut_5': x_get_content_quads__mutmut_5, 
    'x_get_content_quads__mutmut_6': x_get_content_quads__mutmut_6, 
    'x_get_content_quads__mutmut_7': x_get_content_quads__mutmut_7, 
    'x_get_content_quads__mutmut_8': x_get_content_quads__mutmut_8, 
    'x_get_content_quads__mutmut_9': x_get_content_quads__mutmut_9, 
    'x_get_content_quads__mutmut_10': x_get_content_quads__mutmut_10, 
    'x_get_content_quads__mutmut_11': x_get_content_quads__mutmut_11, 
    'x_get_content_quads__mutmut_12': x_get_content_quads__mutmut_12, 
    'x_get_content_quads__mutmut_13': x_get_content_quads__mutmut_13, 
    'x_get_content_quads__mutmut_14': x_get_content_quads__mutmut_14, 
    'x_get_content_quads__mutmut_15': x_get_content_quads__mutmut_15, 
    'x_get_content_quads__mutmut_16': x_get_content_quads__mutmut_16, 
    'x_get_content_quads__mutmut_17': x_get_content_quads__mutmut_17, 
    'x_get_content_quads__mutmut_18': x_get_content_quads__mutmut_18, 
    'x_get_content_quads__mutmut_19': x_get_content_quads__mutmut_19, 
    'x_get_content_quads__mutmut_20': x_get_content_quads__mutmut_20, 
    'x_get_content_quads__mutmut_21': x_get_content_quads__mutmut_21, 
    'x_get_content_quads__mutmut_22': x_get_content_quads__mutmut_22, 
    'x_get_content_quads__mutmut_23': x_get_content_quads__mutmut_23, 
    'x_get_content_quads__mutmut_24': x_get_content_quads__mutmut_24, 
    'x_get_content_quads__mutmut_25': x_get_content_quads__mutmut_25, 
    'x_get_content_quads__mutmut_26': x_get_content_quads__mutmut_26, 
    'x_get_content_quads__mutmut_27': x_get_content_quads__mutmut_27, 
    'x_get_content_quads__mutmut_28': x_get_content_quads__mutmut_28, 
    'x_get_content_quads__mutmut_29': x_get_content_quads__mutmut_29, 
    'x_get_content_quads__mutmut_30': x_get_content_quads__mutmut_30, 
    'x_get_content_quads__mutmut_31': x_get_content_quads__mutmut_31, 
    'x_get_content_quads__mutmut_32': x_get_content_quads__mutmut_32, 
    'x_get_content_quads__mutmut_33': x_get_content_quads__mutmut_33, 
    'x_get_content_quads__mutmut_34': x_get_content_quads__mutmut_34, 
    'x_get_content_quads__mutmut_35': x_get_content_quads__mutmut_35
}

def get_content_quads(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_content_quads__mutmut_orig, x_get_content_quads__mutmut_mutants, args, kwargs)
    return result 

get_content_quads.__signature__ = _mutmut_signature(x_get_content_quads__mutmut_orig)
x_get_content_quads__mutmut_orig.__name__ = 'x_get_content_quads'


def x_get_document__mutmut_orig(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_1(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = None
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_2(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_3(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = None
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_4(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["XXdepthXX"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_5(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["DEPTH"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_6(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["Depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_7(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_8(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_9(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["XXpierceXX"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_10(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["PIERCE"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_11(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["Pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_12(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_13(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_14(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_15(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_16(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getDocumentXX",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_17(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getdocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_18(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETDOCUMENT",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_19(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getdocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_20(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_21(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_22(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "Params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["root"])


def x_get_document__mutmut_23(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = None
    return Node.from_json(json["root"])


def x_get_document__mutmut_24(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(None)


def x_get_document__mutmut_25(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["XXrootXX"])


def x_get_document__mutmut_26(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["ROOT"])


def x_get_document__mutmut_27(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Node]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Implicitly enables the DOM domain events for the current target.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDocument",
        "params": params,
    }
    json = yield cmd_dict
    return Node.from_json(json["Root"])

x_get_document__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_document__mutmut_1': x_get_document__mutmut_1, 
    'x_get_document__mutmut_2': x_get_document__mutmut_2, 
    'x_get_document__mutmut_3': x_get_document__mutmut_3, 
    'x_get_document__mutmut_4': x_get_document__mutmut_4, 
    'x_get_document__mutmut_5': x_get_document__mutmut_5, 
    'x_get_document__mutmut_6': x_get_document__mutmut_6, 
    'x_get_document__mutmut_7': x_get_document__mutmut_7, 
    'x_get_document__mutmut_8': x_get_document__mutmut_8, 
    'x_get_document__mutmut_9': x_get_document__mutmut_9, 
    'x_get_document__mutmut_10': x_get_document__mutmut_10, 
    'x_get_document__mutmut_11': x_get_document__mutmut_11, 
    'x_get_document__mutmut_12': x_get_document__mutmut_12, 
    'x_get_document__mutmut_13': x_get_document__mutmut_13, 
    'x_get_document__mutmut_14': x_get_document__mutmut_14, 
    'x_get_document__mutmut_15': x_get_document__mutmut_15, 
    'x_get_document__mutmut_16': x_get_document__mutmut_16, 
    'x_get_document__mutmut_17': x_get_document__mutmut_17, 
    'x_get_document__mutmut_18': x_get_document__mutmut_18, 
    'x_get_document__mutmut_19': x_get_document__mutmut_19, 
    'x_get_document__mutmut_20': x_get_document__mutmut_20, 
    'x_get_document__mutmut_21': x_get_document__mutmut_21, 
    'x_get_document__mutmut_22': x_get_document__mutmut_22, 
    'x_get_document__mutmut_23': x_get_document__mutmut_23, 
    'x_get_document__mutmut_24': x_get_document__mutmut_24, 
    'x_get_document__mutmut_25': x_get_document__mutmut_25, 
    'x_get_document__mutmut_26': x_get_document__mutmut_26, 
    'x_get_document__mutmut_27': x_get_document__mutmut_27
}

def get_document(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_document__mutmut_orig, x_get_document__mutmut_mutants, args, kwargs)
    return result 

get_document.__signature__ = _mutmut_signature(x_get_document__mutmut_orig)
x_get_document__mutmut_orig.__name__ = 'x_get_document'


def x_get_flattened_document__mutmut_orig(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_1(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = None
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_2(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_3(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = None
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_4(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["XXdepthXX"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_5(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["DEPTH"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_6(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["Depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_7(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_8(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_9(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["XXpierceXX"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_10(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["PIERCE"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_11(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["Pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_12(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_13(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_14(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_15(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_16(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getFlattenedDocumentXX",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_17(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getflatteneddocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_18(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETFLATTENEDDOCUMENT",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_19(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getflatteneddocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_20(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_21(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_22(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "Params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_23(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = None
    return [Node.from_json(i) for i in json["nodes"]]


def x_get_flattened_document__mutmut_24(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(None) for i in json["nodes"]]


def x_get_flattened_document__mutmut_25(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["XXnodesXX"]]


def x_get_flattened_document__mutmut_26(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["NODES"]]


def x_get_flattened_document__mutmut_27(
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[Node]]:
    """
    Returns the root DOM node (and optionally the subtree) to the caller.
    Deprecated, as it is not designed to work well with the rest of the DOM agent.
    Use DOMSnapshot.captureSnapshot instead.

    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
    :returns: Resulting node.
    """
    params: T_JSON_DICT = {}
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFlattenedDocument",
        "params": params,
    }
    json = yield cmd_dict
    return [Node.from_json(i) for i in json["Nodes"]]

x_get_flattened_document__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_flattened_document__mutmut_1': x_get_flattened_document__mutmut_1, 
    'x_get_flattened_document__mutmut_2': x_get_flattened_document__mutmut_2, 
    'x_get_flattened_document__mutmut_3': x_get_flattened_document__mutmut_3, 
    'x_get_flattened_document__mutmut_4': x_get_flattened_document__mutmut_4, 
    'x_get_flattened_document__mutmut_5': x_get_flattened_document__mutmut_5, 
    'x_get_flattened_document__mutmut_6': x_get_flattened_document__mutmut_6, 
    'x_get_flattened_document__mutmut_7': x_get_flattened_document__mutmut_7, 
    'x_get_flattened_document__mutmut_8': x_get_flattened_document__mutmut_8, 
    'x_get_flattened_document__mutmut_9': x_get_flattened_document__mutmut_9, 
    'x_get_flattened_document__mutmut_10': x_get_flattened_document__mutmut_10, 
    'x_get_flattened_document__mutmut_11': x_get_flattened_document__mutmut_11, 
    'x_get_flattened_document__mutmut_12': x_get_flattened_document__mutmut_12, 
    'x_get_flattened_document__mutmut_13': x_get_flattened_document__mutmut_13, 
    'x_get_flattened_document__mutmut_14': x_get_flattened_document__mutmut_14, 
    'x_get_flattened_document__mutmut_15': x_get_flattened_document__mutmut_15, 
    'x_get_flattened_document__mutmut_16': x_get_flattened_document__mutmut_16, 
    'x_get_flattened_document__mutmut_17': x_get_flattened_document__mutmut_17, 
    'x_get_flattened_document__mutmut_18': x_get_flattened_document__mutmut_18, 
    'x_get_flattened_document__mutmut_19': x_get_flattened_document__mutmut_19, 
    'x_get_flattened_document__mutmut_20': x_get_flattened_document__mutmut_20, 
    'x_get_flattened_document__mutmut_21': x_get_flattened_document__mutmut_21, 
    'x_get_flattened_document__mutmut_22': x_get_flattened_document__mutmut_22, 
    'x_get_flattened_document__mutmut_23': x_get_flattened_document__mutmut_23, 
    'x_get_flattened_document__mutmut_24': x_get_flattened_document__mutmut_24, 
    'x_get_flattened_document__mutmut_25': x_get_flattened_document__mutmut_25, 
    'x_get_flattened_document__mutmut_26': x_get_flattened_document__mutmut_26, 
    'x_get_flattened_document__mutmut_27': x_get_flattened_document__mutmut_27
}

def get_flattened_document(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_flattened_document__mutmut_orig, x_get_flattened_document__mutmut_mutants, args, kwargs)
    return result 

get_flattened_document.__signature__ = _mutmut_signature(x_get_flattened_document__mutmut_orig)
x_get_flattened_document__mutmut_orig.__name__ = 'x_get_flattened_document'


def x_get_nodes_for_subtree_by_style__mutmut_orig(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_1(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_2(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_3(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_4(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_5(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_6(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_7(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = None
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_8(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXcomputedStylesXX"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_9(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedstyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_10(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["COMPUTEDSTYLES"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_11(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Computedstyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_12(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_13(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_14(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["XXpierceXX"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_15(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["PIERCE"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_16(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["Pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_17(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_18(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_19(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_20(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_21(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getNodesForSubtreeByStyleXX",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_22(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getnodesforsubtreebystyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_23(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETNODESFORSUBTREEBYSTYLE",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_24(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getnodesforsubtreebystyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_25(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_26(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_27(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "Params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_28(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = None
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_29(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(None) for i in json["nodeIds"]]


def x_get_nodes_for_subtree_by_style__mutmut_30(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["XXnodeIdsXX"]]


def x_get_nodes_for_subtree_by_style__mutmut_31(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeids"]]


def x_get_nodes_for_subtree_by_style__mutmut_32(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["NODEIDS"]]


def x_get_nodes_for_subtree_by_style__mutmut_33(
    node_id: NodeId,
    computed_styles: list[CSSComputedStyleProperty],
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Finds nodes with a given computed style in a subtree.

    **EXPERIMENTAL**

    :param node_id: Node ID pointing to the root of a subtree.
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches).
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
    :returns: Resulting nodes.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["computedStyles"] = [i.to_json() for i in computed_styles]
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodesForSubtreeByStyle",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["Nodeids"]]

x_get_nodes_for_subtree_by_style__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_nodes_for_subtree_by_style__mutmut_1': x_get_nodes_for_subtree_by_style__mutmut_1, 
    'x_get_nodes_for_subtree_by_style__mutmut_2': x_get_nodes_for_subtree_by_style__mutmut_2, 
    'x_get_nodes_for_subtree_by_style__mutmut_3': x_get_nodes_for_subtree_by_style__mutmut_3, 
    'x_get_nodes_for_subtree_by_style__mutmut_4': x_get_nodes_for_subtree_by_style__mutmut_4, 
    'x_get_nodes_for_subtree_by_style__mutmut_5': x_get_nodes_for_subtree_by_style__mutmut_5, 
    'x_get_nodes_for_subtree_by_style__mutmut_6': x_get_nodes_for_subtree_by_style__mutmut_6, 
    'x_get_nodes_for_subtree_by_style__mutmut_7': x_get_nodes_for_subtree_by_style__mutmut_7, 
    'x_get_nodes_for_subtree_by_style__mutmut_8': x_get_nodes_for_subtree_by_style__mutmut_8, 
    'x_get_nodes_for_subtree_by_style__mutmut_9': x_get_nodes_for_subtree_by_style__mutmut_9, 
    'x_get_nodes_for_subtree_by_style__mutmut_10': x_get_nodes_for_subtree_by_style__mutmut_10, 
    'x_get_nodes_for_subtree_by_style__mutmut_11': x_get_nodes_for_subtree_by_style__mutmut_11, 
    'x_get_nodes_for_subtree_by_style__mutmut_12': x_get_nodes_for_subtree_by_style__mutmut_12, 
    'x_get_nodes_for_subtree_by_style__mutmut_13': x_get_nodes_for_subtree_by_style__mutmut_13, 
    'x_get_nodes_for_subtree_by_style__mutmut_14': x_get_nodes_for_subtree_by_style__mutmut_14, 
    'x_get_nodes_for_subtree_by_style__mutmut_15': x_get_nodes_for_subtree_by_style__mutmut_15, 
    'x_get_nodes_for_subtree_by_style__mutmut_16': x_get_nodes_for_subtree_by_style__mutmut_16, 
    'x_get_nodes_for_subtree_by_style__mutmut_17': x_get_nodes_for_subtree_by_style__mutmut_17, 
    'x_get_nodes_for_subtree_by_style__mutmut_18': x_get_nodes_for_subtree_by_style__mutmut_18, 
    'x_get_nodes_for_subtree_by_style__mutmut_19': x_get_nodes_for_subtree_by_style__mutmut_19, 
    'x_get_nodes_for_subtree_by_style__mutmut_20': x_get_nodes_for_subtree_by_style__mutmut_20, 
    'x_get_nodes_for_subtree_by_style__mutmut_21': x_get_nodes_for_subtree_by_style__mutmut_21, 
    'x_get_nodes_for_subtree_by_style__mutmut_22': x_get_nodes_for_subtree_by_style__mutmut_22, 
    'x_get_nodes_for_subtree_by_style__mutmut_23': x_get_nodes_for_subtree_by_style__mutmut_23, 
    'x_get_nodes_for_subtree_by_style__mutmut_24': x_get_nodes_for_subtree_by_style__mutmut_24, 
    'x_get_nodes_for_subtree_by_style__mutmut_25': x_get_nodes_for_subtree_by_style__mutmut_25, 
    'x_get_nodes_for_subtree_by_style__mutmut_26': x_get_nodes_for_subtree_by_style__mutmut_26, 
    'x_get_nodes_for_subtree_by_style__mutmut_27': x_get_nodes_for_subtree_by_style__mutmut_27, 
    'x_get_nodes_for_subtree_by_style__mutmut_28': x_get_nodes_for_subtree_by_style__mutmut_28, 
    'x_get_nodes_for_subtree_by_style__mutmut_29': x_get_nodes_for_subtree_by_style__mutmut_29, 
    'x_get_nodes_for_subtree_by_style__mutmut_30': x_get_nodes_for_subtree_by_style__mutmut_30, 
    'x_get_nodes_for_subtree_by_style__mutmut_31': x_get_nodes_for_subtree_by_style__mutmut_31, 
    'x_get_nodes_for_subtree_by_style__mutmut_32': x_get_nodes_for_subtree_by_style__mutmut_32, 
    'x_get_nodes_for_subtree_by_style__mutmut_33': x_get_nodes_for_subtree_by_style__mutmut_33
}

def get_nodes_for_subtree_by_style(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_nodes_for_subtree_by_style__mutmut_orig, x_get_nodes_for_subtree_by_style__mutmut_mutants, args, kwargs)
    return result 

get_nodes_for_subtree_by_style.__signature__ = _mutmut_signature(x_get_nodes_for_subtree_by_style__mutmut_orig)
x_get_nodes_for_subtree_by_style__mutmut_orig.__name__ = 'x_get_nodes_for_subtree_by_style'


def x_get_node_for_location__mutmut_orig(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_1(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = None
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_2(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = None
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_3(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["XXxXX"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_4(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["X"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_5(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["X"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_6(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = None
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_7(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["XXyXX"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_8(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["Y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_9(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["Y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_10(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_11(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = None
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_12(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["XXincludeUserAgentShadowDOMXX"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_13(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeuseragentshadowdom"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_14(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["INCLUDEUSERAGENTSHADOWDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_15(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["Includeuseragentshadowdom"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_16(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_17(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_18(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["XXignorePointerEventsNoneXX"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_19(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorepointereventsnone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_20(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["IGNOREPOINTEREVENTSNONE"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_21(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["Ignorepointereventsnone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_22(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_23(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_24(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_25(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_26(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getNodeForLocationXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_27(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getnodeforlocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_28(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETNODEFORLOCATION",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_29(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getnodeforlocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_30(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_31(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_32(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_33(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = None
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_34(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(None),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_35(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["XXbackendNodeIdXX"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_36(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendnodeid"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_37(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["BACKENDNODEID"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_38(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["Backendnodeid"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_39(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(None),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_40(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["XXframeIdXX"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_41(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameid"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_42(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["FRAMEID"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_43(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["Frameid"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_44(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(None) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_45(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["XXnodeIdXX"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_46(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeid"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_47(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["NODEID"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_48(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["Nodeid"]) if "nodeId" in json else None,
    )


def x_get_node_for_location__mutmut_49(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "XXnodeIdXX" in json else None,
    )


def x_get_node_for_location__mutmut_50(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeid" in json else None,
    )


def x_get_node_for_location__mutmut_51(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "NODEID" in json else None,
    )


def x_get_node_for_location__mutmut_52(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "Nodeid" in json else None,
    )


def x_get_node_for_location__mutmut_53(
    x: int,
    y: int,
    include_user_agent_shadow_dom: bool | None = None,
    ignore_pointer_events_none: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, page.FrameId, NodeId | None]]:
    """
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
    either returned or not.

    :param x: X coordinate.
    :param y: Y coordinate.
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false).
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them.
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **frameId** - Frame this node belongs to.
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    if ignore_pointer_events_none is not None:
        params["ignorePointerEventsNone"] = ignore_pointer_events_none
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeForLocation",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        page.FrameId.from_json(json["frameId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" not in json else None,
    )

x_get_node_for_location__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_node_for_location__mutmut_1': x_get_node_for_location__mutmut_1, 
    'x_get_node_for_location__mutmut_2': x_get_node_for_location__mutmut_2, 
    'x_get_node_for_location__mutmut_3': x_get_node_for_location__mutmut_3, 
    'x_get_node_for_location__mutmut_4': x_get_node_for_location__mutmut_4, 
    'x_get_node_for_location__mutmut_5': x_get_node_for_location__mutmut_5, 
    'x_get_node_for_location__mutmut_6': x_get_node_for_location__mutmut_6, 
    'x_get_node_for_location__mutmut_7': x_get_node_for_location__mutmut_7, 
    'x_get_node_for_location__mutmut_8': x_get_node_for_location__mutmut_8, 
    'x_get_node_for_location__mutmut_9': x_get_node_for_location__mutmut_9, 
    'x_get_node_for_location__mutmut_10': x_get_node_for_location__mutmut_10, 
    'x_get_node_for_location__mutmut_11': x_get_node_for_location__mutmut_11, 
    'x_get_node_for_location__mutmut_12': x_get_node_for_location__mutmut_12, 
    'x_get_node_for_location__mutmut_13': x_get_node_for_location__mutmut_13, 
    'x_get_node_for_location__mutmut_14': x_get_node_for_location__mutmut_14, 
    'x_get_node_for_location__mutmut_15': x_get_node_for_location__mutmut_15, 
    'x_get_node_for_location__mutmut_16': x_get_node_for_location__mutmut_16, 
    'x_get_node_for_location__mutmut_17': x_get_node_for_location__mutmut_17, 
    'x_get_node_for_location__mutmut_18': x_get_node_for_location__mutmut_18, 
    'x_get_node_for_location__mutmut_19': x_get_node_for_location__mutmut_19, 
    'x_get_node_for_location__mutmut_20': x_get_node_for_location__mutmut_20, 
    'x_get_node_for_location__mutmut_21': x_get_node_for_location__mutmut_21, 
    'x_get_node_for_location__mutmut_22': x_get_node_for_location__mutmut_22, 
    'x_get_node_for_location__mutmut_23': x_get_node_for_location__mutmut_23, 
    'x_get_node_for_location__mutmut_24': x_get_node_for_location__mutmut_24, 
    'x_get_node_for_location__mutmut_25': x_get_node_for_location__mutmut_25, 
    'x_get_node_for_location__mutmut_26': x_get_node_for_location__mutmut_26, 
    'x_get_node_for_location__mutmut_27': x_get_node_for_location__mutmut_27, 
    'x_get_node_for_location__mutmut_28': x_get_node_for_location__mutmut_28, 
    'x_get_node_for_location__mutmut_29': x_get_node_for_location__mutmut_29, 
    'x_get_node_for_location__mutmut_30': x_get_node_for_location__mutmut_30, 
    'x_get_node_for_location__mutmut_31': x_get_node_for_location__mutmut_31, 
    'x_get_node_for_location__mutmut_32': x_get_node_for_location__mutmut_32, 
    'x_get_node_for_location__mutmut_33': x_get_node_for_location__mutmut_33, 
    'x_get_node_for_location__mutmut_34': x_get_node_for_location__mutmut_34, 
    'x_get_node_for_location__mutmut_35': x_get_node_for_location__mutmut_35, 
    'x_get_node_for_location__mutmut_36': x_get_node_for_location__mutmut_36, 
    'x_get_node_for_location__mutmut_37': x_get_node_for_location__mutmut_37, 
    'x_get_node_for_location__mutmut_38': x_get_node_for_location__mutmut_38, 
    'x_get_node_for_location__mutmut_39': x_get_node_for_location__mutmut_39, 
    'x_get_node_for_location__mutmut_40': x_get_node_for_location__mutmut_40, 
    'x_get_node_for_location__mutmut_41': x_get_node_for_location__mutmut_41, 
    'x_get_node_for_location__mutmut_42': x_get_node_for_location__mutmut_42, 
    'x_get_node_for_location__mutmut_43': x_get_node_for_location__mutmut_43, 
    'x_get_node_for_location__mutmut_44': x_get_node_for_location__mutmut_44, 
    'x_get_node_for_location__mutmut_45': x_get_node_for_location__mutmut_45, 
    'x_get_node_for_location__mutmut_46': x_get_node_for_location__mutmut_46, 
    'x_get_node_for_location__mutmut_47': x_get_node_for_location__mutmut_47, 
    'x_get_node_for_location__mutmut_48': x_get_node_for_location__mutmut_48, 
    'x_get_node_for_location__mutmut_49': x_get_node_for_location__mutmut_49, 
    'x_get_node_for_location__mutmut_50': x_get_node_for_location__mutmut_50, 
    'x_get_node_for_location__mutmut_51': x_get_node_for_location__mutmut_51, 
    'x_get_node_for_location__mutmut_52': x_get_node_for_location__mutmut_52, 
    'x_get_node_for_location__mutmut_53': x_get_node_for_location__mutmut_53
}

def get_node_for_location(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_node_for_location__mutmut_orig, x_get_node_for_location__mutmut_mutants, args, kwargs)
    return result 

get_node_for_location.__signature__ = _mutmut_signature(x_get_node_for_location__mutmut_orig)
x_get_node_for_location__mutmut_orig.__name__ = 'x_get_node_for_location'


def x_get_outer_html__mutmut_orig(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_1(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = None
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_2(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_3(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = None
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_4(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["XXnodeIdXX"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_5(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_6(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["NODEID"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_7(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["Nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_8(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_9(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = None
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_10(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["XXbackendNodeIdXX"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_11(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_12(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["BACKENDNODEID"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_13(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["Backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_14(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_15(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_16(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["XXobjectIdXX"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_17(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_18(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["OBJECTID"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_19(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["Objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_20(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_21(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_22(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_23(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_24(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getOuterHTMLXX",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_25(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getouterhtml",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_26(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETOUTERHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_27(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getouterhtml",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_28(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_29(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_30(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "Params": params,
    }
    json = yield cmd_dict
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_31(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = None
    return str(json["outerHTML"])


def x_get_outer_html__mutmut_32(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(None)


def x_get_outer_html__mutmut_33(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["XXouterHTMLXX"])


def x_get_outer_html__mutmut_34(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["outerhtml"])


def x_get_outer_html__mutmut_35(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["OUTERHTML"])


def x_get_outer_html__mutmut_36(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns node's HTML markup.

    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    :returns: Outer HTML markup.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getOuterHTML",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["Outerhtml"])

x_get_outer_html__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_outer_html__mutmut_1': x_get_outer_html__mutmut_1, 
    'x_get_outer_html__mutmut_2': x_get_outer_html__mutmut_2, 
    'x_get_outer_html__mutmut_3': x_get_outer_html__mutmut_3, 
    'x_get_outer_html__mutmut_4': x_get_outer_html__mutmut_4, 
    'x_get_outer_html__mutmut_5': x_get_outer_html__mutmut_5, 
    'x_get_outer_html__mutmut_6': x_get_outer_html__mutmut_6, 
    'x_get_outer_html__mutmut_7': x_get_outer_html__mutmut_7, 
    'x_get_outer_html__mutmut_8': x_get_outer_html__mutmut_8, 
    'x_get_outer_html__mutmut_9': x_get_outer_html__mutmut_9, 
    'x_get_outer_html__mutmut_10': x_get_outer_html__mutmut_10, 
    'x_get_outer_html__mutmut_11': x_get_outer_html__mutmut_11, 
    'x_get_outer_html__mutmut_12': x_get_outer_html__mutmut_12, 
    'x_get_outer_html__mutmut_13': x_get_outer_html__mutmut_13, 
    'x_get_outer_html__mutmut_14': x_get_outer_html__mutmut_14, 
    'x_get_outer_html__mutmut_15': x_get_outer_html__mutmut_15, 
    'x_get_outer_html__mutmut_16': x_get_outer_html__mutmut_16, 
    'x_get_outer_html__mutmut_17': x_get_outer_html__mutmut_17, 
    'x_get_outer_html__mutmut_18': x_get_outer_html__mutmut_18, 
    'x_get_outer_html__mutmut_19': x_get_outer_html__mutmut_19, 
    'x_get_outer_html__mutmut_20': x_get_outer_html__mutmut_20, 
    'x_get_outer_html__mutmut_21': x_get_outer_html__mutmut_21, 
    'x_get_outer_html__mutmut_22': x_get_outer_html__mutmut_22, 
    'x_get_outer_html__mutmut_23': x_get_outer_html__mutmut_23, 
    'x_get_outer_html__mutmut_24': x_get_outer_html__mutmut_24, 
    'x_get_outer_html__mutmut_25': x_get_outer_html__mutmut_25, 
    'x_get_outer_html__mutmut_26': x_get_outer_html__mutmut_26, 
    'x_get_outer_html__mutmut_27': x_get_outer_html__mutmut_27, 
    'x_get_outer_html__mutmut_28': x_get_outer_html__mutmut_28, 
    'x_get_outer_html__mutmut_29': x_get_outer_html__mutmut_29, 
    'x_get_outer_html__mutmut_30': x_get_outer_html__mutmut_30, 
    'x_get_outer_html__mutmut_31': x_get_outer_html__mutmut_31, 
    'x_get_outer_html__mutmut_32': x_get_outer_html__mutmut_32, 
    'x_get_outer_html__mutmut_33': x_get_outer_html__mutmut_33, 
    'x_get_outer_html__mutmut_34': x_get_outer_html__mutmut_34, 
    'x_get_outer_html__mutmut_35': x_get_outer_html__mutmut_35, 
    'x_get_outer_html__mutmut_36': x_get_outer_html__mutmut_36
}

def get_outer_html(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_outer_html__mutmut_orig, x_get_outer_html__mutmut_mutants, args, kwargs)
    return result 

get_outer_html.__signature__ = _mutmut_signature(x_get_outer_html__mutmut_orig)
x_get_outer_html__mutmut_orig.__name__ = 'x_get_outer_html'


def x_get_relayout_boundary__mutmut_orig(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_1(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_2(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_3(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_4(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_5(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_6(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_7(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_8(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_9(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_10(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_11(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getRelayoutBoundaryXX",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_12(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getrelayoutboundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_13(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETRELAYOUTBOUNDARY",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_14(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getrelayoutboundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_15(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_16(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_17(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "Params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_18(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = None
    return NodeId.from_json(json["nodeId"])


def x_get_relayout_boundary__mutmut_19(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(None)


def x_get_relayout_boundary__mutmut_20(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["XXnodeIdXX"])


def x_get_relayout_boundary__mutmut_21(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeid"])


def x_get_relayout_boundary__mutmut_22(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["NODEID"])


def x_get_relayout_boundary__mutmut_23(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the id of the nearest ancestor that is a relayout boundary.

    **EXPERIMENTAL**

    :param node_id: Id of the node.
    :returns: Relayout boundary node id for the given node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getRelayoutBoundary",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["Nodeid"])

x_get_relayout_boundary__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_relayout_boundary__mutmut_1': x_get_relayout_boundary__mutmut_1, 
    'x_get_relayout_boundary__mutmut_2': x_get_relayout_boundary__mutmut_2, 
    'x_get_relayout_boundary__mutmut_3': x_get_relayout_boundary__mutmut_3, 
    'x_get_relayout_boundary__mutmut_4': x_get_relayout_boundary__mutmut_4, 
    'x_get_relayout_boundary__mutmut_5': x_get_relayout_boundary__mutmut_5, 
    'x_get_relayout_boundary__mutmut_6': x_get_relayout_boundary__mutmut_6, 
    'x_get_relayout_boundary__mutmut_7': x_get_relayout_boundary__mutmut_7, 
    'x_get_relayout_boundary__mutmut_8': x_get_relayout_boundary__mutmut_8, 
    'x_get_relayout_boundary__mutmut_9': x_get_relayout_boundary__mutmut_9, 
    'x_get_relayout_boundary__mutmut_10': x_get_relayout_boundary__mutmut_10, 
    'x_get_relayout_boundary__mutmut_11': x_get_relayout_boundary__mutmut_11, 
    'x_get_relayout_boundary__mutmut_12': x_get_relayout_boundary__mutmut_12, 
    'x_get_relayout_boundary__mutmut_13': x_get_relayout_boundary__mutmut_13, 
    'x_get_relayout_boundary__mutmut_14': x_get_relayout_boundary__mutmut_14, 
    'x_get_relayout_boundary__mutmut_15': x_get_relayout_boundary__mutmut_15, 
    'x_get_relayout_boundary__mutmut_16': x_get_relayout_boundary__mutmut_16, 
    'x_get_relayout_boundary__mutmut_17': x_get_relayout_boundary__mutmut_17, 
    'x_get_relayout_boundary__mutmut_18': x_get_relayout_boundary__mutmut_18, 
    'x_get_relayout_boundary__mutmut_19': x_get_relayout_boundary__mutmut_19, 
    'x_get_relayout_boundary__mutmut_20': x_get_relayout_boundary__mutmut_20, 
    'x_get_relayout_boundary__mutmut_21': x_get_relayout_boundary__mutmut_21, 
    'x_get_relayout_boundary__mutmut_22': x_get_relayout_boundary__mutmut_22, 
    'x_get_relayout_boundary__mutmut_23': x_get_relayout_boundary__mutmut_23
}

def get_relayout_boundary(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_relayout_boundary__mutmut_orig, x_get_relayout_boundary__mutmut_mutants, args, kwargs)
    return result 

get_relayout_boundary.__signature__ = _mutmut_signature(x_get_relayout_boundary__mutmut_orig)
x_get_relayout_boundary__mutmut_orig.__name__ = 'x_get_relayout_boundary'


def x_get_search_results__mutmut_orig(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_1(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = None
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_2(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = None
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_3(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["XXsearchIdXX"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_4(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchid"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_5(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["SEARCHID"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_6(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["Searchid"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_7(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = None
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_8(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["XXfromIndexXX"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_9(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromindex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_10(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["FROMINDEX"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_11(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["Fromindex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_12(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_13(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["XXtoIndexXX"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_14(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toindex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_15(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["TOINDEX"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_16(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["Toindex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_17(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_18(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_19(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_20(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_21(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getSearchResultsXX",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_22(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getsearchresults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_23(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETSEARCHRESULTS",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_24(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getsearchresults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_25(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_26(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_27(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "Params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_28(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = None
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_search_results__mutmut_29(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(None) for i in json["nodeIds"]]


def x_get_search_results__mutmut_30(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["XXnodeIdsXX"]]


def x_get_search_results__mutmut_31(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeids"]]


def x_get_search_results__mutmut_32(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["NODEIDS"]]


def x_get_search_results__mutmut_33(
    search_id: str,
    from_index: int,
    to_index: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given
    identifier.

    **EXPERIMENTAL**

    :param search_id: Unique search session identifier.
    :param from_index: Start index of the search result to be returned.
    :param to_index: End index of the search result to be returned.
    :returns: Ids of the search result nodes.
    """
    params: T_JSON_DICT = {}
    params["searchId"] = search_id
    params["fromIndex"] = from_index
    params["toIndex"] = to_index
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getSearchResults",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["Nodeids"]]

x_get_search_results__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_search_results__mutmut_1': x_get_search_results__mutmut_1, 
    'x_get_search_results__mutmut_2': x_get_search_results__mutmut_2, 
    'x_get_search_results__mutmut_3': x_get_search_results__mutmut_3, 
    'x_get_search_results__mutmut_4': x_get_search_results__mutmut_4, 
    'x_get_search_results__mutmut_5': x_get_search_results__mutmut_5, 
    'x_get_search_results__mutmut_6': x_get_search_results__mutmut_6, 
    'x_get_search_results__mutmut_7': x_get_search_results__mutmut_7, 
    'x_get_search_results__mutmut_8': x_get_search_results__mutmut_8, 
    'x_get_search_results__mutmut_9': x_get_search_results__mutmut_9, 
    'x_get_search_results__mutmut_10': x_get_search_results__mutmut_10, 
    'x_get_search_results__mutmut_11': x_get_search_results__mutmut_11, 
    'x_get_search_results__mutmut_12': x_get_search_results__mutmut_12, 
    'x_get_search_results__mutmut_13': x_get_search_results__mutmut_13, 
    'x_get_search_results__mutmut_14': x_get_search_results__mutmut_14, 
    'x_get_search_results__mutmut_15': x_get_search_results__mutmut_15, 
    'x_get_search_results__mutmut_16': x_get_search_results__mutmut_16, 
    'x_get_search_results__mutmut_17': x_get_search_results__mutmut_17, 
    'x_get_search_results__mutmut_18': x_get_search_results__mutmut_18, 
    'x_get_search_results__mutmut_19': x_get_search_results__mutmut_19, 
    'x_get_search_results__mutmut_20': x_get_search_results__mutmut_20, 
    'x_get_search_results__mutmut_21': x_get_search_results__mutmut_21, 
    'x_get_search_results__mutmut_22': x_get_search_results__mutmut_22, 
    'x_get_search_results__mutmut_23': x_get_search_results__mutmut_23, 
    'x_get_search_results__mutmut_24': x_get_search_results__mutmut_24, 
    'x_get_search_results__mutmut_25': x_get_search_results__mutmut_25, 
    'x_get_search_results__mutmut_26': x_get_search_results__mutmut_26, 
    'x_get_search_results__mutmut_27': x_get_search_results__mutmut_27, 
    'x_get_search_results__mutmut_28': x_get_search_results__mutmut_28, 
    'x_get_search_results__mutmut_29': x_get_search_results__mutmut_29, 
    'x_get_search_results__mutmut_30': x_get_search_results__mutmut_30, 
    'x_get_search_results__mutmut_31': x_get_search_results__mutmut_31, 
    'x_get_search_results__mutmut_32': x_get_search_results__mutmut_32, 
    'x_get_search_results__mutmut_33': x_get_search_results__mutmut_33
}

def get_search_results(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_search_results__mutmut_orig, x_get_search_results__mutmut_mutants, args, kwargs)
    return result 

get_search_results.__signature__ = _mutmut_signature(x_get_search_results__mutmut_orig)
x_get_search_results__mutmut_orig.__name__ = 'x_get_search_results'


def x_hide_highlight__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Hides any highlight.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.hideHighlight",
    }
    yield cmd_dict


def x_hide_highlight__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Hides any highlight.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_hide_highlight__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Hides any highlight.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.hideHighlight",
    }
    yield cmd_dict


def x_hide_highlight__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Hides any highlight.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.hideHighlight",
    }
    yield cmd_dict


def x_hide_highlight__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Hides any highlight.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.hideHighlight",
    }
    yield cmd_dict


def x_hide_highlight__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Hides any highlight.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.hideHighlightXX",
    }
    yield cmd_dict


def x_hide_highlight__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Hides any highlight.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "dom.hidehighlight",
    }
    yield cmd_dict


def x_hide_highlight__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Hides any highlight.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.HIDEHIGHLIGHT",
    }
    yield cmd_dict


def x_hide_highlight__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Hides any highlight.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.hidehighlight",
    }
    yield cmd_dict

x_hide_highlight__mutmut_mutants : ClassVar[MutantDict] = {
'x_hide_highlight__mutmut_1': x_hide_highlight__mutmut_1, 
    'x_hide_highlight__mutmut_2': x_hide_highlight__mutmut_2, 
    'x_hide_highlight__mutmut_3': x_hide_highlight__mutmut_3, 
    'x_hide_highlight__mutmut_4': x_hide_highlight__mutmut_4, 
    'x_hide_highlight__mutmut_5': x_hide_highlight__mutmut_5, 
    'x_hide_highlight__mutmut_6': x_hide_highlight__mutmut_6, 
    'x_hide_highlight__mutmut_7': x_hide_highlight__mutmut_7, 
    'x_hide_highlight__mutmut_8': x_hide_highlight__mutmut_8
}

def hide_highlight(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_hide_highlight__mutmut_orig, x_hide_highlight__mutmut_mutants, args, kwargs)
    return result 

hide_highlight.__signature__ = _mutmut_signature(x_hide_highlight__mutmut_orig)
x_hide_highlight__mutmut_orig.__name__ = 'x_hide_highlight'


def x_highlight_node__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights DOM node.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.highlightNode",
    }
    yield cmd_dict


def x_highlight_node__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights DOM node.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_highlight_node__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights DOM node.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.highlightNode",
    }
    yield cmd_dict


def x_highlight_node__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights DOM node.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.highlightNode",
    }
    yield cmd_dict


def x_highlight_node__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights DOM node.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.highlightNode",
    }
    yield cmd_dict


def x_highlight_node__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights DOM node.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.highlightNodeXX",
    }
    yield cmd_dict


def x_highlight_node__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights DOM node.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "dom.highlightnode",
    }
    yield cmd_dict


def x_highlight_node__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights DOM node.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.HIGHLIGHTNODE",
    }
    yield cmd_dict


def x_highlight_node__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights DOM node.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.highlightnode",
    }
    yield cmd_dict

x_highlight_node__mutmut_mutants : ClassVar[MutantDict] = {
'x_highlight_node__mutmut_1': x_highlight_node__mutmut_1, 
    'x_highlight_node__mutmut_2': x_highlight_node__mutmut_2, 
    'x_highlight_node__mutmut_3': x_highlight_node__mutmut_3, 
    'x_highlight_node__mutmut_4': x_highlight_node__mutmut_4, 
    'x_highlight_node__mutmut_5': x_highlight_node__mutmut_5, 
    'x_highlight_node__mutmut_6': x_highlight_node__mutmut_6, 
    'x_highlight_node__mutmut_7': x_highlight_node__mutmut_7, 
    'x_highlight_node__mutmut_8': x_highlight_node__mutmut_8
}

def highlight_node(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_highlight_node__mutmut_orig, x_highlight_node__mutmut_mutants, args, kwargs)
    return result 

highlight_node.__signature__ = _mutmut_signature(x_highlight_node__mutmut_orig)
x_highlight_node__mutmut_orig.__name__ = 'x_highlight_node'


def x_highlight_rect__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights given rectangle.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.highlightRect",
    }
    yield cmd_dict


def x_highlight_rect__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights given rectangle.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_highlight_rect__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights given rectangle.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.highlightRect",
    }
    yield cmd_dict


def x_highlight_rect__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights given rectangle.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.highlightRect",
    }
    yield cmd_dict


def x_highlight_rect__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights given rectangle.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.highlightRect",
    }
    yield cmd_dict


def x_highlight_rect__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights given rectangle.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.highlightRectXX",
    }
    yield cmd_dict


def x_highlight_rect__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights given rectangle.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "dom.highlightrect",
    }
    yield cmd_dict


def x_highlight_rect__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights given rectangle.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.HIGHLIGHTRECT",
    }
    yield cmd_dict


def x_highlight_rect__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Highlights given rectangle.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.highlightrect",
    }
    yield cmd_dict

x_highlight_rect__mutmut_mutants : ClassVar[MutantDict] = {
'x_highlight_rect__mutmut_1': x_highlight_rect__mutmut_1, 
    'x_highlight_rect__mutmut_2': x_highlight_rect__mutmut_2, 
    'x_highlight_rect__mutmut_3': x_highlight_rect__mutmut_3, 
    'x_highlight_rect__mutmut_4': x_highlight_rect__mutmut_4, 
    'x_highlight_rect__mutmut_5': x_highlight_rect__mutmut_5, 
    'x_highlight_rect__mutmut_6': x_highlight_rect__mutmut_6, 
    'x_highlight_rect__mutmut_7': x_highlight_rect__mutmut_7, 
    'x_highlight_rect__mutmut_8': x_highlight_rect__mutmut_8
}

def highlight_rect(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_highlight_rect__mutmut_orig, x_highlight_rect__mutmut_mutants, args, kwargs)
    return result 

highlight_rect.__signature__ = _mutmut_signature(x_highlight_rect__mutmut_orig)
x_highlight_rect__mutmut_orig.__name__ = 'x_highlight_rect'


def x_mark_undoable_state__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Marks last undoable state.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.markUndoableState",
    }
    yield cmd_dict


def x_mark_undoable_state__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Marks last undoable state.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_mark_undoable_state__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Marks last undoable state.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.markUndoableState",
    }
    yield cmd_dict


def x_mark_undoable_state__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Marks last undoable state.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.markUndoableState",
    }
    yield cmd_dict


def x_mark_undoable_state__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Marks last undoable state.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.markUndoableState",
    }
    yield cmd_dict


def x_mark_undoable_state__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Marks last undoable state.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.markUndoableStateXX",
    }
    yield cmd_dict


def x_mark_undoable_state__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Marks last undoable state.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "dom.markundoablestate",
    }
    yield cmd_dict


def x_mark_undoable_state__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Marks last undoable state.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.MARKUNDOABLESTATE",
    }
    yield cmd_dict


def x_mark_undoable_state__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Marks last undoable state.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.markundoablestate",
    }
    yield cmd_dict

x_mark_undoable_state__mutmut_mutants : ClassVar[MutantDict] = {
'x_mark_undoable_state__mutmut_1': x_mark_undoable_state__mutmut_1, 
    'x_mark_undoable_state__mutmut_2': x_mark_undoable_state__mutmut_2, 
    'x_mark_undoable_state__mutmut_3': x_mark_undoable_state__mutmut_3, 
    'x_mark_undoable_state__mutmut_4': x_mark_undoable_state__mutmut_4, 
    'x_mark_undoable_state__mutmut_5': x_mark_undoable_state__mutmut_5, 
    'x_mark_undoable_state__mutmut_6': x_mark_undoable_state__mutmut_6, 
    'x_mark_undoable_state__mutmut_7': x_mark_undoable_state__mutmut_7, 
    'x_mark_undoable_state__mutmut_8': x_mark_undoable_state__mutmut_8
}

def mark_undoable_state(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_mark_undoable_state__mutmut_orig, x_mark_undoable_state__mutmut_mutants, args, kwargs)
    return result 

mark_undoable_state.__signature__ = _mutmut_signature(x_mark_undoable_state__mutmut_orig)
x_mark_undoable_state__mutmut_orig.__name__ = 'x_mark_undoable_state'


def x_move_to__mutmut_orig(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_1(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_2(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_3(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_4(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_5(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_6(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_7(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = None
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_8(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXtargetNodeIdXX"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_9(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetnodeid"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_10(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["TARGETNODEID"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_11(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Targetnodeid"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_12(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_13(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_14(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["XXinsertBeforeNodeIdXX"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_15(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertbeforenodeid"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_16(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["INSERTBEFORENODEID"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_17(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["Insertbeforenodeid"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_18(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_19(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_20(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_21(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_22(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.moveToXX",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_23(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.moveto",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_24(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.MOVETO",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_25(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.moveto",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_26(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_27(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_28(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "Params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_29(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = None
    return NodeId.from_json(json["nodeId"])


def x_move_to__mutmut_30(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(None)


def x_move_to__mutmut_31(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["XXnodeIdXX"])


def x_move_to__mutmut_32(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeid"])


def x_move_to__mutmut_33(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["NODEID"])


def x_move_to__mutmut_34(
    node_id: NodeId,
    target_node_id: NodeId,
    insert_before_node_id: NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Moves node into the new container, places it before the given anchor.

    :param node_id: Id of the node to move.
    :param target_node_id: Id of the element to drop the moved node into.
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```).
    :returns: New id of the moved node.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["targetNodeId"] = target_node_id.to_json()
    if insert_before_node_id is not None:
        params["insertBeforeNodeId"] = insert_before_node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.moveTo",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["Nodeid"])

x_move_to__mutmut_mutants : ClassVar[MutantDict] = {
'x_move_to__mutmut_1': x_move_to__mutmut_1, 
    'x_move_to__mutmut_2': x_move_to__mutmut_2, 
    'x_move_to__mutmut_3': x_move_to__mutmut_3, 
    'x_move_to__mutmut_4': x_move_to__mutmut_4, 
    'x_move_to__mutmut_5': x_move_to__mutmut_5, 
    'x_move_to__mutmut_6': x_move_to__mutmut_6, 
    'x_move_to__mutmut_7': x_move_to__mutmut_7, 
    'x_move_to__mutmut_8': x_move_to__mutmut_8, 
    'x_move_to__mutmut_9': x_move_to__mutmut_9, 
    'x_move_to__mutmut_10': x_move_to__mutmut_10, 
    'x_move_to__mutmut_11': x_move_to__mutmut_11, 
    'x_move_to__mutmut_12': x_move_to__mutmut_12, 
    'x_move_to__mutmut_13': x_move_to__mutmut_13, 
    'x_move_to__mutmut_14': x_move_to__mutmut_14, 
    'x_move_to__mutmut_15': x_move_to__mutmut_15, 
    'x_move_to__mutmut_16': x_move_to__mutmut_16, 
    'x_move_to__mutmut_17': x_move_to__mutmut_17, 
    'x_move_to__mutmut_18': x_move_to__mutmut_18, 
    'x_move_to__mutmut_19': x_move_to__mutmut_19, 
    'x_move_to__mutmut_20': x_move_to__mutmut_20, 
    'x_move_to__mutmut_21': x_move_to__mutmut_21, 
    'x_move_to__mutmut_22': x_move_to__mutmut_22, 
    'x_move_to__mutmut_23': x_move_to__mutmut_23, 
    'x_move_to__mutmut_24': x_move_to__mutmut_24, 
    'x_move_to__mutmut_25': x_move_to__mutmut_25, 
    'x_move_to__mutmut_26': x_move_to__mutmut_26, 
    'x_move_to__mutmut_27': x_move_to__mutmut_27, 
    'x_move_to__mutmut_28': x_move_to__mutmut_28, 
    'x_move_to__mutmut_29': x_move_to__mutmut_29, 
    'x_move_to__mutmut_30': x_move_to__mutmut_30, 
    'x_move_to__mutmut_31': x_move_to__mutmut_31, 
    'x_move_to__mutmut_32': x_move_to__mutmut_32, 
    'x_move_to__mutmut_33': x_move_to__mutmut_33, 
    'x_move_to__mutmut_34': x_move_to__mutmut_34
}

def move_to(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_move_to__mutmut_orig, x_move_to__mutmut_mutants, args, kwargs)
    return result 

move_to.__signature__ = _mutmut_signature(x_move_to__mutmut_orig)
x_move_to__mutmut_orig.__name__ = 'x_move_to'


def x_perform_search__mutmut_orig(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_1(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = None
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_2(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = None
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_3(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["XXqueryXX"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_4(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["QUERY"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_5(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["Query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_6(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_7(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_8(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["XXincludeUserAgentShadowDOMXX"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_9(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeuseragentshadowdom"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_10(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["INCLUDEUSERAGENTSHADOWDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_11(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["Includeuseragentshadowdom"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_12(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_13(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_14(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_15(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_16(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.performSearchXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_17(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "dom.performsearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_18(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.PERFORMSEARCH",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_19(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.performsearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_20(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_21(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_22(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_23(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = None
    return (
        str(json["searchId"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_24(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(None),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_25(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["XXsearchIdXX"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_26(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchid"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_27(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["SEARCHID"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_28(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["Searchid"]),
        int(json["resultCount"]),
    )


def x_perform_search__mutmut_29(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(None),
    )


def x_perform_search__mutmut_30(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["XXresultCountXX"]),
    )


def x_perform_search__mutmut_31(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["resultcount"]),
    )


def x_perform_search__mutmut_32(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["RESULTCOUNT"]),
    )


def x_perform_search__mutmut_33(
    query: str,
    include_user_agent_shadow_dom: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, int]]:
    """
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or
    ``cancelSearch`` to end this search session.

    **EXPERIMENTAL**

    :param query: Plain text or query selector or XPath search query.
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM.
    :returns: A tuple with the following items:

        0. **searchId** - Unique search session identifier.
        1. **resultCount** - Number of search results.
    """
    params: T_JSON_DICT = {}
    params["query"] = query
    if include_user_agent_shadow_dom is not None:
        params["includeUserAgentShadowDOM"] = include_user_agent_shadow_dom
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.performSearch",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["searchId"]),
        int(json["Resultcount"]),
    )

x_perform_search__mutmut_mutants : ClassVar[MutantDict] = {
'x_perform_search__mutmut_1': x_perform_search__mutmut_1, 
    'x_perform_search__mutmut_2': x_perform_search__mutmut_2, 
    'x_perform_search__mutmut_3': x_perform_search__mutmut_3, 
    'x_perform_search__mutmut_4': x_perform_search__mutmut_4, 
    'x_perform_search__mutmut_5': x_perform_search__mutmut_5, 
    'x_perform_search__mutmut_6': x_perform_search__mutmut_6, 
    'x_perform_search__mutmut_7': x_perform_search__mutmut_7, 
    'x_perform_search__mutmut_8': x_perform_search__mutmut_8, 
    'x_perform_search__mutmut_9': x_perform_search__mutmut_9, 
    'x_perform_search__mutmut_10': x_perform_search__mutmut_10, 
    'x_perform_search__mutmut_11': x_perform_search__mutmut_11, 
    'x_perform_search__mutmut_12': x_perform_search__mutmut_12, 
    'x_perform_search__mutmut_13': x_perform_search__mutmut_13, 
    'x_perform_search__mutmut_14': x_perform_search__mutmut_14, 
    'x_perform_search__mutmut_15': x_perform_search__mutmut_15, 
    'x_perform_search__mutmut_16': x_perform_search__mutmut_16, 
    'x_perform_search__mutmut_17': x_perform_search__mutmut_17, 
    'x_perform_search__mutmut_18': x_perform_search__mutmut_18, 
    'x_perform_search__mutmut_19': x_perform_search__mutmut_19, 
    'x_perform_search__mutmut_20': x_perform_search__mutmut_20, 
    'x_perform_search__mutmut_21': x_perform_search__mutmut_21, 
    'x_perform_search__mutmut_22': x_perform_search__mutmut_22, 
    'x_perform_search__mutmut_23': x_perform_search__mutmut_23, 
    'x_perform_search__mutmut_24': x_perform_search__mutmut_24, 
    'x_perform_search__mutmut_25': x_perform_search__mutmut_25, 
    'x_perform_search__mutmut_26': x_perform_search__mutmut_26, 
    'x_perform_search__mutmut_27': x_perform_search__mutmut_27, 
    'x_perform_search__mutmut_28': x_perform_search__mutmut_28, 
    'x_perform_search__mutmut_29': x_perform_search__mutmut_29, 
    'x_perform_search__mutmut_30': x_perform_search__mutmut_30, 
    'x_perform_search__mutmut_31': x_perform_search__mutmut_31, 
    'x_perform_search__mutmut_32': x_perform_search__mutmut_32, 
    'x_perform_search__mutmut_33': x_perform_search__mutmut_33
}

def perform_search(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_perform_search__mutmut_orig, x_perform_search__mutmut_mutants, args, kwargs)
    return result 

perform_search.__signature__ = _mutmut_signature(x_perform_search__mutmut_orig)
x_perform_search__mutmut_orig.__name__ = 'x_perform_search'


def x_push_node_by_path_to_frontend__mutmut_orig(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_1(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = None
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_2(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_3(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["XXpathXX"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_4(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["PATH"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_5(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["Path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_6(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_7(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_8(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_9(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_10(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.pushNodeByPathToFrontendXX",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_11(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "dom.pushnodebypathtofrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_12(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.PUSHNODEBYPATHTOFRONTEND",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_13(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.pushnodebypathtofrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_14(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_15(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_16(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "Params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_17(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = None
    return NodeId.from_json(json["nodeId"])


def x_push_node_by_path_to_frontend__mutmut_18(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(None)


def x_push_node_by_path_to_frontend__mutmut_19(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["XXnodeIdXX"])


def x_push_node_by_path_to_frontend__mutmut_20(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeid"])


def x_push_node_by_path_to_frontend__mutmut_21(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["NODEID"])


def x_push_node_by_path_to_frontend__mutmut_22(
    path: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given its path. // FIXME, use XPath

    **EXPERIMENTAL**

    :param path: Path to node in the proprietary format.
    :returns: Id of the node for given path.
    """
    params: T_JSON_DICT = {}
    params["path"] = path
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodeByPathToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["Nodeid"])

x_push_node_by_path_to_frontend__mutmut_mutants : ClassVar[MutantDict] = {
'x_push_node_by_path_to_frontend__mutmut_1': x_push_node_by_path_to_frontend__mutmut_1, 
    'x_push_node_by_path_to_frontend__mutmut_2': x_push_node_by_path_to_frontend__mutmut_2, 
    'x_push_node_by_path_to_frontend__mutmut_3': x_push_node_by_path_to_frontend__mutmut_3, 
    'x_push_node_by_path_to_frontend__mutmut_4': x_push_node_by_path_to_frontend__mutmut_4, 
    'x_push_node_by_path_to_frontend__mutmut_5': x_push_node_by_path_to_frontend__mutmut_5, 
    'x_push_node_by_path_to_frontend__mutmut_6': x_push_node_by_path_to_frontend__mutmut_6, 
    'x_push_node_by_path_to_frontend__mutmut_7': x_push_node_by_path_to_frontend__mutmut_7, 
    'x_push_node_by_path_to_frontend__mutmut_8': x_push_node_by_path_to_frontend__mutmut_8, 
    'x_push_node_by_path_to_frontend__mutmut_9': x_push_node_by_path_to_frontend__mutmut_9, 
    'x_push_node_by_path_to_frontend__mutmut_10': x_push_node_by_path_to_frontend__mutmut_10, 
    'x_push_node_by_path_to_frontend__mutmut_11': x_push_node_by_path_to_frontend__mutmut_11, 
    'x_push_node_by_path_to_frontend__mutmut_12': x_push_node_by_path_to_frontend__mutmut_12, 
    'x_push_node_by_path_to_frontend__mutmut_13': x_push_node_by_path_to_frontend__mutmut_13, 
    'x_push_node_by_path_to_frontend__mutmut_14': x_push_node_by_path_to_frontend__mutmut_14, 
    'x_push_node_by_path_to_frontend__mutmut_15': x_push_node_by_path_to_frontend__mutmut_15, 
    'x_push_node_by_path_to_frontend__mutmut_16': x_push_node_by_path_to_frontend__mutmut_16, 
    'x_push_node_by_path_to_frontend__mutmut_17': x_push_node_by_path_to_frontend__mutmut_17, 
    'x_push_node_by_path_to_frontend__mutmut_18': x_push_node_by_path_to_frontend__mutmut_18, 
    'x_push_node_by_path_to_frontend__mutmut_19': x_push_node_by_path_to_frontend__mutmut_19, 
    'x_push_node_by_path_to_frontend__mutmut_20': x_push_node_by_path_to_frontend__mutmut_20, 
    'x_push_node_by_path_to_frontend__mutmut_21': x_push_node_by_path_to_frontend__mutmut_21, 
    'x_push_node_by_path_to_frontend__mutmut_22': x_push_node_by_path_to_frontend__mutmut_22
}

def push_node_by_path_to_frontend(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_push_node_by_path_to_frontend__mutmut_orig, x_push_node_by_path_to_frontend__mutmut_mutants, args, kwargs)
    return result 

push_node_by_path_to_frontend.__signature__ = _mutmut_signature(x_push_node_by_path_to_frontend__mutmut_orig)
x_push_node_by_path_to_frontend__mutmut_orig.__name__ = 'x_push_node_by_path_to_frontend'


def x_push_nodes_by_backend_ids_to_frontend__mutmut_orig(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_1(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = None
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_2(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_3(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["XXbackendNodeIdsXX"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_4(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendnodeids"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_5(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["BACKENDNODEIDS"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_6(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["Backendnodeids"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_7(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_8(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_9(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_10(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_11(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.pushNodesByBackendIdsToFrontendXX",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_12(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "dom.pushnodesbybackendidstofrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_13(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.PUSHNODESBYBACKENDIDSTOFRONTEND",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_14(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.pushnodesbybackendidstofrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_15(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_16(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_17(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "Params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_18(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = None
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_19(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(None) for i in json["nodeIds"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_20(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["XXnodeIdsXX"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_21(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeids"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_22(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["NODEIDS"]]


def x_push_nodes_by_backend_ids_to_frontend__mutmut_23(
    backend_node_ids: list[BackendNodeId],
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Requests that a batch of nodes is sent to the caller given their backend node ids.

    **EXPERIMENTAL**

    :param backend_node_ids: The array of backend node ids.
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
    """
    params: T_JSON_DICT = {}
    params["backendNodeIds"] = [i.to_json() for i in backend_node_ids]
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.pushNodesByBackendIdsToFrontend",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["Nodeids"]]

x_push_nodes_by_backend_ids_to_frontend__mutmut_mutants : ClassVar[MutantDict] = {
'x_push_nodes_by_backend_ids_to_frontend__mutmut_1': x_push_nodes_by_backend_ids_to_frontend__mutmut_1, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_2': x_push_nodes_by_backend_ids_to_frontend__mutmut_2, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_3': x_push_nodes_by_backend_ids_to_frontend__mutmut_3, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_4': x_push_nodes_by_backend_ids_to_frontend__mutmut_4, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_5': x_push_nodes_by_backend_ids_to_frontend__mutmut_5, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_6': x_push_nodes_by_backend_ids_to_frontend__mutmut_6, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_7': x_push_nodes_by_backend_ids_to_frontend__mutmut_7, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_8': x_push_nodes_by_backend_ids_to_frontend__mutmut_8, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_9': x_push_nodes_by_backend_ids_to_frontend__mutmut_9, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_10': x_push_nodes_by_backend_ids_to_frontend__mutmut_10, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_11': x_push_nodes_by_backend_ids_to_frontend__mutmut_11, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_12': x_push_nodes_by_backend_ids_to_frontend__mutmut_12, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_13': x_push_nodes_by_backend_ids_to_frontend__mutmut_13, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_14': x_push_nodes_by_backend_ids_to_frontend__mutmut_14, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_15': x_push_nodes_by_backend_ids_to_frontend__mutmut_15, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_16': x_push_nodes_by_backend_ids_to_frontend__mutmut_16, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_17': x_push_nodes_by_backend_ids_to_frontend__mutmut_17, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_18': x_push_nodes_by_backend_ids_to_frontend__mutmut_18, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_19': x_push_nodes_by_backend_ids_to_frontend__mutmut_19, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_20': x_push_nodes_by_backend_ids_to_frontend__mutmut_20, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_21': x_push_nodes_by_backend_ids_to_frontend__mutmut_21, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_22': x_push_nodes_by_backend_ids_to_frontend__mutmut_22, 
    'x_push_nodes_by_backend_ids_to_frontend__mutmut_23': x_push_nodes_by_backend_ids_to_frontend__mutmut_23
}

def push_nodes_by_backend_ids_to_frontend(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_push_nodes_by_backend_ids_to_frontend__mutmut_orig, x_push_nodes_by_backend_ids_to_frontend__mutmut_mutants, args, kwargs)
    return result 

push_nodes_by_backend_ids_to_frontend.__signature__ = _mutmut_signature(x_push_nodes_by_backend_ids_to_frontend__mutmut_orig)
x_push_nodes_by_backend_ids_to_frontend__mutmut_orig.__name__ = 'x_push_nodes_by_backend_ids_to_frontend'


def x_query_selector__mutmut_orig(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_1(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_2(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_3(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_4(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_5(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_6(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_7(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_8(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXselectorXX"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_9(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["SELECTOR"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_10(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_11(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_12(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_13(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_14(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_15(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.querySelectorXX",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_16(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "dom.queryselector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_17(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.QUERYSELECTOR",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_18(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.queryselector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_19(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_20(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_21(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "Params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_22(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = None
    return NodeId.from_json(json["nodeId"])


def x_query_selector__mutmut_23(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(None)


def x_query_selector__mutmut_24(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["XXnodeIdXX"])


def x_query_selector__mutmut_25(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeid"])


def x_query_selector__mutmut_26(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["NODEID"])


def x_query_selector__mutmut_27(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Executes ``querySelector`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelector",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["Nodeid"])

x_query_selector__mutmut_mutants : ClassVar[MutantDict] = {
'x_query_selector__mutmut_1': x_query_selector__mutmut_1, 
    'x_query_selector__mutmut_2': x_query_selector__mutmut_2, 
    'x_query_selector__mutmut_3': x_query_selector__mutmut_3, 
    'x_query_selector__mutmut_4': x_query_selector__mutmut_4, 
    'x_query_selector__mutmut_5': x_query_selector__mutmut_5, 
    'x_query_selector__mutmut_6': x_query_selector__mutmut_6, 
    'x_query_selector__mutmut_7': x_query_selector__mutmut_7, 
    'x_query_selector__mutmut_8': x_query_selector__mutmut_8, 
    'x_query_selector__mutmut_9': x_query_selector__mutmut_9, 
    'x_query_selector__mutmut_10': x_query_selector__mutmut_10, 
    'x_query_selector__mutmut_11': x_query_selector__mutmut_11, 
    'x_query_selector__mutmut_12': x_query_selector__mutmut_12, 
    'x_query_selector__mutmut_13': x_query_selector__mutmut_13, 
    'x_query_selector__mutmut_14': x_query_selector__mutmut_14, 
    'x_query_selector__mutmut_15': x_query_selector__mutmut_15, 
    'x_query_selector__mutmut_16': x_query_selector__mutmut_16, 
    'x_query_selector__mutmut_17': x_query_selector__mutmut_17, 
    'x_query_selector__mutmut_18': x_query_selector__mutmut_18, 
    'x_query_selector__mutmut_19': x_query_selector__mutmut_19, 
    'x_query_selector__mutmut_20': x_query_selector__mutmut_20, 
    'x_query_selector__mutmut_21': x_query_selector__mutmut_21, 
    'x_query_selector__mutmut_22': x_query_selector__mutmut_22, 
    'x_query_selector__mutmut_23': x_query_selector__mutmut_23, 
    'x_query_selector__mutmut_24': x_query_selector__mutmut_24, 
    'x_query_selector__mutmut_25': x_query_selector__mutmut_25, 
    'x_query_selector__mutmut_26': x_query_selector__mutmut_26, 
    'x_query_selector__mutmut_27': x_query_selector__mutmut_27
}

def query_selector(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_query_selector__mutmut_orig, x_query_selector__mutmut_mutants, args, kwargs)
    return result 

query_selector.__signature__ = _mutmut_signature(x_query_selector__mutmut_orig)
x_query_selector__mutmut_orig.__name__ = 'x_query_selector'


def x_query_selector_all__mutmut_orig(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_1(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_2(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_3(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_4(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_5(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_6(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_7(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_8(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXselectorXX"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_9(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["SELECTOR"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_10(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_11(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_12(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_13(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_14(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_15(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.querySelectorAllXX",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_16(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "dom.queryselectorall",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_17(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.QUERYSELECTORALL",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_18(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.queryselectorall",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_19(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_20(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_21(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "Params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_22(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = None
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_23(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(None) for i in json["nodeIds"]]


def x_query_selector_all__mutmut_24(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["XXnodeIdsXX"]]


def x_query_selector_all__mutmut_25(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeids"]]


def x_query_selector_all__mutmut_26(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["NODEIDS"]]


def x_query_selector_all__mutmut_27(
    node_id: NodeId,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Executes ``querySelectorAll`` on a given node.

    :param node_id: Id of the node to query upon.
    :param selector: Selector string.
    :returns: Query selector result.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["selector"] = selector
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.querySelectorAll",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["Nodeids"]]

x_query_selector_all__mutmut_mutants : ClassVar[MutantDict] = {
'x_query_selector_all__mutmut_1': x_query_selector_all__mutmut_1, 
    'x_query_selector_all__mutmut_2': x_query_selector_all__mutmut_2, 
    'x_query_selector_all__mutmut_3': x_query_selector_all__mutmut_3, 
    'x_query_selector_all__mutmut_4': x_query_selector_all__mutmut_4, 
    'x_query_selector_all__mutmut_5': x_query_selector_all__mutmut_5, 
    'x_query_selector_all__mutmut_6': x_query_selector_all__mutmut_6, 
    'x_query_selector_all__mutmut_7': x_query_selector_all__mutmut_7, 
    'x_query_selector_all__mutmut_8': x_query_selector_all__mutmut_8, 
    'x_query_selector_all__mutmut_9': x_query_selector_all__mutmut_9, 
    'x_query_selector_all__mutmut_10': x_query_selector_all__mutmut_10, 
    'x_query_selector_all__mutmut_11': x_query_selector_all__mutmut_11, 
    'x_query_selector_all__mutmut_12': x_query_selector_all__mutmut_12, 
    'x_query_selector_all__mutmut_13': x_query_selector_all__mutmut_13, 
    'x_query_selector_all__mutmut_14': x_query_selector_all__mutmut_14, 
    'x_query_selector_all__mutmut_15': x_query_selector_all__mutmut_15, 
    'x_query_selector_all__mutmut_16': x_query_selector_all__mutmut_16, 
    'x_query_selector_all__mutmut_17': x_query_selector_all__mutmut_17, 
    'x_query_selector_all__mutmut_18': x_query_selector_all__mutmut_18, 
    'x_query_selector_all__mutmut_19': x_query_selector_all__mutmut_19, 
    'x_query_selector_all__mutmut_20': x_query_selector_all__mutmut_20, 
    'x_query_selector_all__mutmut_21': x_query_selector_all__mutmut_21, 
    'x_query_selector_all__mutmut_22': x_query_selector_all__mutmut_22, 
    'x_query_selector_all__mutmut_23': x_query_selector_all__mutmut_23, 
    'x_query_selector_all__mutmut_24': x_query_selector_all__mutmut_24, 
    'x_query_selector_all__mutmut_25': x_query_selector_all__mutmut_25, 
    'x_query_selector_all__mutmut_26': x_query_selector_all__mutmut_26, 
    'x_query_selector_all__mutmut_27': x_query_selector_all__mutmut_27
}

def query_selector_all(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_query_selector_all__mutmut_orig, x_query_selector_all__mutmut_mutants, args, kwargs)
    return result 

query_selector_all.__signature__ = _mutmut_signature(x_query_selector_all__mutmut_orig)
x_query_selector_all__mutmut_orig.__name__ = 'x_query_selector_all'


def x_get_top_layer_elements__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getTopLayerElements",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_top_layer_elements__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_top_layer_elements__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getTopLayerElements",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_top_layer_elements__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getTopLayerElements",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_top_layer_elements__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getTopLayerElements",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_top_layer_elements__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getTopLayerElementsXX",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_top_layer_elements__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "method": "dom.gettoplayerelements",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_top_layer_elements__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETTOPLAYERELEMENTS",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_top_layer_elements__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.gettoplayerelements",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_top_layer_elements__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getTopLayerElements",
    }
    json = None
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_top_layer_elements__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getTopLayerElements",
    }
    json = yield cmd_dict
    return [NodeId.from_json(None) for i in json["nodeIds"]]


def x_get_top_layer_elements__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getTopLayerElements",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["XXnodeIdsXX"]]


def x_get_top_layer_elements__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getTopLayerElements",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeids"]]


def x_get_top_layer_elements__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getTopLayerElements",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["NODEIDS"]]


def x_get_top_layer_elements__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns NodeIds of current top layer elements.
    Top layer is rendered closest to the user within a viewport, therefore its elements always
    appear on top of all other content.

    **EXPERIMENTAL**

    :returns: NodeIds of top layer elements
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getTopLayerElements",
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["Nodeids"]]

x_get_top_layer_elements__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_top_layer_elements__mutmut_1': x_get_top_layer_elements__mutmut_1, 
    'x_get_top_layer_elements__mutmut_2': x_get_top_layer_elements__mutmut_2, 
    'x_get_top_layer_elements__mutmut_3': x_get_top_layer_elements__mutmut_3, 
    'x_get_top_layer_elements__mutmut_4': x_get_top_layer_elements__mutmut_4, 
    'x_get_top_layer_elements__mutmut_5': x_get_top_layer_elements__mutmut_5, 
    'x_get_top_layer_elements__mutmut_6': x_get_top_layer_elements__mutmut_6, 
    'x_get_top_layer_elements__mutmut_7': x_get_top_layer_elements__mutmut_7, 
    'x_get_top_layer_elements__mutmut_8': x_get_top_layer_elements__mutmut_8, 
    'x_get_top_layer_elements__mutmut_9': x_get_top_layer_elements__mutmut_9, 
    'x_get_top_layer_elements__mutmut_10': x_get_top_layer_elements__mutmut_10, 
    'x_get_top_layer_elements__mutmut_11': x_get_top_layer_elements__mutmut_11, 
    'x_get_top_layer_elements__mutmut_12': x_get_top_layer_elements__mutmut_12, 
    'x_get_top_layer_elements__mutmut_13': x_get_top_layer_elements__mutmut_13, 
    'x_get_top_layer_elements__mutmut_14': x_get_top_layer_elements__mutmut_14
}

def get_top_layer_elements(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_top_layer_elements__mutmut_orig, x_get_top_layer_elements__mutmut_mutants, args, kwargs)
    return result 

get_top_layer_elements.__signature__ = _mutmut_signature(x_get_top_layer_elements__mutmut_orig)
x_get_top_layer_elements__mutmut_orig.__name__ = 'x_get_top_layer_elements'


def x_get_element_by_relation__mutmut_orig(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_1(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_2(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_3(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_4(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_5(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_6(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_7(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_8(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXrelationXX"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_9(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["RELATION"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_10(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_11(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_12(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_13(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_14(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_15(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getElementByRelationXX",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_16(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getelementbyrelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_17(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETELEMENTBYRELATION",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_18(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getelementbyrelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_19(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_20(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_21(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "Params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_22(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = None
    return NodeId.from_json(json["nodeId"])


def x_get_element_by_relation__mutmut_23(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(None)


def x_get_element_by_relation__mutmut_24(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["XXnodeIdXX"])


def x_get_element_by_relation__mutmut_25(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeid"])


def x_get_element_by_relation__mutmut_26(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["NODEID"])


def x_get_element_by_relation__mutmut_27(
    node_id: NodeId,
    relation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the NodeId of the matched element according to certain relations.

    **EXPERIMENTAL**

    :param node_id: Id of the node from which to query the relation.
    :param relation: Type of relation to get.
    :returns: NodeId of the element matching the queried relation.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["relation"] = relation
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getElementByRelation",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["Nodeid"])

x_get_element_by_relation__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_element_by_relation__mutmut_1': x_get_element_by_relation__mutmut_1, 
    'x_get_element_by_relation__mutmut_2': x_get_element_by_relation__mutmut_2, 
    'x_get_element_by_relation__mutmut_3': x_get_element_by_relation__mutmut_3, 
    'x_get_element_by_relation__mutmut_4': x_get_element_by_relation__mutmut_4, 
    'x_get_element_by_relation__mutmut_5': x_get_element_by_relation__mutmut_5, 
    'x_get_element_by_relation__mutmut_6': x_get_element_by_relation__mutmut_6, 
    'x_get_element_by_relation__mutmut_7': x_get_element_by_relation__mutmut_7, 
    'x_get_element_by_relation__mutmut_8': x_get_element_by_relation__mutmut_8, 
    'x_get_element_by_relation__mutmut_9': x_get_element_by_relation__mutmut_9, 
    'x_get_element_by_relation__mutmut_10': x_get_element_by_relation__mutmut_10, 
    'x_get_element_by_relation__mutmut_11': x_get_element_by_relation__mutmut_11, 
    'x_get_element_by_relation__mutmut_12': x_get_element_by_relation__mutmut_12, 
    'x_get_element_by_relation__mutmut_13': x_get_element_by_relation__mutmut_13, 
    'x_get_element_by_relation__mutmut_14': x_get_element_by_relation__mutmut_14, 
    'x_get_element_by_relation__mutmut_15': x_get_element_by_relation__mutmut_15, 
    'x_get_element_by_relation__mutmut_16': x_get_element_by_relation__mutmut_16, 
    'x_get_element_by_relation__mutmut_17': x_get_element_by_relation__mutmut_17, 
    'x_get_element_by_relation__mutmut_18': x_get_element_by_relation__mutmut_18, 
    'x_get_element_by_relation__mutmut_19': x_get_element_by_relation__mutmut_19, 
    'x_get_element_by_relation__mutmut_20': x_get_element_by_relation__mutmut_20, 
    'x_get_element_by_relation__mutmut_21': x_get_element_by_relation__mutmut_21, 
    'x_get_element_by_relation__mutmut_22': x_get_element_by_relation__mutmut_22, 
    'x_get_element_by_relation__mutmut_23': x_get_element_by_relation__mutmut_23, 
    'x_get_element_by_relation__mutmut_24': x_get_element_by_relation__mutmut_24, 
    'x_get_element_by_relation__mutmut_25': x_get_element_by_relation__mutmut_25, 
    'x_get_element_by_relation__mutmut_26': x_get_element_by_relation__mutmut_26, 
    'x_get_element_by_relation__mutmut_27': x_get_element_by_relation__mutmut_27
}

def get_element_by_relation(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_element_by_relation__mutmut_orig, x_get_element_by_relation__mutmut_mutants, args, kwargs)
    return result 

get_element_by_relation.__signature__ = _mutmut_signature(x_get_element_by_relation__mutmut_orig)
x_get_element_by_relation__mutmut_orig.__name__ = 'x_get_element_by_relation'


def x_redo__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Re-does the last undone action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.redo",
    }
    yield cmd_dict


def x_redo__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Re-does the last undone action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_redo__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Re-does the last undone action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.redo",
    }
    yield cmd_dict


def x_redo__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Re-does the last undone action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.redo",
    }
    yield cmd_dict


def x_redo__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Re-does the last undone action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.redo",
    }
    yield cmd_dict


def x_redo__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Re-does the last undone action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.redoXX",
    }
    yield cmd_dict


def x_redo__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Re-does the last undone action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "dom.redo",
    }
    yield cmd_dict


def x_redo__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Re-does the last undone action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.REDO",
    }
    yield cmd_dict


def x_redo__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Re-does the last undone action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.redo",
    }
    yield cmd_dict

x_redo__mutmut_mutants : ClassVar[MutantDict] = {
'x_redo__mutmut_1': x_redo__mutmut_1, 
    'x_redo__mutmut_2': x_redo__mutmut_2, 
    'x_redo__mutmut_3': x_redo__mutmut_3, 
    'x_redo__mutmut_4': x_redo__mutmut_4, 
    'x_redo__mutmut_5': x_redo__mutmut_5, 
    'x_redo__mutmut_6': x_redo__mutmut_6, 
    'x_redo__mutmut_7': x_redo__mutmut_7, 
    'x_redo__mutmut_8': x_redo__mutmut_8
}

def redo(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_redo__mutmut_orig, x_redo__mutmut_mutants, args, kwargs)
    return result 

redo.__signature__ = _mutmut_signature(x_redo__mutmut_orig)
x_redo__mutmut_orig.__name__ = 'x_redo'


def x_remove_attribute__mutmut_orig(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_1(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_2(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_3(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_4(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_5(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_6(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_7(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_8(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXnameXX"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_9(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["NAME"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_10(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_11(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_remove_attribute__mutmut_12(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_13(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_14(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.removeAttribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_15(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.removeAttributeXX",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_16(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "dom.removeattribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_17(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.REMOVEATTRIBUTE",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_18(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.removeattribute",
        "params": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_19(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_20(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "PARAMS": params,
    }
    yield cmd_dict


def x_remove_attribute__mutmut_21(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes attribute with given name from an element with given id.

    :param node_id: Id of the element to remove attribute from.
    :param name: Name of the attribute to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeAttribute",
        "Params": params,
    }
    yield cmd_dict

x_remove_attribute__mutmut_mutants : ClassVar[MutantDict] = {
'x_remove_attribute__mutmut_1': x_remove_attribute__mutmut_1, 
    'x_remove_attribute__mutmut_2': x_remove_attribute__mutmut_2, 
    'x_remove_attribute__mutmut_3': x_remove_attribute__mutmut_3, 
    'x_remove_attribute__mutmut_4': x_remove_attribute__mutmut_4, 
    'x_remove_attribute__mutmut_5': x_remove_attribute__mutmut_5, 
    'x_remove_attribute__mutmut_6': x_remove_attribute__mutmut_6, 
    'x_remove_attribute__mutmut_7': x_remove_attribute__mutmut_7, 
    'x_remove_attribute__mutmut_8': x_remove_attribute__mutmut_8, 
    'x_remove_attribute__mutmut_9': x_remove_attribute__mutmut_9, 
    'x_remove_attribute__mutmut_10': x_remove_attribute__mutmut_10, 
    'x_remove_attribute__mutmut_11': x_remove_attribute__mutmut_11, 
    'x_remove_attribute__mutmut_12': x_remove_attribute__mutmut_12, 
    'x_remove_attribute__mutmut_13': x_remove_attribute__mutmut_13, 
    'x_remove_attribute__mutmut_14': x_remove_attribute__mutmut_14, 
    'x_remove_attribute__mutmut_15': x_remove_attribute__mutmut_15, 
    'x_remove_attribute__mutmut_16': x_remove_attribute__mutmut_16, 
    'x_remove_attribute__mutmut_17': x_remove_attribute__mutmut_17, 
    'x_remove_attribute__mutmut_18': x_remove_attribute__mutmut_18, 
    'x_remove_attribute__mutmut_19': x_remove_attribute__mutmut_19, 
    'x_remove_attribute__mutmut_20': x_remove_attribute__mutmut_20, 
    'x_remove_attribute__mutmut_21': x_remove_attribute__mutmut_21
}

def remove_attribute(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_remove_attribute__mutmut_orig, x_remove_attribute__mutmut_mutants, args, kwargs)
    return result 

remove_attribute.__signature__ = _mutmut_signature(x_remove_attribute__mutmut_orig)
x_remove_attribute__mutmut_orig.__name__ = 'x_remove_attribute'


def x_remove_node__mutmut_orig(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeNode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_1(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeNode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_2(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeNode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_3(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeNode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_4(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeNode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_5(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeNode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_6(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeNode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_7(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_remove_node__mutmut_8(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.removeNode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_9(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.removeNode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_10(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.removeNode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_11(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.removeNodeXX",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_12(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.removenode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_13(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.REMOVENODE",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_14(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.removenode",
        "params": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_15(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeNode",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_16(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeNode",
        "PARAMS": params,
    }
    yield cmd_dict


def x_remove_node__mutmut_17(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes node with given id.

    :param node_id: Id of the node to remove.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.removeNode",
        "Params": params,
    }
    yield cmd_dict

x_remove_node__mutmut_mutants : ClassVar[MutantDict] = {
'x_remove_node__mutmut_1': x_remove_node__mutmut_1, 
    'x_remove_node__mutmut_2': x_remove_node__mutmut_2, 
    'x_remove_node__mutmut_3': x_remove_node__mutmut_3, 
    'x_remove_node__mutmut_4': x_remove_node__mutmut_4, 
    'x_remove_node__mutmut_5': x_remove_node__mutmut_5, 
    'x_remove_node__mutmut_6': x_remove_node__mutmut_6, 
    'x_remove_node__mutmut_7': x_remove_node__mutmut_7, 
    'x_remove_node__mutmut_8': x_remove_node__mutmut_8, 
    'x_remove_node__mutmut_9': x_remove_node__mutmut_9, 
    'x_remove_node__mutmut_10': x_remove_node__mutmut_10, 
    'x_remove_node__mutmut_11': x_remove_node__mutmut_11, 
    'x_remove_node__mutmut_12': x_remove_node__mutmut_12, 
    'x_remove_node__mutmut_13': x_remove_node__mutmut_13, 
    'x_remove_node__mutmut_14': x_remove_node__mutmut_14, 
    'x_remove_node__mutmut_15': x_remove_node__mutmut_15, 
    'x_remove_node__mutmut_16': x_remove_node__mutmut_16, 
    'x_remove_node__mutmut_17': x_remove_node__mutmut_17
}

def remove_node(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_remove_node__mutmut_orig, x_remove_node__mutmut_mutants, args, kwargs)
    return result 

remove_node.__signature__ = _mutmut_signature(x_remove_node__mutmut_orig)
x_remove_node__mutmut_orig.__name__ = 'x_remove_node'


def x_request_child_nodes__mutmut_orig(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_1(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_2(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_3(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_4(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_5(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_6(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_7(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_8(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = None
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_9(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["XXdepthXX"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_10(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["DEPTH"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_11(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["Depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_12(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_13(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_14(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["XXpierceXX"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_15(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["PIERCE"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_16(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["Pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_17(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_request_child_nodes__mutmut_18(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_19(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_20(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.requestChildNodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_21(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.requestChildNodesXX",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_22(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "dom.requestchildnodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_23(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.REQUESTCHILDNODES",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_24(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.requestchildnodes",
        "params": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_25(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_26(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "PARAMS": params,
    }
    yield cmd_dict


def x_request_child_nodes__mutmut_27(
    node_id: NodeId,
    depth: int | None = None,
    pierce: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Requests that children of the node with given id are returned to the caller in form of
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to
    the specified depth.

    :param node_id: Id of the node to get children for.
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if depth is not None:
        params["depth"] = depth
    if pierce is not None:
        params["pierce"] = pierce
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestChildNodes",
        "Params": params,
    }
    yield cmd_dict

x_request_child_nodes__mutmut_mutants : ClassVar[MutantDict] = {
'x_request_child_nodes__mutmut_1': x_request_child_nodes__mutmut_1, 
    'x_request_child_nodes__mutmut_2': x_request_child_nodes__mutmut_2, 
    'x_request_child_nodes__mutmut_3': x_request_child_nodes__mutmut_3, 
    'x_request_child_nodes__mutmut_4': x_request_child_nodes__mutmut_4, 
    'x_request_child_nodes__mutmut_5': x_request_child_nodes__mutmut_5, 
    'x_request_child_nodes__mutmut_6': x_request_child_nodes__mutmut_6, 
    'x_request_child_nodes__mutmut_7': x_request_child_nodes__mutmut_7, 
    'x_request_child_nodes__mutmut_8': x_request_child_nodes__mutmut_8, 
    'x_request_child_nodes__mutmut_9': x_request_child_nodes__mutmut_9, 
    'x_request_child_nodes__mutmut_10': x_request_child_nodes__mutmut_10, 
    'x_request_child_nodes__mutmut_11': x_request_child_nodes__mutmut_11, 
    'x_request_child_nodes__mutmut_12': x_request_child_nodes__mutmut_12, 
    'x_request_child_nodes__mutmut_13': x_request_child_nodes__mutmut_13, 
    'x_request_child_nodes__mutmut_14': x_request_child_nodes__mutmut_14, 
    'x_request_child_nodes__mutmut_15': x_request_child_nodes__mutmut_15, 
    'x_request_child_nodes__mutmut_16': x_request_child_nodes__mutmut_16, 
    'x_request_child_nodes__mutmut_17': x_request_child_nodes__mutmut_17, 
    'x_request_child_nodes__mutmut_18': x_request_child_nodes__mutmut_18, 
    'x_request_child_nodes__mutmut_19': x_request_child_nodes__mutmut_19, 
    'x_request_child_nodes__mutmut_20': x_request_child_nodes__mutmut_20, 
    'x_request_child_nodes__mutmut_21': x_request_child_nodes__mutmut_21, 
    'x_request_child_nodes__mutmut_22': x_request_child_nodes__mutmut_22, 
    'x_request_child_nodes__mutmut_23': x_request_child_nodes__mutmut_23, 
    'x_request_child_nodes__mutmut_24': x_request_child_nodes__mutmut_24, 
    'x_request_child_nodes__mutmut_25': x_request_child_nodes__mutmut_25, 
    'x_request_child_nodes__mutmut_26': x_request_child_nodes__mutmut_26, 
    'x_request_child_nodes__mutmut_27': x_request_child_nodes__mutmut_27
}

def request_child_nodes(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_request_child_nodes__mutmut_orig, x_request_child_nodes__mutmut_mutants, args, kwargs)
    return result 

request_child_nodes.__signature__ = _mutmut_signature(x_request_child_nodes__mutmut_orig)
x_request_child_nodes__mutmut_orig.__name__ = 'x_request_child_nodes'


def x_request_node__mutmut_orig(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_1(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = None
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_2(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_3(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["XXobjectIdXX"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_4(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_5(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["OBJECTID"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_6(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["Objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_7(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_8(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_9(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_10(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_11(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.requestNodeXX",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_12(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.requestnode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_13(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.REQUESTNODE",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_14(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.requestnode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_15(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_16(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_17(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "Params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_18(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = None
    return NodeId.from_json(json["nodeId"])


def x_request_node__mutmut_19(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(None)


def x_request_node__mutmut_20(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["XXnodeIdXX"])


def x_request_node__mutmut_21(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeid"])


def x_request_node__mutmut_22(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["NODEID"])


def x_request_node__mutmut_23(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Requests that the node is sent to the caller given the JavaScript node object reference. All
    nodes that form the path from the node to the root are also sent to the client as a series of
    ``setChildNodes`` notifications.

    :param object_id: JavaScript object id to convert into node.
    :returns: Node id for given object.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.requestNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["Nodeid"])

x_request_node__mutmut_mutants : ClassVar[MutantDict] = {
'x_request_node__mutmut_1': x_request_node__mutmut_1, 
    'x_request_node__mutmut_2': x_request_node__mutmut_2, 
    'x_request_node__mutmut_3': x_request_node__mutmut_3, 
    'x_request_node__mutmut_4': x_request_node__mutmut_4, 
    'x_request_node__mutmut_5': x_request_node__mutmut_5, 
    'x_request_node__mutmut_6': x_request_node__mutmut_6, 
    'x_request_node__mutmut_7': x_request_node__mutmut_7, 
    'x_request_node__mutmut_8': x_request_node__mutmut_8, 
    'x_request_node__mutmut_9': x_request_node__mutmut_9, 
    'x_request_node__mutmut_10': x_request_node__mutmut_10, 
    'x_request_node__mutmut_11': x_request_node__mutmut_11, 
    'x_request_node__mutmut_12': x_request_node__mutmut_12, 
    'x_request_node__mutmut_13': x_request_node__mutmut_13, 
    'x_request_node__mutmut_14': x_request_node__mutmut_14, 
    'x_request_node__mutmut_15': x_request_node__mutmut_15, 
    'x_request_node__mutmut_16': x_request_node__mutmut_16, 
    'x_request_node__mutmut_17': x_request_node__mutmut_17, 
    'x_request_node__mutmut_18': x_request_node__mutmut_18, 
    'x_request_node__mutmut_19': x_request_node__mutmut_19, 
    'x_request_node__mutmut_20': x_request_node__mutmut_20, 
    'x_request_node__mutmut_21': x_request_node__mutmut_21, 
    'x_request_node__mutmut_22': x_request_node__mutmut_22, 
    'x_request_node__mutmut_23': x_request_node__mutmut_23
}

def request_node(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_request_node__mutmut_orig, x_request_node__mutmut_mutants, args, kwargs)
    return result 

request_node.__signature__ = _mutmut_signature(x_request_node__mutmut_orig)
x_request_node__mutmut_orig.__name__ = 'x_request_node'


def x_resolve_node__mutmut_orig(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_1(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = None
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_2(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_3(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = None
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_4(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["XXnodeIdXX"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_5(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_6(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["NODEID"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_7(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["Nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_8(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_9(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = None
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_10(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["XXbackendNodeIdXX"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_11(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendnodeid"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_12(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["BACKENDNODEID"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_13(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["Backendnodeid"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_14(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_15(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = None
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_16(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["XXobjectGroupXX"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_17(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectgroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_18(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["OBJECTGROUP"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_19(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["Objectgroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_20(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_21(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_22(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["XXexecutionContextIdXX"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_23(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executioncontextid"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_24(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["EXECUTIONCONTEXTID"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_25(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["Executioncontextid"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_26(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_27(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_28(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_29(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_30(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.resolveNodeXX",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_31(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.resolvenode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_32(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.RESOLVENODE",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_33(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.resolvenode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_34(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_35(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_36(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "Params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_37(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = None
    return runtime.RemoteObject.from_json(json["object"])


def x_resolve_node__mutmut_38(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(None)


def x_resolve_node__mutmut_39(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["XXobjectXX"])


def x_resolve_node__mutmut_40(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["OBJECT"])


def x_resolve_node__mutmut_41(
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_group: str | None = None,
    execution_context_id: runtime.ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Resolves the JavaScript node object for a given NodeId or BackendNodeId.

    :param node_id: *(Optional)* Id of the node to resolve.
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node.
    :returns: JavaScript object wrapper for given node.
    """
    params: T_JSON_DICT = {}
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.resolveNode",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json["Object"])

x_resolve_node__mutmut_mutants : ClassVar[MutantDict] = {
'x_resolve_node__mutmut_1': x_resolve_node__mutmut_1, 
    'x_resolve_node__mutmut_2': x_resolve_node__mutmut_2, 
    'x_resolve_node__mutmut_3': x_resolve_node__mutmut_3, 
    'x_resolve_node__mutmut_4': x_resolve_node__mutmut_4, 
    'x_resolve_node__mutmut_5': x_resolve_node__mutmut_5, 
    'x_resolve_node__mutmut_6': x_resolve_node__mutmut_6, 
    'x_resolve_node__mutmut_7': x_resolve_node__mutmut_7, 
    'x_resolve_node__mutmut_8': x_resolve_node__mutmut_8, 
    'x_resolve_node__mutmut_9': x_resolve_node__mutmut_9, 
    'x_resolve_node__mutmut_10': x_resolve_node__mutmut_10, 
    'x_resolve_node__mutmut_11': x_resolve_node__mutmut_11, 
    'x_resolve_node__mutmut_12': x_resolve_node__mutmut_12, 
    'x_resolve_node__mutmut_13': x_resolve_node__mutmut_13, 
    'x_resolve_node__mutmut_14': x_resolve_node__mutmut_14, 
    'x_resolve_node__mutmut_15': x_resolve_node__mutmut_15, 
    'x_resolve_node__mutmut_16': x_resolve_node__mutmut_16, 
    'x_resolve_node__mutmut_17': x_resolve_node__mutmut_17, 
    'x_resolve_node__mutmut_18': x_resolve_node__mutmut_18, 
    'x_resolve_node__mutmut_19': x_resolve_node__mutmut_19, 
    'x_resolve_node__mutmut_20': x_resolve_node__mutmut_20, 
    'x_resolve_node__mutmut_21': x_resolve_node__mutmut_21, 
    'x_resolve_node__mutmut_22': x_resolve_node__mutmut_22, 
    'x_resolve_node__mutmut_23': x_resolve_node__mutmut_23, 
    'x_resolve_node__mutmut_24': x_resolve_node__mutmut_24, 
    'x_resolve_node__mutmut_25': x_resolve_node__mutmut_25, 
    'x_resolve_node__mutmut_26': x_resolve_node__mutmut_26, 
    'x_resolve_node__mutmut_27': x_resolve_node__mutmut_27, 
    'x_resolve_node__mutmut_28': x_resolve_node__mutmut_28, 
    'x_resolve_node__mutmut_29': x_resolve_node__mutmut_29, 
    'x_resolve_node__mutmut_30': x_resolve_node__mutmut_30, 
    'x_resolve_node__mutmut_31': x_resolve_node__mutmut_31, 
    'x_resolve_node__mutmut_32': x_resolve_node__mutmut_32, 
    'x_resolve_node__mutmut_33': x_resolve_node__mutmut_33, 
    'x_resolve_node__mutmut_34': x_resolve_node__mutmut_34, 
    'x_resolve_node__mutmut_35': x_resolve_node__mutmut_35, 
    'x_resolve_node__mutmut_36': x_resolve_node__mutmut_36, 
    'x_resolve_node__mutmut_37': x_resolve_node__mutmut_37, 
    'x_resolve_node__mutmut_38': x_resolve_node__mutmut_38, 
    'x_resolve_node__mutmut_39': x_resolve_node__mutmut_39, 
    'x_resolve_node__mutmut_40': x_resolve_node__mutmut_40, 
    'x_resolve_node__mutmut_41': x_resolve_node__mutmut_41
}

def resolve_node(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_resolve_node__mutmut_orig, x_resolve_node__mutmut_mutants, args, kwargs)
    return result 

resolve_node.__signature__ = _mutmut_signature(x_resolve_node__mutmut_orig)
x_resolve_node__mutmut_orig.__name__ = 'x_resolve_node'


def x_set_attribute_value__mutmut_orig(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_1(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_2(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_3(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_4(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_5(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_6(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_7(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = None
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_8(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXnameXX"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_9(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["NAME"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_10(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_11(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_12(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["XXvalueXX"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_13(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["VALUE"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_14(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["Value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_15(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_attribute_value__mutmut_16(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_17(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_18(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.setAttributeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_19(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.setAttributeValueXX",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_20(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "dom.setattributevalue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_21(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.SETATTRIBUTEVALUE",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_22(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.setattributevalue",
        "params": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_23(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_24(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_attribute_value__mutmut_25(
    node_id: NodeId,
    name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attribute for an element with given id.

    :param node_id: Id of the element to set attribute for.
    :param name: Attribute name.
    :param value: Attribute value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributeValue",
        "Params": params,
    }
    yield cmd_dict

x_set_attribute_value__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_attribute_value__mutmut_1': x_set_attribute_value__mutmut_1, 
    'x_set_attribute_value__mutmut_2': x_set_attribute_value__mutmut_2, 
    'x_set_attribute_value__mutmut_3': x_set_attribute_value__mutmut_3, 
    'x_set_attribute_value__mutmut_4': x_set_attribute_value__mutmut_4, 
    'x_set_attribute_value__mutmut_5': x_set_attribute_value__mutmut_5, 
    'x_set_attribute_value__mutmut_6': x_set_attribute_value__mutmut_6, 
    'x_set_attribute_value__mutmut_7': x_set_attribute_value__mutmut_7, 
    'x_set_attribute_value__mutmut_8': x_set_attribute_value__mutmut_8, 
    'x_set_attribute_value__mutmut_9': x_set_attribute_value__mutmut_9, 
    'x_set_attribute_value__mutmut_10': x_set_attribute_value__mutmut_10, 
    'x_set_attribute_value__mutmut_11': x_set_attribute_value__mutmut_11, 
    'x_set_attribute_value__mutmut_12': x_set_attribute_value__mutmut_12, 
    'x_set_attribute_value__mutmut_13': x_set_attribute_value__mutmut_13, 
    'x_set_attribute_value__mutmut_14': x_set_attribute_value__mutmut_14, 
    'x_set_attribute_value__mutmut_15': x_set_attribute_value__mutmut_15, 
    'x_set_attribute_value__mutmut_16': x_set_attribute_value__mutmut_16, 
    'x_set_attribute_value__mutmut_17': x_set_attribute_value__mutmut_17, 
    'x_set_attribute_value__mutmut_18': x_set_attribute_value__mutmut_18, 
    'x_set_attribute_value__mutmut_19': x_set_attribute_value__mutmut_19, 
    'x_set_attribute_value__mutmut_20': x_set_attribute_value__mutmut_20, 
    'x_set_attribute_value__mutmut_21': x_set_attribute_value__mutmut_21, 
    'x_set_attribute_value__mutmut_22': x_set_attribute_value__mutmut_22, 
    'x_set_attribute_value__mutmut_23': x_set_attribute_value__mutmut_23, 
    'x_set_attribute_value__mutmut_24': x_set_attribute_value__mutmut_24, 
    'x_set_attribute_value__mutmut_25': x_set_attribute_value__mutmut_25
}

def set_attribute_value(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_attribute_value__mutmut_orig, x_set_attribute_value__mutmut_mutants, args, kwargs)
    return result 

set_attribute_value.__signature__ = _mutmut_signature(x_set_attribute_value__mutmut_orig)
x_set_attribute_value__mutmut_orig.__name__ = 'x_set_attribute_value'


def x_set_attributes_as_text__mutmut_orig(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_1(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_2(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_3(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_4(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_5(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_6(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_7(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = None
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_8(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXtextXX"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_9(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["TEXT"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_10(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_11(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_12(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_13(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["XXnameXX"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_14(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["NAME"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_15(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["Name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_16(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_attributes_as_text__mutmut_17(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_18(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_19(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.setAttributesAsText",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_20(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.setAttributesAsTextXX",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_21(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "dom.setattributesastext",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_22(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.SETATTRIBUTESASTEXT",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_23(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.setattributesastext",
        "params": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_24(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_25(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_attributes_as_text__mutmut_26(
    node_id: NodeId,
    text: str,
    name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets attributes on element with given id. This method is useful when user edits some existing
    attribute value and types in several attribute name/value pairs.

    :param node_id: Id of the element to set attributes for.
    :param text: Text with a number of attributes. Will parse this text using HTML parser.
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["text"] = text
    if name is not None:
        params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setAttributesAsText",
        "Params": params,
    }
    yield cmd_dict

x_set_attributes_as_text__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_attributes_as_text__mutmut_1': x_set_attributes_as_text__mutmut_1, 
    'x_set_attributes_as_text__mutmut_2': x_set_attributes_as_text__mutmut_2, 
    'x_set_attributes_as_text__mutmut_3': x_set_attributes_as_text__mutmut_3, 
    'x_set_attributes_as_text__mutmut_4': x_set_attributes_as_text__mutmut_4, 
    'x_set_attributes_as_text__mutmut_5': x_set_attributes_as_text__mutmut_5, 
    'x_set_attributes_as_text__mutmut_6': x_set_attributes_as_text__mutmut_6, 
    'x_set_attributes_as_text__mutmut_7': x_set_attributes_as_text__mutmut_7, 
    'x_set_attributes_as_text__mutmut_8': x_set_attributes_as_text__mutmut_8, 
    'x_set_attributes_as_text__mutmut_9': x_set_attributes_as_text__mutmut_9, 
    'x_set_attributes_as_text__mutmut_10': x_set_attributes_as_text__mutmut_10, 
    'x_set_attributes_as_text__mutmut_11': x_set_attributes_as_text__mutmut_11, 
    'x_set_attributes_as_text__mutmut_12': x_set_attributes_as_text__mutmut_12, 
    'x_set_attributes_as_text__mutmut_13': x_set_attributes_as_text__mutmut_13, 
    'x_set_attributes_as_text__mutmut_14': x_set_attributes_as_text__mutmut_14, 
    'x_set_attributes_as_text__mutmut_15': x_set_attributes_as_text__mutmut_15, 
    'x_set_attributes_as_text__mutmut_16': x_set_attributes_as_text__mutmut_16, 
    'x_set_attributes_as_text__mutmut_17': x_set_attributes_as_text__mutmut_17, 
    'x_set_attributes_as_text__mutmut_18': x_set_attributes_as_text__mutmut_18, 
    'x_set_attributes_as_text__mutmut_19': x_set_attributes_as_text__mutmut_19, 
    'x_set_attributes_as_text__mutmut_20': x_set_attributes_as_text__mutmut_20, 
    'x_set_attributes_as_text__mutmut_21': x_set_attributes_as_text__mutmut_21, 
    'x_set_attributes_as_text__mutmut_22': x_set_attributes_as_text__mutmut_22, 
    'x_set_attributes_as_text__mutmut_23': x_set_attributes_as_text__mutmut_23, 
    'x_set_attributes_as_text__mutmut_24': x_set_attributes_as_text__mutmut_24, 
    'x_set_attributes_as_text__mutmut_25': x_set_attributes_as_text__mutmut_25, 
    'x_set_attributes_as_text__mutmut_26': x_set_attributes_as_text__mutmut_26
}

def set_attributes_as_text(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_attributes_as_text__mutmut_orig, x_set_attributes_as_text__mutmut_mutants, args, kwargs)
    return result 

set_attributes_as_text.__signature__ = _mutmut_signature(x_set_attributes_as_text__mutmut_orig)
x_set_attributes_as_text__mutmut_orig.__name__ = 'x_set_attributes_as_text'


def x_set_file_input_files__mutmut_orig(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_1(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = None
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_2(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = None
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_3(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["XXfilesXX"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_4(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["FILES"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_5(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["Files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_6(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(None)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_7(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_8(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = None
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_9(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["XXnodeIdXX"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_10(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_11(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["NODEID"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_12(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["Nodeid"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_13(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_14(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = None
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_15(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["XXbackendNodeIdXX"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_16(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_17(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["BACKENDNODEID"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_18(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["Backendnodeid"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_19(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_20(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_21(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["XXobjectIdXX"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_22(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_23(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["OBJECTID"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_24(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["Objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_25(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_file_input_files__mutmut_26(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_27(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_28(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.setFileInputFiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_29(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.setFileInputFilesXX",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_30(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.setfileinputfiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_31(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.SETFILEINPUTFILES",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_32(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.setfileinputfiles",
        "params": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_33(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_34(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_file_input_files__mutmut_35(
    files: list[str],
    node_id: NodeId | None = None,
    backend_node_id: BackendNodeId | None = None,
    object_id: runtime.RemoteObjectId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets files for the given file input element.

    :param files: Array of file paths to set.
    :param node_id: *(Optional)* Identifier of the node.
    :param backend_node_id: *(Optional)* Identifier of the backend node.
    :param object_id: *(Optional)* JavaScript object id of the node wrapper.
    """
    params: T_JSON_DICT = {}
    params["files"] = list(files)
    if node_id is not None:
        params["nodeId"] = node_id.to_json()
    if backend_node_id is not None:
        params["backendNodeId"] = backend_node_id.to_json()
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setFileInputFiles",
        "Params": params,
    }
    yield cmd_dict

x_set_file_input_files__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_file_input_files__mutmut_1': x_set_file_input_files__mutmut_1, 
    'x_set_file_input_files__mutmut_2': x_set_file_input_files__mutmut_2, 
    'x_set_file_input_files__mutmut_3': x_set_file_input_files__mutmut_3, 
    'x_set_file_input_files__mutmut_4': x_set_file_input_files__mutmut_4, 
    'x_set_file_input_files__mutmut_5': x_set_file_input_files__mutmut_5, 
    'x_set_file_input_files__mutmut_6': x_set_file_input_files__mutmut_6, 
    'x_set_file_input_files__mutmut_7': x_set_file_input_files__mutmut_7, 
    'x_set_file_input_files__mutmut_8': x_set_file_input_files__mutmut_8, 
    'x_set_file_input_files__mutmut_9': x_set_file_input_files__mutmut_9, 
    'x_set_file_input_files__mutmut_10': x_set_file_input_files__mutmut_10, 
    'x_set_file_input_files__mutmut_11': x_set_file_input_files__mutmut_11, 
    'x_set_file_input_files__mutmut_12': x_set_file_input_files__mutmut_12, 
    'x_set_file_input_files__mutmut_13': x_set_file_input_files__mutmut_13, 
    'x_set_file_input_files__mutmut_14': x_set_file_input_files__mutmut_14, 
    'x_set_file_input_files__mutmut_15': x_set_file_input_files__mutmut_15, 
    'x_set_file_input_files__mutmut_16': x_set_file_input_files__mutmut_16, 
    'x_set_file_input_files__mutmut_17': x_set_file_input_files__mutmut_17, 
    'x_set_file_input_files__mutmut_18': x_set_file_input_files__mutmut_18, 
    'x_set_file_input_files__mutmut_19': x_set_file_input_files__mutmut_19, 
    'x_set_file_input_files__mutmut_20': x_set_file_input_files__mutmut_20, 
    'x_set_file_input_files__mutmut_21': x_set_file_input_files__mutmut_21, 
    'x_set_file_input_files__mutmut_22': x_set_file_input_files__mutmut_22, 
    'x_set_file_input_files__mutmut_23': x_set_file_input_files__mutmut_23, 
    'x_set_file_input_files__mutmut_24': x_set_file_input_files__mutmut_24, 
    'x_set_file_input_files__mutmut_25': x_set_file_input_files__mutmut_25, 
    'x_set_file_input_files__mutmut_26': x_set_file_input_files__mutmut_26, 
    'x_set_file_input_files__mutmut_27': x_set_file_input_files__mutmut_27, 
    'x_set_file_input_files__mutmut_28': x_set_file_input_files__mutmut_28, 
    'x_set_file_input_files__mutmut_29': x_set_file_input_files__mutmut_29, 
    'x_set_file_input_files__mutmut_30': x_set_file_input_files__mutmut_30, 
    'x_set_file_input_files__mutmut_31': x_set_file_input_files__mutmut_31, 
    'x_set_file_input_files__mutmut_32': x_set_file_input_files__mutmut_32, 
    'x_set_file_input_files__mutmut_33': x_set_file_input_files__mutmut_33, 
    'x_set_file_input_files__mutmut_34': x_set_file_input_files__mutmut_34, 
    'x_set_file_input_files__mutmut_35': x_set_file_input_files__mutmut_35
}

def set_file_input_files(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_file_input_files__mutmut_orig, x_set_file_input_files__mutmut_mutants, args, kwargs)
    return result 

set_file_input_files.__signature__ = _mutmut_signature(x_set_file_input_files__mutmut_orig)
x_set_file_input_files__mutmut_orig.__name__ = 'x_set_file_input_files'


def x_set_node_stack_traces_enabled__mutmut_orig(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeStackTracesEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_1(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = None
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeStackTracesEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_2(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeStackTracesEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_3(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["XXenableXX"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeStackTracesEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_4(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["ENABLE"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeStackTracesEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_5(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["Enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeStackTracesEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_6(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_7(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.setNodeStackTracesEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_8(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.setNodeStackTracesEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_9(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.setNodeStackTracesEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_10(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.setNodeStackTracesEnabledXX",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_11(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "dom.setnodestacktracesenabled",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_12(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.SETNODESTACKTRACESENABLED",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_13(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.setnodestacktracesenabled",
        "params": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_14(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeStackTracesEnabled",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_15(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeStackTracesEnabled",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_node_stack_traces_enabled__mutmut_16(
    enable: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled.

    **EXPERIMENTAL**

    :param enable: Enable or disable.
    """
    params: T_JSON_DICT = {}
    params["enable"] = enable
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeStackTracesEnabled",
        "Params": params,
    }
    yield cmd_dict

x_set_node_stack_traces_enabled__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_node_stack_traces_enabled__mutmut_1': x_set_node_stack_traces_enabled__mutmut_1, 
    'x_set_node_stack_traces_enabled__mutmut_2': x_set_node_stack_traces_enabled__mutmut_2, 
    'x_set_node_stack_traces_enabled__mutmut_3': x_set_node_stack_traces_enabled__mutmut_3, 
    'x_set_node_stack_traces_enabled__mutmut_4': x_set_node_stack_traces_enabled__mutmut_4, 
    'x_set_node_stack_traces_enabled__mutmut_5': x_set_node_stack_traces_enabled__mutmut_5, 
    'x_set_node_stack_traces_enabled__mutmut_6': x_set_node_stack_traces_enabled__mutmut_6, 
    'x_set_node_stack_traces_enabled__mutmut_7': x_set_node_stack_traces_enabled__mutmut_7, 
    'x_set_node_stack_traces_enabled__mutmut_8': x_set_node_stack_traces_enabled__mutmut_8, 
    'x_set_node_stack_traces_enabled__mutmut_9': x_set_node_stack_traces_enabled__mutmut_9, 
    'x_set_node_stack_traces_enabled__mutmut_10': x_set_node_stack_traces_enabled__mutmut_10, 
    'x_set_node_stack_traces_enabled__mutmut_11': x_set_node_stack_traces_enabled__mutmut_11, 
    'x_set_node_stack_traces_enabled__mutmut_12': x_set_node_stack_traces_enabled__mutmut_12, 
    'x_set_node_stack_traces_enabled__mutmut_13': x_set_node_stack_traces_enabled__mutmut_13, 
    'x_set_node_stack_traces_enabled__mutmut_14': x_set_node_stack_traces_enabled__mutmut_14, 
    'x_set_node_stack_traces_enabled__mutmut_15': x_set_node_stack_traces_enabled__mutmut_15, 
    'x_set_node_stack_traces_enabled__mutmut_16': x_set_node_stack_traces_enabled__mutmut_16
}

def set_node_stack_traces_enabled(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_node_stack_traces_enabled__mutmut_orig, x_set_node_stack_traces_enabled__mutmut_mutants, args, kwargs)
    return result 

set_node_stack_traces_enabled.__signature__ = _mutmut_signature(x_set_node_stack_traces_enabled__mutmut_orig)
x_set_node_stack_traces_enabled__mutmut_orig.__name__ = 'x_set_node_stack_traces_enabled'


def x_get_node_stack_traces__mutmut_orig(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_1(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_2(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_3(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_4(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_5(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_6(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_7(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_8(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_9(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_10(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_11(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getNodeStackTracesXX",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_12(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getnodestacktraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_13(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETNODESTACKTRACES",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_14(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getnodestacktraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_15(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_16(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_17(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "Params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_18(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = None
    return runtime.StackTrace.from_json(json["creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_19(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(None) if "creation" in json else None


def x_get_node_stack_traces__mutmut_20(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["XXcreationXX"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_21(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["CREATION"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_22(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["Creation"]) if "creation" in json else None


def x_get_node_stack_traces__mutmut_23(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "XXcreationXX" in json else None


def x_get_node_stack_traces__mutmut_24(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "CREATION" in json else None


def x_get_node_stack_traces__mutmut_25(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "Creation" in json else None


def x_get_node_stack_traces__mutmut_26(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace | None]:
    """
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.

    **EXPERIMENTAL**

    :param node_id: Id of the node to get stack traces for.
    :returns: *(Optional)* Creation stack trace, if available.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getNodeStackTraces",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["creation"]) if "creation" not in json else None

x_get_node_stack_traces__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_node_stack_traces__mutmut_1': x_get_node_stack_traces__mutmut_1, 
    'x_get_node_stack_traces__mutmut_2': x_get_node_stack_traces__mutmut_2, 
    'x_get_node_stack_traces__mutmut_3': x_get_node_stack_traces__mutmut_3, 
    'x_get_node_stack_traces__mutmut_4': x_get_node_stack_traces__mutmut_4, 
    'x_get_node_stack_traces__mutmut_5': x_get_node_stack_traces__mutmut_5, 
    'x_get_node_stack_traces__mutmut_6': x_get_node_stack_traces__mutmut_6, 
    'x_get_node_stack_traces__mutmut_7': x_get_node_stack_traces__mutmut_7, 
    'x_get_node_stack_traces__mutmut_8': x_get_node_stack_traces__mutmut_8, 
    'x_get_node_stack_traces__mutmut_9': x_get_node_stack_traces__mutmut_9, 
    'x_get_node_stack_traces__mutmut_10': x_get_node_stack_traces__mutmut_10, 
    'x_get_node_stack_traces__mutmut_11': x_get_node_stack_traces__mutmut_11, 
    'x_get_node_stack_traces__mutmut_12': x_get_node_stack_traces__mutmut_12, 
    'x_get_node_stack_traces__mutmut_13': x_get_node_stack_traces__mutmut_13, 
    'x_get_node_stack_traces__mutmut_14': x_get_node_stack_traces__mutmut_14, 
    'x_get_node_stack_traces__mutmut_15': x_get_node_stack_traces__mutmut_15, 
    'x_get_node_stack_traces__mutmut_16': x_get_node_stack_traces__mutmut_16, 
    'x_get_node_stack_traces__mutmut_17': x_get_node_stack_traces__mutmut_17, 
    'x_get_node_stack_traces__mutmut_18': x_get_node_stack_traces__mutmut_18, 
    'x_get_node_stack_traces__mutmut_19': x_get_node_stack_traces__mutmut_19, 
    'x_get_node_stack_traces__mutmut_20': x_get_node_stack_traces__mutmut_20, 
    'x_get_node_stack_traces__mutmut_21': x_get_node_stack_traces__mutmut_21, 
    'x_get_node_stack_traces__mutmut_22': x_get_node_stack_traces__mutmut_22, 
    'x_get_node_stack_traces__mutmut_23': x_get_node_stack_traces__mutmut_23, 
    'x_get_node_stack_traces__mutmut_24': x_get_node_stack_traces__mutmut_24, 
    'x_get_node_stack_traces__mutmut_25': x_get_node_stack_traces__mutmut_25, 
    'x_get_node_stack_traces__mutmut_26': x_get_node_stack_traces__mutmut_26
}

def get_node_stack_traces(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_node_stack_traces__mutmut_orig, x_get_node_stack_traces__mutmut_mutants, args, kwargs)
    return result 

get_node_stack_traces.__signature__ = _mutmut_signature(x_get_node_stack_traces__mutmut_orig)
x_get_node_stack_traces__mutmut_orig.__name__ = 'x_get_node_stack_traces'


def x_get_file_info__mutmut_orig(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_1(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = None
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_2(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_3(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["XXobjectIdXX"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_4(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_5(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["OBJECTID"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_6(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["Objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_7(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_8(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_9(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_10(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_11(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getFileInfoXX",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_12(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getfileinfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_13(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETFILEINFO",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_14(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getfileinfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_15(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_16(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_17(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "Params": params,
    }
    json = yield cmd_dict
    return str(json["path"])


def x_get_file_info__mutmut_18(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = None
    return str(json["path"])


def x_get_file_info__mutmut_19(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(None)


def x_get_file_info__mutmut_20(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["XXpathXX"])


def x_get_file_info__mutmut_21(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["PATH"])


def x_get_file_info__mutmut_22(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns file information for the given
    File wrapper.

    **EXPERIMENTAL**

    :param object_id: JavaScript object id of the node wrapper.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFileInfo",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["Path"])

x_get_file_info__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_file_info__mutmut_1': x_get_file_info__mutmut_1, 
    'x_get_file_info__mutmut_2': x_get_file_info__mutmut_2, 
    'x_get_file_info__mutmut_3': x_get_file_info__mutmut_3, 
    'x_get_file_info__mutmut_4': x_get_file_info__mutmut_4, 
    'x_get_file_info__mutmut_5': x_get_file_info__mutmut_5, 
    'x_get_file_info__mutmut_6': x_get_file_info__mutmut_6, 
    'x_get_file_info__mutmut_7': x_get_file_info__mutmut_7, 
    'x_get_file_info__mutmut_8': x_get_file_info__mutmut_8, 
    'x_get_file_info__mutmut_9': x_get_file_info__mutmut_9, 
    'x_get_file_info__mutmut_10': x_get_file_info__mutmut_10, 
    'x_get_file_info__mutmut_11': x_get_file_info__mutmut_11, 
    'x_get_file_info__mutmut_12': x_get_file_info__mutmut_12, 
    'x_get_file_info__mutmut_13': x_get_file_info__mutmut_13, 
    'x_get_file_info__mutmut_14': x_get_file_info__mutmut_14, 
    'x_get_file_info__mutmut_15': x_get_file_info__mutmut_15, 
    'x_get_file_info__mutmut_16': x_get_file_info__mutmut_16, 
    'x_get_file_info__mutmut_17': x_get_file_info__mutmut_17, 
    'x_get_file_info__mutmut_18': x_get_file_info__mutmut_18, 
    'x_get_file_info__mutmut_19': x_get_file_info__mutmut_19, 
    'x_get_file_info__mutmut_20': x_get_file_info__mutmut_20, 
    'x_get_file_info__mutmut_21': x_get_file_info__mutmut_21, 
    'x_get_file_info__mutmut_22': x_get_file_info__mutmut_22
}

def get_file_info(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_file_info__mutmut_orig, x_get_file_info__mutmut_mutants, args, kwargs)
    return result 

get_file_info.__signature__ = _mutmut_signature(x_get_file_info__mutmut_orig)
x_get_file_info__mutmut_orig.__name__ = 'x_get_file_info'


def x_get_detached_dom_nodes__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDetachedDomNodes",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["detachedNodes"]]


def x_get_detached_dom_nodes__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["detachedNodes"]]


def x_get_detached_dom_nodes__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getDetachedDomNodes",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["detachedNodes"]]


def x_get_detached_dom_nodes__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getDetachedDomNodes",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["detachedNodes"]]


def x_get_detached_dom_nodes__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getDetachedDomNodes",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["detachedNodes"]]


def x_get_detached_dom_nodes__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getDetachedDomNodesXX",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["detachedNodes"]]


def x_get_detached_dom_nodes__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getdetacheddomnodes",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["detachedNodes"]]


def x_get_detached_dom_nodes__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETDETACHEDDOMNODES",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["detachedNodes"]]


def x_get_detached_dom_nodes__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getdetacheddomnodes",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["detachedNodes"]]


def x_get_detached_dom_nodes__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDetachedDomNodes",
    }
    json = None
    return [DetachedElementInfo.from_json(i) for i in json["detachedNodes"]]


def x_get_detached_dom_nodes__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDetachedDomNodes",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(None) for i in json["detachedNodes"]]


def x_get_detached_dom_nodes__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDetachedDomNodes",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["XXdetachedNodesXX"]]


def x_get_detached_dom_nodes__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDetachedDomNodes",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["detachednodes"]]


def x_get_detached_dom_nodes__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDetachedDomNodes",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["DETACHEDNODES"]]


def x_get_detached_dom_nodes__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DetachedElementInfo]]:
    """
    Returns list of detached nodes

    **EXPERIMENTAL**

    :returns: The list of detached nodes
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getDetachedDomNodes",
    }
    json = yield cmd_dict
    return [DetachedElementInfo.from_json(i) for i in json["Detachednodes"]]

x_get_detached_dom_nodes__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_detached_dom_nodes__mutmut_1': x_get_detached_dom_nodes__mutmut_1, 
    'x_get_detached_dom_nodes__mutmut_2': x_get_detached_dom_nodes__mutmut_2, 
    'x_get_detached_dom_nodes__mutmut_3': x_get_detached_dom_nodes__mutmut_3, 
    'x_get_detached_dom_nodes__mutmut_4': x_get_detached_dom_nodes__mutmut_4, 
    'x_get_detached_dom_nodes__mutmut_5': x_get_detached_dom_nodes__mutmut_5, 
    'x_get_detached_dom_nodes__mutmut_6': x_get_detached_dom_nodes__mutmut_6, 
    'x_get_detached_dom_nodes__mutmut_7': x_get_detached_dom_nodes__mutmut_7, 
    'x_get_detached_dom_nodes__mutmut_8': x_get_detached_dom_nodes__mutmut_8, 
    'x_get_detached_dom_nodes__mutmut_9': x_get_detached_dom_nodes__mutmut_9, 
    'x_get_detached_dom_nodes__mutmut_10': x_get_detached_dom_nodes__mutmut_10, 
    'x_get_detached_dom_nodes__mutmut_11': x_get_detached_dom_nodes__mutmut_11, 
    'x_get_detached_dom_nodes__mutmut_12': x_get_detached_dom_nodes__mutmut_12, 
    'x_get_detached_dom_nodes__mutmut_13': x_get_detached_dom_nodes__mutmut_13, 
    'x_get_detached_dom_nodes__mutmut_14': x_get_detached_dom_nodes__mutmut_14
}

def get_detached_dom_nodes(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_detached_dom_nodes__mutmut_orig, x_get_detached_dom_nodes__mutmut_mutants, args, kwargs)
    return result 

get_detached_dom_nodes.__signature__ = _mutmut_signature(x_get_detached_dom_nodes__mutmut_orig)
x_get_detached_dom_nodes__mutmut_orig.__name__ = 'x_get_detached_dom_nodes'


def x_set_inspected_node__mutmut_orig(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setInspectedNode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_1(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setInspectedNode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_2(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setInspectedNode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_3(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setInspectedNode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_4(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setInspectedNode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_5(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setInspectedNode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_6(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setInspectedNode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_7(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_inspected_node__mutmut_8(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.setInspectedNode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_9(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.setInspectedNode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_10(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.setInspectedNode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_11(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.setInspectedNodeXX",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_12(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.setinspectednode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_13(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.SETINSPECTEDNODE",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_14(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.setinspectednode",
        "params": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_15(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setInspectedNode",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_16(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setInspectedNode",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_inspected_node__mutmut_17(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables console to refer to the node with given id via $x (see Command Line API for more details
    $x functions).

    **EXPERIMENTAL**

    :param node_id: DOM node id to be accessible by means of $x command line API.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setInspectedNode",
        "Params": params,
    }
    yield cmd_dict

x_set_inspected_node__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_inspected_node__mutmut_1': x_set_inspected_node__mutmut_1, 
    'x_set_inspected_node__mutmut_2': x_set_inspected_node__mutmut_2, 
    'x_set_inspected_node__mutmut_3': x_set_inspected_node__mutmut_3, 
    'x_set_inspected_node__mutmut_4': x_set_inspected_node__mutmut_4, 
    'x_set_inspected_node__mutmut_5': x_set_inspected_node__mutmut_5, 
    'x_set_inspected_node__mutmut_6': x_set_inspected_node__mutmut_6, 
    'x_set_inspected_node__mutmut_7': x_set_inspected_node__mutmut_7, 
    'x_set_inspected_node__mutmut_8': x_set_inspected_node__mutmut_8, 
    'x_set_inspected_node__mutmut_9': x_set_inspected_node__mutmut_9, 
    'x_set_inspected_node__mutmut_10': x_set_inspected_node__mutmut_10, 
    'x_set_inspected_node__mutmut_11': x_set_inspected_node__mutmut_11, 
    'x_set_inspected_node__mutmut_12': x_set_inspected_node__mutmut_12, 
    'x_set_inspected_node__mutmut_13': x_set_inspected_node__mutmut_13, 
    'x_set_inspected_node__mutmut_14': x_set_inspected_node__mutmut_14, 
    'x_set_inspected_node__mutmut_15': x_set_inspected_node__mutmut_15, 
    'x_set_inspected_node__mutmut_16': x_set_inspected_node__mutmut_16, 
    'x_set_inspected_node__mutmut_17': x_set_inspected_node__mutmut_17
}

def set_inspected_node(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_inspected_node__mutmut_orig, x_set_inspected_node__mutmut_mutants, args, kwargs)
    return result 

set_inspected_node.__signature__ = _mutmut_signature(x_set_inspected_node__mutmut_orig)
x_set_inspected_node__mutmut_orig.__name__ = 'x_set_inspected_node'


def x_set_node_name__mutmut_orig(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_1(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_2(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_3(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_4(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_5(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_6(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_7(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_8(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXnameXX"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_9(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["NAME"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_10(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_11(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_12(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_13(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_14(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_15(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.setNodeNameXX",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_16(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "dom.setnodename",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_17(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.SETNODENAME",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_18(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.setnodename",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_19(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_20(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_21(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "Params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_22(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = None
    return NodeId.from_json(json["nodeId"])


def x_set_node_name__mutmut_23(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(None)


def x_set_node_name__mutmut_24(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["XXnodeIdXX"])


def x_set_node_name__mutmut_25(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeid"])


def x_set_node_name__mutmut_26(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["NODEID"])


def x_set_node_name__mutmut_27(
    node_id: NodeId,
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Sets node name for a node with given id.

    :param node_id: Id of the node to set name for.
    :param name: New node's name.
    :returns: New node's id.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeName",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["Nodeid"])

x_set_node_name__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_node_name__mutmut_1': x_set_node_name__mutmut_1, 
    'x_set_node_name__mutmut_2': x_set_node_name__mutmut_2, 
    'x_set_node_name__mutmut_3': x_set_node_name__mutmut_3, 
    'x_set_node_name__mutmut_4': x_set_node_name__mutmut_4, 
    'x_set_node_name__mutmut_5': x_set_node_name__mutmut_5, 
    'x_set_node_name__mutmut_6': x_set_node_name__mutmut_6, 
    'x_set_node_name__mutmut_7': x_set_node_name__mutmut_7, 
    'x_set_node_name__mutmut_8': x_set_node_name__mutmut_8, 
    'x_set_node_name__mutmut_9': x_set_node_name__mutmut_9, 
    'x_set_node_name__mutmut_10': x_set_node_name__mutmut_10, 
    'x_set_node_name__mutmut_11': x_set_node_name__mutmut_11, 
    'x_set_node_name__mutmut_12': x_set_node_name__mutmut_12, 
    'x_set_node_name__mutmut_13': x_set_node_name__mutmut_13, 
    'x_set_node_name__mutmut_14': x_set_node_name__mutmut_14, 
    'x_set_node_name__mutmut_15': x_set_node_name__mutmut_15, 
    'x_set_node_name__mutmut_16': x_set_node_name__mutmut_16, 
    'x_set_node_name__mutmut_17': x_set_node_name__mutmut_17, 
    'x_set_node_name__mutmut_18': x_set_node_name__mutmut_18, 
    'x_set_node_name__mutmut_19': x_set_node_name__mutmut_19, 
    'x_set_node_name__mutmut_20': x_set_node_name__mutmut_20, 
    'x_set_node_name__mutmut_21': x_set_node_name__mutmut_21, 
    'x_set_node_name__mutmut_22': x_set_node_name__mutmut_22, 
    'x_set_node_name__mutmut_23': x_set_node_name__mutmut_23, 
    'x_set_node_name__mutmut_24': x_set_node_name__mutmut_24, 
    'x_set_node_name__mutmut_25': x_set_node_name__mutmut_25, 
    'x_set_node_name__mutmut_26': x_set_node_name__mutmut_26, 
    'x_set_node_name__mutmut_27': x_set_node_name__mutmut_27
}

def set_node_name(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_node_name__mutmut_orig, x_set_node_name__mutmut_mutants, args, kwargs)
    return result 

set_node_name.__signature__ = _mutmut_signature(x_set_node_name__mutmut_orig)
x_set_node_name__mutmut_orig.__name__ = 'x_set_node_name'


def x_set_node_value__mutmut_orig(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_1(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_2(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_3(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_4(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_5(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_6(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_7(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_8(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXvalueXX"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_9(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["VALUE"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_10(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_11(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_node_value__mutmut_12(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_13(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_14(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.setNodeValue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_15(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.setNodeValueXX",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_16(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "dom.setnodevalue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_17(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.SETNODEVALUE",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_18(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.setnodevalue",
        "params": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_19(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_20(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_node_value__mutmut_21(
    node_id: NodeId,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node value for a node with given id.

    :param node_id: Id of the node to set value for.
    :param value: New node's value.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["value"] = value
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setNodeValue",
        "Params": params,
    }
    yield cmd_dict

x_set_node_value__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_node_value__mutmut_1': x_set_node_value__mutmut_1, 
    'x_set_node_value__mutmut_2': x_set_node_value__mutmut_2, 
    'x_set_node_value__mutmut_3': x_set_node_value__mutmut_3, 
    'x_set_node_value__mutmut_4': x_set_node_value__mutmut_4, 
    'x_set_node_value__mutmut_5': x_set_node_value__mutmut_5, 
    'x_set_node_value__mutmut_6': x_set_node_value__mutmut_6, 
    'x_set_node_value__mutmut_7': x_set_node_value__mutmut_7, 
    'x_set_node_value__mutmut_8': x_set_node_value__mutmut_8, 
    'x_set_node_value__mutmut_9': x_set_node_value__mutmut_9, 
    'x_set_node_value__mutmut_10': x_set_node_value__mutmut_10, 
    'x_set_node_value__mutmut_11': x_set_node_value__mutmut_11, 
    'x_set_node_value__mutmut_12': x_set_node_value__mutmut_12, 
    'x_set_node_value__mutmut_13': x_set_node_value__mutmut_13, 
    'x_set_node_value__mutmut_14': x_set_node_value__mutmut_14, 
    'x_set_node_value__mutmut_15': x_set_node_value__mutmut_15, 
    'x_set_node_value__mutmut_16': x_set_node_value__mutmut_16, 
    'x_set_node_value__mutmut_17': x_set_node_value__mutmut_17, 
    'x_set_node_value__mutmut_18': x_set_node_value__mutmut_18, 
    'x_set_node_value__mutmut_19': x_set_node_value__mutmut_19, 
    'x_set_node_value__mutmut_20': x_set_node_value__mutmut_20, 
    'x_set_node_value__mutmut_21': x_set_node_value__mutmut_21
}

def set_node_value(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_node_value__mutmut_orig, x_set_node_value__mutmut_mutants, args, kwargs)
    return result 

set_node_value.__signature__ = _mutmut_signature(x_set_node_value__mutmut_orig)
x_set_node_value__mutmut_orig.__name__ = 'x_set_node_value'


def x_set_outer_html__mutmut_orig(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_1(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_2(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_3(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_4(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_5(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_6(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_7(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_8(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["XXouterHTMLXX"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_9(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerhtml"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_10(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["OUTERHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_11(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["Outerhtml"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_12(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_outer_html__mutmut_13(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_14(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_15(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.setOuterHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_16(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.setOuterHTMLXX",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_17(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "dom.setouterhtml",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_18(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.SETOUTERHTML",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_19(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.setouterhtml",
        "params": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_20(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_21(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_outer_html__mutmut_22(
    node_id: NodeId,
    outer_html: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Sets node HTML markup, returns new node id.

    :param node_id: Id of the node to set markup for.
    :param outer_html: Outer HTML markup to set.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    params["outerHTML"] = outer_html
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.setOuterHTML",
        "Params": params,
    }
    yield cmd_dict

x_set_outer_html__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_outer_html__mutmut_1': x_set_outer_html__mutmut_1, 
    'x_set_outer_html__mutmut_2': x_set_outer_html__mutmut_2, 
    'x_set_outer_html__mutmut_3': x_set_outer_html__mutmut_3, 
    'x_set_outer_html__mutmut_4': x_set_outer_html__mutmut_4, 
    'x_set_outer_html__mutmut_5': x_set_outer_html__mutmut_5, 
    'x_set_outer_html__mutmut_6': x_set_outer_html__mutmut_6, 
    'x_set_outer_html__mutmut_7': x_set_outer_html__mutmut_7, 
    'x_set_outer_html__mutmut_8': x_set_outer_html__mutmut_8, 
    'x_set_outer_html__mutmut_9': x_set_outer_html__mutmut_9, 
    'x_set_outer_html__mutmut_10': x_set_outer_html__mutmut_10, 
    'x_set_outer_html__mutmut_11': x_set_outer_html__mutmut_11, 
    'x_set_outer_html__mutmut_12': x_set_outer_html__mutmut_12, 
    'x_set_outer_html__mutmut_13': x_set_outer_html__mutmut_13, 
    'x_set_outer_html__mutmut_14': x_set_outer_html__mutmut_14, 
    'x_set_outer_html__mutmut_15': x_set_outer_html__mutmut_15, 
    'x_set_outer_html__mutmut_16': x_set_outer_html__mutmut_16, 
    'x_set_outer_html__mutmut_17': x_set_outer_html__mutmut_17, 
    'x_set_outer_html__mutmut_18': x_set_outer_html__mutmut_18, 
    'x_set_outer_html__mutmut_19': x_set_outer_html__mutmut_19, 
    'x_set_outer_html__mutmut_20': x_set_outer_html__mutmut_20, 
    'x_set_outer_html__mutmut_21': x_set_outer_html__mutmut_21, 
    'x_set_outer_html__mutmut_22': x_set_outer_html__mutmut_22
}

def set_outer_html(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_outer_html__mutmut_orig, x_set_outer_html__mutmut_mutants, args, kwargs)
    return result 

set_outer_html.__signature__ = _mutmut_signature(x_set_outer_html__mutmut_orig)
x_set_outer_html__mutmut_orig.__name__ = 'x_set_outer_html'


def x_undo__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Undoes the last performed action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.undo",
    }
    yield cmd_dict


def x_undo__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Undoes the last performed action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_undo__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Undoes the last performed action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.undo",
    }
    yield cmd_dict


def x_undo__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Undoes the last performed action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.undo",
    }
    yield cmd_dict


def x_undo__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Undoes the last performed action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.undo",
    }
    yield cmd_dict


def x_undo__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Undoes the last performed action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.undoXX",
    }
    yield cmd_dict


def x_undo__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Undoes the last performed action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "dom.undo",
    }
    yield cmd_dict


def x_undo__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Undoes the last performed action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.UNDO",
    }
    yield cmd_dict


def x_undo__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Undoes the last performed action.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.undo",
    }
    yield cmd_dict

x_undo__mutmut_mutants : ClassVar[MutantDict] = {
'x_undo__mutmut_1': x_undo__mutmut_1, 
    'x_undo__mutmut_2': x_undo__mutmut_2, 
    'x_undo__mutmut_3': x_undo__mutmut_3, 
    'x_undo__mutmut_4': x_undo__mutmut_4, 
    'x_undo__mutmut_5': x_undo__mutmut_5, 
    'x_undo__mutmut_6': x_undo__mutmut_6, 
    'x_undo__mutmut_7': x_undo__mutmut_7, 
    'x_undo__mutmut_8': x_undo__mutmut_8
}

def undo(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_undo__mutmut_orig, x_undo__mutmut_mutants, args, kwargs)
    return result 

undo.__signature__ = _mutmut_signature(x_undo__mutmut_orig)
x_undo__mutmut_orig.__name__ = 'x_undo'


def x_get_frame_owner__mutmut_orig(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_1(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = None
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_2(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_3(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["XXframeIdXX"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_4(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameid"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_5(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["FRAMEID"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_6(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["Frameid"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_7(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_8(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_9(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_10(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_11(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getFrameOwnerXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_12(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getframeowner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_13(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETFRAMEOWNER",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_14(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getframeowner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_15(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_16(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_17(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_18(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = None
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_19(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(None),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_20(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["XXbackendNodeIdXX"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_21(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendnodeid"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_22(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["BACKENDNODEID"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_23(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["Backendnodeid"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_24(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(None) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_25(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["XXnodeIdXX"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_26(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeid"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_27(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["NODEID"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_28(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["Nodeid"]) if "nodeId" in json else None,
    )


def x_get_frame_owner__mutmut_29(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "XXnodeIdXX" in json else None,
    )


def x_get_frame_owner__mutmut_30(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeid" in json else None,
    )


def x_get_frame_owner__mutmut_31(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "NODEID" in json else None,
    )


def x_get_frame_owner__mutmut_32(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "Nodeid" in json else None,
    )


def x_get_frame_owner__mutmut_33(
    frame_id: page.FrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BackendNodeId, NodeId | None]]:
    """
    Returns iframe node that owns iframe with the given domain.

    **EXPERIMENTAL**

    :param frame_id:
    :returns: A tuple with the following items:

        0. **backendNodeId** - Resulting node.
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document.
    """
    params: T_JSON_DICT = {}
    params["frameId"] = frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getFrameOwner",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BackendNodeId.from_json(json["backendNodeId"]),
        NodeId.from_json(json["nodeId"]) if "nodeId" not in json else None,
    )

x_get_frame_owner__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_frame_owner__mutmut_1': x_get_frame_owner__mutmut_1, 
    'x_get_frame_owner__mutmut_2': x_get_frame_owner__mutmut_2, 
    'x_get_frame_owner__mutmut_3': x_get_frame_owner__mutmut_3, 
    'x_get_frame_owner__mutmut_4': x_get_frame_owner__mutmut_4, 
    'x_get_frame_owner__mutmut_5': x_get_frame_owner__mutmut_5, 
    'x_get_frame_owner__mutmut_6': x_get_frame_owner__mutmut_6, 
    'x_get_frame_owner__mutmut_7': x_get_frame_owner__mutmut_7, 
    'x_get_frame_owner__mutmut_8': x_get_frame_owner__mutmut_8, 
    'x_get_frame_owner__mutmut_9': x_get_frame_owner__mutmut_9, 
    'x_get_frame_owner__mutmut_10': x_get_frame_owner__mutmut_10, 
    'x_get_frame_owner__mutmut_11': x_get_frame_owner__mutmut_11, 
    'x_get_frame_owner__mutmut_12': x_get_frame_owner__mutmut_12, 
    'x_get_frame_owner__mutmut_13': x_get_frame_owner__mutmut_13, 
    'x_get_frame_owner__mutmut_14': x_get_frame_owner__mutmut_14, 
    'x_get_frame_owner__mutmut_15': x_get_frame_owner__mutmut_15, 
    'x_get_frame_owner__mutmut_16': x_get_frame_owner__mutmut_16, 
    'x_get_frame_owner__mutmut_17': x_get_frame_owner__mutmut_17, 
    'x_get_frame_owner__mutmut_18': x_get_frame_owner__mutmut_18, 
    'x_get_frame_owner__mutmut_19': x_get_frame_owner__mutmut_19, 
    'x_get_frame_owner__mutmut_20': x_get_frame_owner__mutmut_20, 
    'x_get_frame_owner__mutmut_21': x_get_frame_owner__mutmut_21, 
    'x_get_frame_owner__mutmut_22': x_get_frame_owner__mutmut_22, 
    'x_get_frame_owner__mutmut_23': x_get_frame_owner__mutmut_23, 
    'x_get_frame_owner__mutmut_24': x_get_frame_owner__mutmut_24, 
    'x_get_frame_owner__mutmut_25': x_get_frame_owner__mutmut_25, 
    'x_get_frame_owner__mutmut_26': x_get_frame_owner__mutmut_26, 
    'x_get_frame_owner__mutmut_27': x_get_frame_owner__mutmut_27, 
    'x_get_frame_owner__mutmut_28': x_get_frame_owner__mutmut_28, 
    'x_get_frame_owner__mutmut_29': x_get_frame_owner__mutmut_29, 
    'x_get_frame_owner__mutmut_30': x_get_frame_owner__mutmut_30, 
    'x_get_frame_owner__mutmut_31': x_get_frame_owner__mutmut_31, 
    'x_get_frame_owner__mutmut_32': x_get_frame_owner__mutmut_32, 
    'x_get_frame_owner__mutmut_33': x_get_frame_owner__mutmut_33
}

def get_frame_owner(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_frame_owner__mutmut_orig, x_get_frame_owner__mutmut_mutants, args, kwargs)
    return result 

get_frame_owner.__signature__ = _mutmut_signature(x_get_frame_owner__mutmut_orig)
x_get_frame_owner__mutmut_orig.__name__ = 'x_get_frame_owner'


def x_get_container_for_node__mutmut_orig(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_1(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_2(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_3(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_4(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_5(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_6(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_7(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_8(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = None
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_9(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["XXcontainerNameXX"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_10(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containername"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_11(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["CONTAINERNAME"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_12(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["Containername"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_13(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_14(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = None
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_15(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["XXphysicalAxesXX"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_16(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalaxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_17(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["PHYSICALAXES"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_18(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["Physicalaxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_19(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_20(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = None
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_21(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["XXlogicalAxesXX"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_22(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalaxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_23(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["LOGICALAXES"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_24(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["Logicalaxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_25(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_26(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_27(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["XXqueriesScrollStateXX"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_28(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesscrollstate"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_29(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["QUERIESSCROLLSTATE"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_30(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["Queriesscrollstate"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_31(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_32(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_33(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_34(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_35(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getContainerForNodeXX",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_36(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getcontainerfornode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_37(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETCONTAINERFORNODE",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_38(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getcontainerfornode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_39(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_40(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_41(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "Params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_42(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = None
    return NodeId.from_json(json["nodeId"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_43(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(None) if "nodeId" in json else None


def x_get_container_for_node__mutmut_44(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["XXnodeIdXX"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_45(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeid"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_46(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["NODEID"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_47(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["Nodeid"]) if "nodeId" in json else None


def x_get_container_for_node__mutmut_48(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "XXnodeIdXX" in json else None


def x_get_container_for_node__mutmut_49(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeid" in json else None


def x_get_container_for_node__mutmut_50(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "NODEID" in json else None


def x_get_container_for_node__mutmut_51(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "Nodeid" in json else None


def x_get_container_for_node__mutmut_52(
    node_id: NodeId,
    container_name: str | None = None,
    physical_axes: PhysicalAxes | None = None,
    logical_axes: LogicalAxes | None = None,
    queries_scroll_state: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId | None]:
    """
    Returns the query container of the given node based on container query
    conditions: containerName, physical and logical axes, and whether it queries
    scroll-state. If no axes are provided and queriesScrollState is false, the
    style container is returned, which is the direct parent or the closest
    element with a matching container-name.

    **EXPERIMENTAL**

    :param node_id:
    :param container_name: *(Optional)*
    :param physical_axes: *(Optional)*
    :param logical_axes: *(Optional)*
    :param queries_scroll_state: *(Optional)*
    :returns: *(Optional)* The container node for the given node, or null if not found.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if container_name is not None:
        params["containerName"] = container_name
    if physical_axes is not None:
        params["physicalAxes"] = physical_axes.to_json()
    if logical_axes is not None:
        params["logicalAxes"] = logical_axes.to_json()
    if queries_scroll_state is not None:
        params["queriesScrollState"] = queries_scroll_state
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getContainerForNode",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"]) if "nodeId" not in json else None

x_get_container_for_node__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_container_for_node__mutmut_1': x_get_container_for_node__mutmut_1, 
    'x_get_container_for_node__mutmut_2': x_get_container_for_node__mutmut_2, 
    'x_get_container_for_node__mutmut_3': x_get_container_for_node__mutmut_3, 
    'x_get_container_for_node__mutmut_4': x_get_container_for_node__mutmut_4, 
    'x_get_container_for_node__mutmut_5': x_get_container_for_node__mutmut_5, 
    'x_get_container_for_node__mutmut_6': x_get_container_for_node__mutmut_6, 
    'x_get_container_for_node__mutmut_7': x_get_container_for_node__mutmut_7, 
    'x_get_container_for_node__mutmut_8': x_get_container_for_node__mutmut_8, 
    'x_get_container_for_node__mutmut_9': x_get_container_for_node__mutmut_9, 
    'x_get_container_for_node__mutmut_10': x_get_container_for_node__mutmut_10, 
    'x_get_container_for_node__mutmut_11': x_get_container_for_node__mutmut_11, 
    'x_get_container_for_node__mutmut_12': x_get_container_for_node__mutmut_12, 
    'x_get_container_for_node__mutmut_13': x_get_container_for_node__mutmut_13, 
    'x_get_container_for_node__mutmut_14': x_get_container_for_node__mutmut_14, 
    'x_get_container_for_node__mutmut_15': x_get_container_for_node__mutmut_15, 
    'x_get_container_for_node__mutmut_16': x_get_container_for_node__mutmut_16, 
    'x_get_container_for_node__mutmut_17': x_get_container_for_node__mutmut_17, 
    'x_get_container_for_node__mutmut_18': x_get_container_for_node__mutmut_18, 
    'x_get_container_for_node__mutmut_19': x_get_container_for_node__mutmut_19, 
    'x_get_container_for_node__mutmut_20': x_get_container_for_node__mutmut_20, 
    'x_get_container_for_node__mutmut_21': x_get_container_for_node__mutmut_21, 
    'x_get_container_for_node__mutmut_22': x_get_container_for_node__mutmut_22, 
    'x_get_container_for_node__mutmut_23': x_get_container_for_node__mutmut_23, 
    'x_get_container_for_node__mutmut_24': x_get_container_for_node__mutmut_24, 
    'x_get_container_for_node__mutmut_25': x_get_container_for_node__mutmut_25, 
    'x_get_container_for_node__mutmut_26': x_get_container_for_node__mutmut_26, 
    'x_get_container_for_node__mutmut_27': x_get_container_for_node__mutmut_27, 
    'x_get_container_for_node__mutmut_28': x_get_container_for_node__mutmut_28, 
    'x_get_container_for_node__mutmut_29': x_get_container_for_node__mutmut_29, 
    'x_get_container_for_node__mutmut_30': x_get_container_for_node__mutmut_30, 
    'x_get_container_for_node__mutmut_31': x_get_container_for_node__mutmut_31, 
    'x_get_container_for_node__mutmut_32': x_get_container_for_node__mutmut_32, 
    'x_get_container_for_node__mutmut_33': x_get_container_for_node__mutmut_33, 
    'x_get_container_for_node__mutmut_34': x_get_container_for_node__mutmut_34, 
    'x_get_container_for_node__mutmut_35': x_get_container_for_node__mutmut_35, 
    'x_get_container_for_node__mutmut_36': x_get_container_for_node__mutmut_36, 
    'x_get_container_for_node__mutmut_37': x_get_container_for_node__mutmut_37, 
    'x_get_container_for_node__mutmut_38': x_get_container_for_node__mutmut_38, 
    'x_get_container_for_node__mutmut_39': x_get_container_for_node__mutmut_39, 
    'x_get_container_for_node__mutmut_40': x_get_container_for_node__mutmut_40, 
    'x_get_container_for_node__mutmut_41': x_get_container_for_node__mutmut_41, 
    'x_get_container_for_node__mutmut_42': x_get_container_for_node__mutmut_42, 
    'x_get_container_for_node__mutmut_43': x_get_container_for_node__mutmut_43, 
    'x_get_container_for_node__mutmut_44': x_get_container_for_node__mutmut_44, 
    'x_get_container_for_node__mutmut_45': x_get_container_for_node__mutmut_45, 
    'x_get_container_for_node__mutmut_46': x_get_container_for_node__mutmut_46, 
    'x_get_container_for_node__mutmut_47': x_get_container_for_node__mutmut_47, 
    'x_get_container_for_node__mutmut_48': x_get_container_for_node__mutmut_48, 
    'x_get_container_for_node__mutmut_49': x_get_container_for_node__mutmut_49, 
    'x_get_container_for_node__mutmut_50': x_get_container_for_node__mutmut_50, 
    'x_get_container_for_node__mutmut_51': x_get_container_for_node__mutmut_51, 
    'x_get_container_for_node__mutmut_52': x_get_container_for_node__mutmut_52
}

def get_container_for_node(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_container_for_node__mutmut_orig, x_get_container_for_node__mutmut_mutants, args, kwargs)
    return result 

get_container_for_node.__signature__ = _mutmut_signature(x_get_container_for_node__mutmut_orig)
x_get_container_for_node__mutmut_orig.__name__ = 'x_get_container_for_node'


def x_get_querying_descendants_for_container__mutmut_orig(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_1(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_2(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_3(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_4(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_5(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_6(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_7(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_8(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_9(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_10(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_11(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getQueryingDescendantsForContainerXX",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_12(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getqueryingdescendantsforcontainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_13(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETQUERYINGDESCENDANTSFORCONTAINER",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_14(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getqueryingdescendantsforcontainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_15(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_16(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_17(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "Params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_18(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = None
    return [NodeId.from_json(i) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_19(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(None) for i in json["nodeIds"]]


def x_get_querying_descendants_for_container__mutmut_20(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["XXnodeIdsXX"]]


def x_get_querying_descendants_for_container__mutmut_21(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["nodeids"]]


def x_get_querying_descendants_for_container__mutmut_22(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["NODEIDS"]]


def x_get_querying_descendants_for_container__mutmut_23(
    node_id: NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[NodeId]]:
    """
    Returns the descendants of a container query container that have
    container queries against this container.

    **EXPERIMENTAL**

    :param node_id: Id of the container node to find querying descendants from.
    :returns: Descendant nodes with container queries against the given container.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getQueryingDescendantsForContainer",
        "params": params,
    }
    json = yield cmd_dict
    return [NodeId.from_json(i) for i in json["Nodeids"]]

x_get_querying_descendants_for_container__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_querying_descendants_for_container__mutmut_1': x_get_querying_descendants_for_container__mutmut_1, 
    'x_get_querying_descendants_for_container__mutmut_2': x_get_querying_descendants_for_container__mutmut_2, 
    'x_get_querying_descendants_for_container__mutmut_3': x_get_querying_descendants_for_container__mutmut_3, 
    'x_get_querying_descendants_for_container__mutmut_4': x_get_querying_descendants_for_container__mutmut_4, 
    'x_get_querying_descendants_for_container__mutmut_5': x_get_querying_descendants_for_container__mutmut_5, 
    'x_get_querying_descendants_for_container__mutmut_6': x_get_querying_descendants_for_container__mutmut_6, 
    'x_get_querying_descendants_for_container__mutmut_7': x_get_querying_descendants_for_container__mutmut_7, 
    'x_get_querying_descendants_for_container__mutmut_8': x_get_querying_descendants_for_container__mutmut_8, 
    'x_get_querying_descendants_for_container__mutmut_9': x_get_querying_descendants_for_container__mutmut_9, 
    'x_get_querying_descendants_for_container__mutmut_10': x_get_querying_descendants_for_container__mutmut_10, 
    'x_get_querying_descendants_for_container__mutmut_11': x_get_querying_descendants_for_container__mutmut_11, 
    'x_get_querying_descendants_for_container__mutmut_12': x_get_querying_descendants_for_container__mutmut_12, 
    'x_get_querying_descendants_for_container__mutmut_13': x_get_querying_descendants_for_container__mutmut_13, 
    'x_get_querying_descendants_for_container__mutmut_14': x_get_querying_descendants_for_container__mutmut_14, 
    'x_get_querying_descendants_for_container__mutmut_15': x_get_querying_descendants_for_container__mutmut_15, 
    'x_get_querying_descendants_for_container__mutmut_16': x_get_querying_descendants_for_container__mutmut_16, 
    'x_get_querying_descendants_for_container__mutmut_17': x_get_querying_descendants_for_container__mutmut_17, 
    'x_get_querying_descendants_for_container__mutmut_18': x_get_querying_descendants_for_container__mutmut_18, 
    'x_get_querying_descendants_for_container__mutmut_19': x_get_querying_descendants_for_container__mutmut_19, 
    'x_get_querying_descendants_for_container__mutmut_20': x_get_querying_descendants_for_container__mutmut_20, 
    'x_get_querying_descendants_for_container__mutmut_21': x_get_querying_descendants_for_container__mutmut_21, 
    'x_get_querying_descendants_for_container__mutmut_22': x_get_querying_descendants_for_container__mutmut_22, 
    'x_get_querying_descendants_for_container__mutmut_23': x_get_querying_descendants_for_container__mutmut_23
}

def get_querying_descendants_for_container(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_querying_descendants_for_container__mutmut_orig, x_get_querying_descendants_for_container__mutmut_mutants, args, kwargs)
    return result 

get_querying_descendants_for_container.__signature__ = _mutmut_signature(x_get_querying_descendants_for_container__mutmut_orig)
x_get_querying_descendants_for_container__mutmut_orig.__name__ = 'x_get_querying_descendants_for_container'


def x_get_anchor_element__mutmut_orig(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_1(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = None
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_2(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = None
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_3(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["XXnodeIdXX"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_4(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeid"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_5(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["NODEID"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_6(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["Nodeid"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_7(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_8(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_9(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["XXanchorSpecifierXX"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_10(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorspecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_11(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["ANCHORSPECIFIER"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_12(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["Anchorspecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_13(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_14(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_15(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "METHOD": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_16(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "Method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_17(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "XXDOM.getAnchorElementXX",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_18(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "dom.getanchorelement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_19(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.GETANCHORELEMENT",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_20(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "Dom.getanchorelement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_21(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_22(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_23(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "Params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_24(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = None
    return NodeId.from_json(json["nodeId"])


def x_get_anchor_element__mutmut_25(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(None)


def x_get_anchor_element__mutmut_26(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["XXnodeIdXX"])


def x_get_anchor_element__mutmut_27(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["nodeid"])


def x_get_anchor_element__mutmut_28(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["NODEID"])


def x_get_anchor_element__mutmut_29(
    node_id: NodeId,
    anchor_specifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, NodeId]:
    """
    Returns the target anchor element of the given anchor query according to
    https://www.w3.org/TR/css-anchor-position-1/#target.

    **EXPERIMENTAL**

    :param node_id: Id of the positioned element from which to find the anchor.
    :param anchor_specifier: *(Optional)* An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
    :returns: The anchor element of the given anchor query.
    """
    params: T_JSON_DICT = {}
    params["nodeId"] = node_id.to_json()
    if anchor_specifier is not None:
        params["anchorSpecifier"] = anchor_specifier
    cmd_dict: T_JSON_DICT = {
        "method": "DOM.getAnchorElement",
        "params": params,
    }
    json = yield cmd_dict
    return NodeId.from_json(json["Nodeid"])

x_get_anchor_element__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_anchor_element__mutmut_1': x_get_anchor_element__mutmut_1, 
    'x_get_anchor_element__mutmut_2': x_get_anchor_element__mutmut_2, 
    'x_get_anchor_element__mutmut_3': x_get_anchor_element__mutmut_3, 
    'x_get_anchor_element__mutmut_4': x_get_anchor_element__mutmut_4, 
    'x_get_anchor_element__mutmut_5': x_get_anchor_element__mutmut_5, 
    'x_get_anchor_element__mutmut_6': x_get_anchor_element__mutmut_6, 
    'x_get_anchor_element__mutmut_7': x_get_anchor_element__mutmut_7, 
    'x_get_anchor_element__mutmut_8': x_get_anchor_element__mutmut_8, 
    'x_get_anchor_element__mutmut_9': x_get_anchor_element__mutmut_9, 
    'x_get_anchor_element__mutmut_10': x_get_anchor_element__mutmut_10, 
    'x_get_anchor_element__mutmut_11': x_get_anchor_element__mutmut_11, 
    'x_get_anchor_element__mutmut_12': x_get_anchor_element__mutmut_12, 
    'x_get_anchor_element__mutmut_13': x_get_anchor_element__mutmut_13, 
    'x_get_anchor_element__mutmut_14': x_get_anchor_element__mutmut_14, 
    'x_get_anchor_element__mutmut_15': x_get_anchor_element__mutmut_15, 
    'x_get_anchor_element__mutmut_16': x_get_anchor_element__mutmut_16, 
    'x_get_anchor_element__mutmut_17': x_get_anchor_element__mutmut_17, 
    'x_get_anchor_element__mutmut_18': x_get_anchor_element__mutmut_18, 
    'x_get_anchor_element__mutmut_19': x_get_anchor_element__mutmut_19, 
    'x_get_anchor_element__mutmut_20': x_get_anchor_element__mutmut_20, 
    'x_get_anchor_element__mutmut_21': x_get_anchor_element__mutmut_21, 
    'x_get_anchor_element__mutmut_22': x_get_anchor_element__mutmut_22, 
    'x_get_anchor_element__mutmut_23': x_get_anchor_element__mutmut_23, 
    'x_get_anchor_element__mutmut_24': x_get_anchor_element__mutmut_24, 
    'x_get_anchor_element__mutmut_25': x_get_anchor_element__mutmut_25, 
    'x_get_anchor_element__mutmut_26': x_get_anchor_element__mutmut_26, 
    'x_get_anchor_element__mutmut_27': x_get_anchor_element__mutmut_27, 
    'x_get_anchor_element__mutmut_28': x_get_anchor_element__mutmut_28, 
    'x_get_anchor_element__mutmut_29': x_get_anchor_element__mutmut_29
}

def get_anchor_element(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_anchor_element__mutmut_orig, x_get_anchor_element__mutmut_mutants, args, kwargs)
    return result 

get_anchor_element.__signature__ = _mutmut_signature(x_get_anchor_element__mutmut_orig)
x_get_anchor_element__mutmut_orig.__name__ = 'x_get_anchor_element'


@event_class("DOM.attributeModified")
@dataclass
class AttributeModified:
    """
    Fired when ``Element``'s attribute is modified.
    """
    #: Id of the node that has changed.
    node_id: NodeId
    #: Attribute name.
    name: str
    #: Attribute value.
    value: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AttributeModified:
        return cls(
            node_id=NodeId.from_json(json["nodeId"]),
            name=str(json["name"]),
            value=str(json["value"]),
        )


@event_class("DOM.attributeRemoved")
@dataclass
class AttributeRemoved:
    """
    Fired when ``Element``'s attribute is removed.
    """
    #: Id of the node that has changed.
    node_id: NodeId
    #: A ttribute name.
    name: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AttributeRemoved:
        return cls(
            node_id=NodeId.from_json(json["nodeId"]),
            name=str(json["name"]),
        )


@event_class("DOM.characterDataModified")
@dataclass
class CharacterDataModified:
    """
    Mirrors ``DOMCharacterDataModified`` event.
    """
    #: Id of the node that has changed.
    node_id: NodeId
    #: New text value.
    character_data: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CharacterDataModified:
        return cls(
            node_id=NodeId.from_json(json["nodeId"]),
            character_data=str(json["characterData"]),
        )


@event_class("DOM.childNodeCountUpdated")
@dataclass
class ChildNodeCountUpdated:
    """
    Fired when ``Container``'s child node count has changed.
    """
    #: Id of the node that has changed.
    node_id: NodeId
    #: New node count.
    child_node_count: int

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ChildNodeCountUpdated:
        return cls(
            node_id=NodeId.from_json(json["nodeId"]),
            child_node_count=int(json["childNodeCount"]),
        )


@event_class("DOM.childNodeInserted")
@dataclass
class ChildNodeInserted:
    """
    Mirrors ``DOMNodeInserted`` event.
    """
    #: Id of the node that has changed.
    parent_node_id: NodeId
    #: Id of the previous sibling.
    previous_node_id: NodeId
    #: Inserted node data.
    node: Node

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ChildNodeInserted:
        return cls(
            parent_node_id=NodeId.from_json(json["parentNodeId"]),
            previous_node_id=NodeId.from_json(json["previousNodeId"]),
            node=Node.from_json(json["node"]),
        )


@event_class("DOM.childNodeRemoved")
@dataclass
class ChildNodeRemoved:
    """
    Mirrors ``DOMNodeRemoved`` event.
    """
    #: Parent id.
    parent_node_id: NodeId
    #: Id of the node that has been removed.
    node_id: NodeId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ChildNodeRemoved:
        return cls(
            parent_node_id=NodeId.from_json(json["parentNodeId"]),
            node_id=NodeId.from_json(json["nodeId"]),
        )


@event_class("DOM.distributedNodesUpdated")
@dataclass
class DistributedNodesUpdated:
    """
    **EXPERIMENTAL**

    Called when distribution is changed.
    """
    #: Insertion point where distributed nodes were updated.
    insertion_point_id: NodeId
    #: Distributed nodes for given insertion point.
    distributed_nodes: list[BackendNode]

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DistributedNodesUpdated:
        return cls(
            insertion_point_id=NodeId.from_json(json["insertionPointId"]),
            distributed_nodes=[BackendNode.from_json(i) for i in json["distributedNodes"]],
        )


@event_class("DOM.documentUpdated")
@dataclass
class DocumentUpdated:
    """
    Fired when ``Document`` has been totally updated. Node ids are no longer valid.
    """


    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DocumentUpdated:
        return cls(

        )


@event_class("DOM.inlineStyleInvalidated")
@dataclass
class InlineStyleInvalidated:
    """
    **EXPERIMENTAL**

    Fired when ``Element``'s inline style is modified via a CSS property modification.
    """
    #: Ids of the nodes for which the inline styles have been invalidated.
    node_ids: list[NodeId]

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> InlineStyleInvalidated:
        return cls(
            node_ids=[NodeId.from_json(i) for i in json["nodeIds"]],
        )


@event_class("DOM.pseudoElementAdded")
@dataclass
class PseudoElementAdded:
    """
    **EXPERIMENTAL**

    Called when a pseudo element is added to an element.
    """
    #: Pseudo element's parent element id.
    parent_id: NodeId
    #: The added pseudo element.
    pseudo_element: Node

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PseudoElementAdded:
        return cls(
            parent_id=NodeId.from_json(json["parentId"]),
            pseudo_element=Node.from_json(json["pseudoElement"]),
        )


@event_class("DOM.topLayerElementsUpdated")
@dataclass
class TopLayerElementsUpdated:
    """
    **EXPERIMENTAL**

    Called when top layer elements are changed.
    """


    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> TopLayerElementsUpdated:
        return cls(

        )


@event_class("DOM.scrollableFlagUpdated")
@dataclass
class ScrollableFlagUpdated:
    """
    **EXPERIMENTAL**

    Fired when a node's scrollability state changes.
    """
    #: The id of the node.
    node_id: NodeId
    #: If the node is scrollable.
    is_scrollable: bool

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScrollableFlagUpdated:
        return cls(
            node_id=NodeId.from_json(json["nodeId"]),
            is_scrollable=bool(json["isScrollable"]),
        )


@event_class("DOM.pseudoElementRemoved")
@dataclass
class PseudoElementRemoved:
    """
    **EXPERIMENTAL**

    Called when a pseudo element is removed from an element.
    """
    #: Pseudo element's parent element id.
    parent_id: NodeId
    #: The removed pseudo element id.
    pseudo_element_id: NodeId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PseudoElementRemoved:
        return cls(
            parent_id=NodeId.from_json(json["parentId"]),
            pseudo_element_id=NodeId.from_json(json["pseudoElementId"]),
        )


@event_class("DOM.setChildNodes")
@dataclass
class SetChildNodes:
    """
    Fired when backend wants to provide client with the missing DOM structure. This happens upon
    most of the calls requesting node ids.
    """
    #: Parent node id to populate with children.
    parent_id: NodeId
    #: Child nodes array.
    nodes: list[Node]

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> SetChildNodes:
        return cls(
            parent_id=NodeId.from_json(json["parentId"]),
            nodes=[Node.from_json(i) for i in json["nodes"]],
        )


@event_class("DOM.shadowRootPopped")
@dataclass
class ShadowRootPopped:
    """
    **EXPERIMENTAL**

    Called when shadow root is popped from the element.
    """
    #: Host element id.
    host_id: NodeId
    #: Shadow root id.
    root_id: NodeId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ShadowRootPopped:
        return cls(
            host_id=NodeId.from_json(json["hostId"]),
            root_id=NodeId.from_json(json["rootId"]),
        )


@event_class("DOM.shadowRootPushed")
@dataclass
class ShadowRootPushed:
    """
    **EXPERIMENTAL**

    Called when shadow root is pushed into the element.
    """
    #: Host element id.
    host_id: NodeId
    #: Shadow root.
    root: Node

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ShadowRootPushed:
        return cls(
            host_id=NodeId.from_json(json["hostId"]),
            root=Node.from_json(json["root"]),
        )
