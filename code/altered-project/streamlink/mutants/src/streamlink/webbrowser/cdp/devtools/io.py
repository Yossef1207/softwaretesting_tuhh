# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all modules.
#
# CDP version: v0.0.1438564
# CDP domain: IO

from __future__ import annotations

import enum
from collections.abc import Generator
from dataclasses import dataclass
from typing import Any

import streamlink.webbrowser.cdp.devtools.runtime as runtime
from streamlink.webbrowser.cdp.devtools.util import T_JSON_DICT, event_class
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


class StreamHandle(str):
    """
    This is either obtained from another method or specified as ``blob:<uuid>`` where
    ``<uuid>`` is an UUID of a Blob.
    """
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> StreamHandle:
        return cls(json)

    def __repr__(self):
        return f"StreamHandle({super().__repr__()})"


def x_close__mutmut_orig(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.close",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_1(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = None
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.close",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_2(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "IO.close",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_3(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["XXhandleXX"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.close",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_4(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["HANDLE"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.close",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_5(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["Handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.close",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_6(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_close__mutmut_7(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "IO.close",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_8(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "IO.close",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_9(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "IO.close",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_10(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXIO.closeXX",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_11(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "io.close",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_12(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.CLOSE",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_13(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Io.close",
        "params": params,
    }
    yield cmd_dict


def x_close__mutmut_14(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.close",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_close__mutmut_15(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.close",
        "PARAMS": params,
    }
    yield cmd_dict


def x_close__mutmut_16(
    handle: StreamHandle,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Close the stream, discard any temporary backing storage.

    :param handle: Handle of the stream to close.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.close",
        "Params": params,
    }
    yield cmd_dict

x_close__mutmut_mutants : ClassVar[MutantDict] = {
'x_close__mutmut_1': x_close__mutmut_1, 
    'x_close__mutmut_2': x_close__mutmut_2, 
    'x_close__mutmut_3': x_close__mutmut_3, 
    'x_close__mutmut_4': x_close__mutmut_4, 
    'x_close__mutmut_5': x_close__mutmut_5, 
    'x_close__mutmut_6': x_close__mutmut_6, 
    'x_close__mutmut_7': x_close__mutmut_7, 
    'x_close__mutmut_8': x_close__mutmut_8, 
    'x_close__mutmut_9': x_close__mutmut_9, 
    'x_close__mutmut_10': x_close__mutmut_10, 
    'x_close__mutmut_11': x_close__mutmut_11, 
    'x_close__mutmut_12': x_close__mutmut_12, 
    'x_close__mutmut_13': x_close__mutmut_13, 
    'x_close__mutmut_14': x_close__mutmut_14, 
    'x_close__mutmut_15': x_close__mutmut_15, 
    'x_close__mutmut_16': x_close__mutmut_16
}

def close(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_close__mutmut_orig, x_close__mutmut_mutants, args, kwargs)
    return result 

close.__signature__ = _mutmut_signature(x_close__mutmut_orig)
x_close__mutmut_orig.__name__ = 'x_close'


def x_read__mutmut_orig(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_1(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = None
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_2(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = None
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_3(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["XXhandleXX"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_4(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["HANDLE"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_5(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["Handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_6(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_7(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = None
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_8(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["XXoffsetXX"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_9(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["OFFSET"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_10(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["Offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_11(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_12(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_13(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["XXsizeXX"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_14(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["SIZE"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_15(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["Size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_16(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_17(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_18(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "METHOD": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_19(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "Method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_20(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "XXIO.readXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_21(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "io.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_22(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.READ",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_23(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "Io.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_24(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_25(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_26(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_27(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = None
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_28(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(None) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_29(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["XXbase64EncodedXX"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_30(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_31(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["BASE64ENCODED"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_32(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["Base64encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_33(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "XXbase64EncodedXX" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_34(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_35(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "BASE64ENCODED" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_36(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "Base64encoded" in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_37(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" not in json else None,
        str(json["data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_38(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(None),
        bool(json["eof"]),
    )


def x_read__mutmut_39(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["XXdataXX"]),
        bool(json["eof"]),
    )


def x_read__mutmut_40(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["DATA"]),
        bool(json["eof"]),
    )


def x_read__mutmut_41(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["Data"]),
        bool(json["eof"]),
    )


def x_read__mutmut_42(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(None),
    )


def x_read__mutmut_43(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["XXeofXX"]),
    )


def x_read__mutmut_44(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["EOF"]),
    )


def x_read__mutmut_45(
    handle: StreamHandle,
    offset: int | None = None,
    size: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[bool | None, str, bool]]:
    """
    Read a chunk of the stream

    :param handle: Handle of the stream to read.
    :param offset: *(Optional)* Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
    :param size: *(Optional)* Maximum number of bytes to read (left upon the agent discretion if not specified).
    :returns: A tuple with the following items:

        0. **base64Encoded** - *(Optional)* Set if the data is base64-encoded
        1. **data** - Data that were read.
        2. **eof** - Set if the end-of-file condition occurred while reading.
    """
    params: T_JSON_DICT = {}
    params["handle"] = handle.to_json()
    if offset is not None:
        params["offset"] = offset
    if size is not None:
        params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "IO.read",
        "params": params,
    }
    json = yield cmd_dict
    return (
        bool(json["base64Encoded"]) if "base64Encoded" in json else None,
        str(json["data"]),
        bool(json["Eof"]),
    )

x_read__mutmut_mutants : ClassVar[MutantDict] = {
'x_read__mutmut_1': x_read__mutmut_1, 
    'x_read__mutmut_2': x_read__mutmut_2, 
    'x_read__mutmut_3': x_read__mutmut_3, 
    'x_read__mutmut_4': x_read__mutmut_4, 
    'x_read__mutmut_5': x_read__mutmut_5, 
    'x_read__mutmut_6': x_read__mutmut_6, 
    'x_read__mutmut_7': x_read__mutmut_7, 
    'x_read__mutmut_8': x_read__mutmut_8, 
    'x_read__mutmut_9': x_read__mutmut_9, 
    'x_read__mutmut_10': x_read__mutmut_10, 
    'x_read__mutmut_11': x_read__mutmut_11, 
    'x_read__mutmut_12': x_read__mutmut_12, 
    'x_read__mutmut_13': x_read__mutmut_13, 
    'x_read__mutmut_14': x_read__mutmut_14, 
    'x_read__mutmut_15': x_read__mutmut_15, 
    'x_read__mutmut_16': x_read__mutmut_16, 
    'x_read__mutmut_17': x_read__mutmut_17, 
    'x_read__mutmut_18': x_read__mutmut_18, 
    'x_read__mutmut_19': x_read__mutmut_19, 
    'x_read__mutmut_20': x_read__mutmut_20, 
    'x_read__mutmut_21': x_read__mutmut_21, 
    'x_read__mutmut_22': x_read__mutmut_22, 
    'x_read__mutmut_23': x_read__mutmut_23, 
    'x_read__mutmut_24': x_read__mutmut_24, 
    'x_read__mutmut_25': x_read__mutmut_25, 
    'x_read__mutmut_26': x_read__mutmut_26, 
    'x_read__mutmut_27': x_read__mutmut_27, 
    'x_read__mutmut_28': x_read__mutmut_28, 
    'x_read__mutmut_29': x_read__mutmut_29, 
    'x_read__mutmut_30': x_read__mutmut_30, 
    'x_read__mutmut_31': x_read__mutmut_31, 
    'x_read__mutmut_32': x_read__mutmut_32, 
    'x_read__mutmut_33': x_read__mutmut_33, 
    'x_read__mutmut_34': x_read__mutmut_34, 
    'x_read__mutmut_35': x_read__mutmut_35, 
    'x_read__mutmut_36': x_read__mutmut_36, 
    'x_read__mutmut_37': x_read__mutmut_37, 
    'x_read__mutmut_38': x_read__mutmut_38, 
    'x_read__mutmut_39': x_read__mutmut_39, 
    'x_read__mutmut_40': x_read__mutmut_40, 
    'x_read__mutmut_41': x_read__mutmut_41, 
    'x_read__mutmut_42': x_read__mutmut_42, 
    'x_read__mutmut_43': x_read__mutmut_43, 
    'x_read__mutmut_44': x_read__mutmut_44, 
    'x_read__mutmut_45': x_read__mutmut_45
}

def read(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_read__mutmut_orig, x_read__mutmut_mutants, args, kwargs)
    return result 

read.__signature__ = _mutmut_signature(x_read__mutmut_orig)
x_read__mutmut_orig.__name__ = 'x_read'


def x_resolve_blob__mutmut_orig(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_1(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = None
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_2(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_3(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["XXobjectIdXX"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_4(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_5(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["OBJECTID"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_6(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["Objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_7(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_8(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_9(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_10(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_11(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXIO.resolveBlobXX",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_12(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "io.resolveblob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_13(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.RESOLVEBLOB",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_14(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Io.resolveblob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_15(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_16(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_17(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "Params": params,
    }
    json = yield cmd_dict
    return str(json["uuid"])


def x_resolve_blob__mutmut_18(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = None
    return str(json["uuid"])


def x_resolve_blob__mutmut_19(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(None)


def x_resolve_blob__mutmut_20(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["XXuuidXX"])


def x_resolve_blob__mutmut_21(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["UUID"])


def x_resolve_blob__mutmut_22(
    object_id: runtime.RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Return UUID of Blob object specified by a remote object id.

    :param object_id: Object id of a Blob object wrapper.
    :returns: UUID of the specified Blob.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "IO.resolveBlob",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["Uuid"])

x_resolve_blob__mutmut_mutants : ClassVar[MutantDict] = {
'x_resolve_blob__mutmut_1': x_resolve_blob__mutmut_1, 
    'x_resolve_blob__mutmut_2': x_resolve_blob__mutmut_2, 
    'x_resolve_blob__mutmut_3': x_resolve_blob__mutmut_3, 
    'x_resolve_blob__mutmut_4': x_resolve_blob__mutmut_4, 
    'x_resolve_blob__mutmut_5': x_resolve_blob__mutmut_5, 
    'x_resolve_blob__mutmut_6': x_resolve_blob__mutmut_6, 
    'x_resolve_blob__mutmut_7': x_resolve_blob__mutmut_7, 
    'x_resolve_blob__mutmut_8': x_resolve_blob__mutmut_8, 
    'x_resolve_blob__mutmut_9': x_resolve_blob__mutmut_9, 
    'x_resolve_blob__mutmut_10': x_resolve_blob__mutmut_10, 
    'x_resolve_blob__mutmut_11': x_resolve_blob__mutmut_11, 
    'x_resolve_blob__mutmut_12': x_resolve_blob__mutmut_12, 
    'x_resolve_blob__mutmut_13': x_resolve_blob__mutmut_13, 
    'x_resolve_blob__mutmut_14': x_resolve_blob__mutmut_14, 
    'x_resolve_blob__mutmut_15': x_resolve_blob__mutmut_15, 
    'x_resolve_blob__mutmut_16': x_resolve_blob__mutmut_16, 
    'x_resolve_blob__mutmut_17': x_resolve_blob__mutmut_17, 
    'x_resolve_blob__mutmut_18': x_resolve_blob__mutmut_18, 
    'x_resolve_blob__mutmut_19': x_resolve_blob__mutmut_19, 
    'x_resolve_blob__mutmut_20': x_resolve_blob__mutmut_20, 
    'x_resolve_blob__mutmut_21': x_resolve_blob__mutmut_21, 
    'x_resolve_blob__mutmut_22': x_resolve_blob__mutmut_22
}

def resolve_blob(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_resolve_blob__mutmut_orig, x_resolve_blob__mutmut_mutants, args, kwargs)
    return result 

resolve_blob.__signature__ = _mutmut_signature(x_resolve_blob__mutmut_orig)
x_resolve_blob__mutmut_orig.__name__ = 'x_resolve_blob'
