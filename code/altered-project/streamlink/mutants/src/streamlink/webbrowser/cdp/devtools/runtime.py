# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all modules.
#
# CDP version: v0.0.1438564
# CDP domain: Runtime

from __future__ import annotations

import enum
from collections.abc import Generator
from dataclasses import dataclass
from typing import Any

from streamlink.webbrowser.cdp.devtools.util import T_JSON_DICT, event_class
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


class ScriptId(str):
    """
    Unique script identifier.
    """
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> ScriptId:
        return cls(json)

    def __repr__(self):
        return f"ScriptId({super().__repr__()})"


@dataclass
class SerializationOptions:
    """
    Represents options for serialization. Overrides ``generatePreview`` and ``returnByValue``.
    """
    serialization: str

    #: Deep serialization depth. Default is full depth. Respected only in ``deep`` serialization mode.
    max_depth: int | None = None

    #: Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM
    #: serialization via ``maxNodeDepth: integer`` and ``includeShadowTree: "none" `` "open" `` "all"``.
    #: Values can be only of type string or integer.
    additional_parameters: dict | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["serialization"] = self.serialization
        if self.max_depth is not None:
            json["maxDepth"] = self.max_depth
        if self.additional_parameters is not None:
            json["additionalParameters"] = self.additional_parameters
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> SerializationOptions:
        return cls(
            serialization=str(json["serialization"]),
            max_depth=int(json["maxDepth"]) if "maxDepth" in json else None,
            additional_parameters=dict(json["additionalParameters"]) if "additionalParameters" in json else None,
        )


@dataclass
class DeepSerializedValue:
    """
    Represents deep serialized value.
    """
    type_: str

    value: Any | None = None

    object_id: str | None = None

    #: Set if value reference met more then once during serialization. In such
    #: case, value is provided only to one of the serialized values. Unique
    #: per value in the scope of one CDP call.
    weak_local_object_reference: int | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["type"] = self.type_
        if self.value is not None:
            json["value"] = self.value
        if self.object_id is not None:
            json["objectId"] = self.object_id
        if self.weak_local_object_reference is not None:
            json["weakLocalObjectReference"] = self.weak_local_object_reference
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DeepSerializedValue:
        return cls(
            type_=str(json["type"]),
            value=json["value"] if "value" in json else None,
            object_id=str(json["objectId"]) if "objectId" in json else None,
            weak_local_object_reference=int(json["weakLocalObjectReference"]) if "weakLocalObjectReference" in json else None,
        )


class RemoteObjectId(str):
    """
    Unique object identifier.
    """
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> RemoteObjectId:
        return cls(json)

    def __repr__(self):
        return f"RemoteObjectId({super().__repr__()})"


class UnserializableValue(str):
    """
    Primitive value which cannot be JSON-stringified. Includes values ``-0``, ``NaN``, ``Infinity``,
    ``-Infinity``, and bigint literals.
    """
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> UnserializableValue:
        return cls(json)

    def __repr__(self):
        return f"UnserializableValue({super().__repr__()})"


@dataclass
class RemoteObject:
    """
    Mirror object referencing original JavaScript object.
    """
    #: Object type.
    type_: str

    #: Object subtype hint. Specified for ``object`` type values only.
    #: NOTE: If you change anything here, make sure to also update
    #: ``subtype`` in ``ObjectPreview`` and ``PropertyPreview`` below.
    subtype: str | None = None

    #: Object class (constructor) name. Specified for ``object`` type values only.
    class_name: str | None = None

    #: Remote object value in case of primitive values or JSON values (if it was requested).
    value: Any | None = None

    #: Primitive value which can not be JSON-stringified does not have ``value``, but gets this
    #: property.
    unserializable_value: UnserializableValue | None = None

    #: String representation of the object.
    description: str | None = None

    #: Deep serialized value.
    deep_serialized_value: DeepSerializedValue | None = None

    #: Unique object identifier (for non-primitive values).
    object_id: RemoteObjectId | None = None

    #: Preview containing abbreviated property values. Specified for ``object`` type values only.
    preview: ObjectPreview | None = None

    custom_preview: CustomPreview | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["type"] = self.type_
        if self.subtype is not None:
            json["subtype"] = self.subtype
        if self.class_name is not None:
            json["className"] = self.class_name
        if self.value is not None:
            json["value"] = self.value
        if self.unserializable_value is not None:
            json["unserializableValue"] = self.unserializable_value.to_json()
        if self.description is not None:
            json["description"] = self.description
        if self.deep_serialized_value is not None:
            json["deepSerializedValue"] = self.deep_serialized_value.to_json()
        if self.object_id is not None:
            json["objectId"] = self.object_id.to_json()
        if self.preview is not None:
            json["preview"] = self.preview.to_json()
        if self.custom_preview is not None:
            json["customPreview"] = self.custom_preview.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> RemoteObject:
        return cls(
            type_=str(json["type"]),
            subtype=str(json["subtype"]) if "subtype" in json else None,
            class_name=str(json["className"]) if "className" in json else None,
            value=json["value"] if "value" in json else None,
            unserializable_value=UnserializableValue.from_json(json["unserializableValue"]) if "unserializableValue" in json else None,
            description=str(json["description"]) if "description" in json else None,
            deep_serialized_value=DeepSerializedValue.from_json(json["deepSerializedValue"]) if "deepSerializedValue" in json else None,
            object_id=RemoteObjectId.from_json(json["objectId"]) if "objectId" in json else None,
            preview=ObjectPreview.from_json(json["preview"]) if "preview" in json else None,
            custom_preview=CustomPreview.from_json(json["customPreview"]) if "customPreview" in json else None,
        )


@dataclass
class CustomPreview:
    #: The JSON-stringified result of formatter.header(object, config) call.
    #: It contains json ML array that represents RemoteObject.
    header: str

    #: If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
    #: contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
    #: The result value is json ML array.
    body_getter_id: RemoteObjectId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["header"] = self.header
        if self.body_getter_id is not None:
            json["bodyGetterId"] = self.body_getter_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CustomPreview:
        return cls(
            header=str(json["header"]),
            body_getter_id=RemoteObjectId.from_json(json["bodyGetterId"]) if "bodyGetterId" in json else None,
        )


@dataclass
class ObjectPreview:
    """
    Object containing abbreviated remote object value.
    """
    #: Object type.
    type_: str

    #: True iff some of the properties or entries of the original object did not fit.
    overflow: bool

    #: List of the properties.
    properties: list[PropertyPreview]

    #: Object subtype hint. Specified for ``object`` type values only.
    subtype: str | None = None

    #: String representation of the object.
    description: str | None = None

    #: List of the entries. Specified for ``map`` and ``set`` subtype values only.
    entries: list[EntryPreview] | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["type"] = self.type_
        json["overflow"] = self.overflow
        json["properties"] = [i.to_json() for i in self.properties]
        if self.subtype is not None:
            json["subtype"] = self.subtype
        if self.description is not None:
            json["description"] = self.description
        if self.entries is not None:
            json["entries"] = [i.to_json() for i in self.entries]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ObjectPreview:
        return cls(
            type_=str(json["type"]),
            overflow=bool(json["overflow"]),
            properties=[PropertyPreview.from_json(i) for i in json["properties"]],
            subtype=str(json["subtype"]) if "subtype" in json else None,
            description=str(json["description"]) if "description" in json else None,
            entries=[EntryPreview.from_json(i) for i in json["entries"]] if "entries" in json else None,
        )


@dataclass
class PropertyPreview:
    #: Property name.
    name: str

    #: Object type. Accessor means that the property itself is an accessor property.
    type_: str

    #: User-friendly property value string.
    value: str | None = None

    #: Nested value preview.
    value_preview: ObjectPreview | None = None

    #: Object subtype hint. Specified for ``object`` type values only.
    subtype: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["name"] = self.name
        json["type"] = self.type_
        if self.value is not None:
            json["value"] = self.value
        if self.value_preview is not None:
            json["valuePreview"] = self.value_preview.to_json()
        if self.subtype is not None:
            json["subtype"] = self.subtype
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PropertyPreview:
        return cls(
            name=str(json["name"]),
            type_=str(json["type"]),
            value=str(json["value"]) if "value" in json else None,
            value_preview=ObjectPreview.from_json(json["valuePreview"]) if "valuePreview" in json else None,
            subtype=str(json["subtype"]) if "subtype" in json else None,
        )


@dataclass
class EntryPreview:
    #: Preview of the value.
    value: ObjectPreview

    #: Preview of the key. Specified for map-like collection entries.
    key: ObjectPreview | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["value"] = self.value.to_json()
        if self.key is not None:
            json["key"] = self.key.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> EntryPreview:
        return cls(
            value=ObjectPreview.from_json(json["value"]),
            key=ObjectPreview.from_json(json["key"]) if "key" in json else None,
        )


@dataclass
class PropertyDescriptor:
    """
    Object property descriptor.
    """
    #: Property name or symbol description.
    name: str

    #: True if the type of this property descriptor may be changed and if the property may be
    #: deleted from the corresponding object.
    configurable: bool

    #: True if this property shows up during enumeration of the properties on the corresponding
    #: object.
    enumerable: bool

    #: The value associated with the property.
    value: RemoteObject | None = None

    #: True if the value associated with the property may be changed (data descriptors only).
    writable: bool | None = None

    #: A function which serves as a getter for the property, or ``undefined`` if there is no getter
    #: (accessor descriptors only).
    get: RemoteObject | None = None

    #: A function which serves as a setter for the property, or ``undefined`` if there is no setter
    #: (accessor descriptors only).
    set_: RemoteObject | None = None

    #: True if the result was thrown during the evaluation.
    was_thrown: bool | None = None

    #: True if the property is owned for the object.
    is_own: bool | None = None

    #: Property symbol object, if the property is of the ``symbol`` type.
    symbol: RemoteObject | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["name"] = self.name
        json["configurable"] = self.configurable
        json["enumerable"] = self.enumerable
        if self.value is not None:
            json["value"] = self.value.to_json()
        if self.writable is not None:
            json["writable"] = self.writable
        if self.get is not None:
            json["get"] = self.get.to_json()
        if self.set_ is not None:
            json["set"] = self.set_.to_json()
        if self.was_thrown is not None:
            json["wasThrown"] = self.was_thrown
        if self.is_own is not None:
            json["isOwn"] = self.is_own
        if self.symbol is not None:
            json["symbol"] = self.symbol.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PropertyDescriptor:
        return cls(
            name=str(json["name"]),
            configurable=bool(json["configurable"]),
            enumerable=bool(json["enumerable"]),
            value=RemoteObject.from_json(json["value"]) if "value" in json else None,
            writable=bool(json["writable"]) if "writable" in json else None,
            get=RemoteObject.from_json(json["get"]) if "get" in json else None,
            set_=RemoteObject.from_json(json["set"]) if "set" in json else None,
            was_thrown=bool(json["wasThrown"]) if "wasThrown" in json else None,
            is_own=bool(json["isOwn"]) if "isOwn" in json else None,
            symbol=RemoteObject.from_json(json["symbol"]) if "symbol" in json else None,
        )


@dataclass
class InternalPropertyDescriptor:
    """
    Object internal property descriptor. This property isn't normally visible in JavaScript code.
    """
    #: Conventional property name.
    name: str

    #: The value associated with the property.
    value: RemoteObject | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["name"] = self.name
        if self.value is not None:
            json["value"] = self.value.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> InternalPropertyDescriptor:
        return cls(
            name=str(json["name"]),
            value=RemoteObject.from_json(json["value"]) if "value" in json else None,
        )


@dataclass
class PrivatePropertyDescriptor:
    """
    Object private field descriptor.
    """
    #: Private property name.
    name: str

    #: The value associated with the private property.
    value: RemoteObject | None = None

    #: A function which serves as a getter for the private property,
    #: or ``undefined`` if there is no getter (accessor descriptors only).
    get: RemoteObject | None = None

    #: A function which serves as a setter for the private property,
    #: or ``undefined`` if there is no setter (accessor descriptors only).
    set_: RemoteObject | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["name"] = self.name
        if self.value is not None:
            json["value"] = self.value.to_json()
        if self.get is not None:
            json["get"] = self.get.to_json()
        if self.set_ is not None:
            json["set"] = self.set_.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PrivatePropertyDescriptor:
        return cls(
            name=str(json["name"]),
            value=RemoteObject.from_json(json["value"]) if "value" in json else None,
            get=RemoteObject.from_json(json["get"]) if "get" in json else None,
            set_=RemoteObject.from_json(json["set"]) if "set" in json else None,
        )


@dataclass
class CallArgument:
    """
    Represents function call argument. Either remote object id ``objectId``, primitive ``value``,
    unserializable primitive value or neither of (for undefined) them should be specified.
    """
    #: Primitive value or serializable javascript object.
    value: Any | None = None

    #: Primitive value which can not be JSON-stringified.
    unserializable_value: UnserializableValue | None = None

    #: Remote object handle.
    object_id: RemoteObjectId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.value is not None:
            json["value"] = self.value
        if self.unserializable_value is not None:
            json["unserializableValue"] = self.unserializable_value.to_json()
        if self.object_id is not None:
            json["objectId"] = self.object_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CallArgument:
        return cls(
            value=json["value"] if "value" in json else None,
            unserializable_value=UnserializableValue.from_json(json["unserializableValue"]) if "unserializableValue" in json else None,
            object_id=RemoteObjectId.from_json(json["objectId"]) if "objectId" in json else None,
        )


class ExecutionContextId(int):
    """
    Id of an execution context.
    """
    def to_json(self) -> int:
        return self

    @classmethod
    def from_json(cls, json: int) -> ExecutionContextId:
        return cls(json)

    def __repr__(self):
        return f"ExecutionContextId({super().__repr__()})"


@dataclass
class ExecutionContextDescription:
    """
    Description of an isolated world.
    """
    #: Unique id of the execution context. It can be used to specify in which execution context
    #: script evaluation should be performed.
    id_: ExecutionContextId

    #: Execution context origin.
    origin: str

    #: Human readable name describing given context.
    name: str

    #: A system-unique execution context identifier. Unlike the id, this is unique across
    #: multiple processes, so can be reliably used to identify specific context while backend
    #: performs a cross-process navigation.
    unique_id: str

    #: Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'``'isolated'``'worker', frameId: string}
    aux_data: dict | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["id"] = self.id_.to_json()
        json["origin"] = self.origin
        json["name"] = self.name
        json["uniqueId"] = self.unique_id
        if self.aux_data is not None:
            json["auxData"] = self.aux_data
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ExecutionContextDescription:
        return cls(
            id_=ExecutionContextId.from_json(json["id"]),
            origin=str(json["origin"]),
            name=str(json["name"]),
            unique_id=str(json["uniqueId"]),
            aux_data=dict(json["auxData"]) if "auxData" in json else None,
        )


@dataclass
class ExceptionDetails:
    """
    Detailed information about exception (or error) that was thrown during script compilation or
    execution.
    """
    #: Exception id.
    exception_id: int

    #: Exception text, which should be used together with exception object when available.
    text: str

    #: Line number of the exception location (0-based).
    line_number: int

    #: Column number of the exception location (0-based).
    column_number: int

    #: Script ID of the exception location.
    script_id: ScriptId | None = None

    #: URL of the exception location, to be used when the script was not reported.
    url: str | None = None

    #: JavaScript stack trace if available.
    stack_trace: StackTrace | None = None

    #: Exception object if available.
    exception: RemoteObject | None = None

    #: Identifier of the context where exception happened.
    execution_context_id: ExecutionContextId | None = None

    #: Dictionary with entries of meta data that the client associated
    #: with this exception, such as information about associated network
    #: requests, etc.
    exception_meta_data: dict | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["exceptionId"] = self.exception_id
        json["text"] = self.text
        json["lineNumber"] = self.line_number
        json["columnNumber"] = self.column_number
        if self.script_id is not None:
            json["scriptId"] = self.script_id.to_json()
        if self.url is not None:
            json["url"] = self.url
        if self.stack_trace is not None:
            json["stackTrace"] = self.stack_trace.to_json()
        if self.exception is not None:
            json["exception"] = self.exception.to_json()
        if self.execution_context_id is not None:
            json["executionContextId"] = self.execution_context_id.to_json()
        if self.exception_meta_data is not None:
            json["exceptionMetaData"] = self.exception_meta_data
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ExceptionDetails:
        return cls(
            exception_id=int(json["exceptionId"]),
            text=str(json["text"]),
            line_number=int(json["lineNumber"]),
            column_number=int(json["columnNumber"]),
            script_id=ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
            url=str(json["url"]) if "url" in json else None,
            stack_trace=StackTrace.from_json(json["stackTrace"]) if "stackTrace" in json else None,
            exception=RemoteObject.from_json(json["exception"]) if "exception" in json else None,
            execution_context_id=ExecutionContextId.from_json(json["executionContextId"]) if "executionContextId" in json else None,
            exception_meta_data=dict(json["exceptionMetaData"]) if "exceptionMetaData" in json else None,
        )


class Timestamp(float):
    """
    Number of milliseconds since epoch.
    """
    def to_json(self) -> float:
        return self

    @classmethod
    def from_json(cls, json: float) -> Timestamp:
        return cls(json)

    def __repr__(self):
        return f"Timestamp({super().__repr__()})"


class TimeDelta(float):
    """
    Number of milliseconds.
    """
    def to_json(self) -> float:
        return self

    @classmethod
    def from_json(cls, json: float) -> TimeDelta:
        return cls(json)

    def __repr__(self):
        return f"TimeDelta({super().__repr__()})"


@dataclass
class CallFrame:
    """
    Stack entry for runtime errors and assertions.
    """
    #: JavaScript function name.
    function_name: str

    #: JavaScript script id.
    script_id: ScriptId

    #: JavaScript script name or url.
    url: str

    #: JavaScript script line number (0-based).
    line_number: int

    #: JavaScript script column number (0-based).
    column_number: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["functionName"] = self.function_name
        json["scriptId"] = self.script_id.to_json()
        json["url"] = self.url
        json["lineNumber"] = self.line_number
        json["columnNumber"] = self.column_number
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CallFrame:
        return cls(
            function_name=str(json["functionName"]),
            script_id=ScriptId.from_json(json["scriptId"]),
            url=str(json["url"]),
            line_number=int(json["lineNumber"]),
            column_number=int(json["columnNumber"]),
        )


@dataclass
class StackTrace:
    """
    Call frames for assertions or error messages.
    """
    #: JavaScript function name.
    call_frames: list[CallFrame]

    #: String label of this stack trace. For async traces this may be a name of the function that
    #: initiated the async call.
    description: str | None = None

    #: Asynchronous JavaScript stack trace that preceded this stack, if available.
    parent: StackTrace | None = None

    #: Asynchronous JavaScript stack trace that preceded this stack, if available.
    parent_id: StackTraceId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["callFrames"] = [i.to_json() for i in self.call_frames]
        if self.description is not None:
            json["description"] = self.description
        if self.parent is not None:
            json["parent"] = self.parent.to_json()
        if self.parent_id is not None:
            json["parentId"] = self.parent_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> StackTrace:
        return cls(
            call_frames=[CallFrame.from_json(i) for i in json["callFrames"]],
            description=str(json["description"]) if "description" in json else None,
            parent=StackTrace.from_json(json["parent"]) if "parent" in json else None,
            parent_id=StackTraceId.from_json(json["parentId"]) if "parentId" in json else None,
        )


class UniqueDebuggerId(str):
    """
    Unique identifier of current debugger.
    """
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> UniqueDebuggerId:
        return cls(json)

    def __repr__(self):
        return f"UniqueDebuggerId({super().__repr__()})"


@dataclass
class StackTraceId:
    """
    If ``debuggerId`` is set stack trace comes from another debugger and can be resolved there. This
    allows to track cross-debugger calls. See ``Runtime.StackTrace`` and ``Debugger.paused`` for usages.
    """
    id_: str

    debugger_id: UniqueDebuggerId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["id"] = self.id_
        if self.debugger_id is not None:
            json["debuggerId"] = self.debugger_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> StackTraceId:
        return cls(
            id_=str(json["id"]),
            debugger_id=UniqueDebuggerId.from_json(json["debuggerId"]) if "debuggerId" in json else None,
        )


def x_await_promise__mutmut_orig(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_1(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = None
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_2(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = None
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_3(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["XXpromiseObjectIdXX"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_4(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseobjectid"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_5(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["PROMISEOBJECTID"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_6(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["Promiseobjectid"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_7(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_8(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = None
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_9(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["XXreturnByValueXX"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_10(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnbyvalue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_11(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["RETURNBYVALUE"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_12(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["Returnbyvalue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_13(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_14(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_15(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["XXgeneratePreviewXX"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_16(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatepreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_17(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["GENERATEPREVIEW"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_18(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["Generatepreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_19(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_20(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_21(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_22(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_23(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.awaitPromiseXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_24(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.awaitpromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_25(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.AWAITPROMISE",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_26(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitpromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_27(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_28(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_29(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_30(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = None
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_31(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(None),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_32(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["XXresultXX"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_33(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["RESULT"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_34(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["Result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_35(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(None) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_36(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["XXexceptionDetailsXX"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_37(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_38(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["EXCEPTIONDETAILS"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_39(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["Exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_await_promise__mutmut_40(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "XXexceptionDetailsXX" in json else None,
    )


def x_await_promise__mutmut_41(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptiondetails" in json else None,
    )


def x_await_promise__mutmut_42(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "EXCEPTIONDETAILS" in json else None,
    )


def x_await_promise__mutmut_43(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "Exceptiondetails" in json else None,
    )


def x_await_promise__mutmut_44(
    promise_object_id: RemoteObjectId,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Add handler to promise with given promise object id.

    :param promise_object_id: Identifier of the promise.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :returns: A tuple with the following items:

        0. **result** - Promise result. Will contain rejected value if promise was rejected.
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available.
    """
    params: T_JSON_DICT = {}
    params["promiseObjectId"] = promise_object_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.awaitPromise",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" not in json else None,
    )

x_await_promise__mutmut_mutants : ClassVar[MutantDict] = {
'x_await_promise__mutmut_1': x_await_promise__mutmut_1, 
    'x_await_promise__mutmut_2': x_await_promise__mutmut_2, 
    'x_await_promise__mutmut_3': x_await_promise__mutmut_3, 
    'x_await_promise__mutmut_4': x_await_promise__mutmut_4, 
    'x_await_promise__mutmut_5': x_await_promise__mutmut_5, 
    'x_await_promise__mutmut_6': x_await_promise__mutmut_6, 
    'x_await_promise__mutmut_7': x_await_promise__mutmut_7, 
    'x_await_promise__mutmut_8': x_await_promise__mutmut_8, 
    'x_await_promise__mutmut_9': x_await_promise__mutmut_9, 
    'x_await_promise__mutmut_10': x_await_promise__mutmut_10, 
    'x_await_promise__mutmut_11': x_await_promise__mutmut_11, 
    'x_await_promise__mutmut_12': x_await_promise__mutmut_12, 
    'x_await_promise__mutmut_13': x_await_promise__mutmut_13, 
    'x_await_promise__mutmut_14': x_await_promise__mutmut_14, 
    'x_await_promise__mutmut_15': x_await_promise__mutmut_15, 
    'x_await_promise__mutmut_16': x_await_promise__mutmut_16, 
    'x_await_promise__mutmut_17': x_await_promise__mutmut_17, 
    'x_await_promise__mutmut_18': x_await_promise__mutmut_18, 
    'x_await_promise__mutmut_19': x_await_promise__mutmut_19, 
    'x_await_promise__mutmut_20': x_await_promise__mutmut_20, 
    'x_await_promise__mutmut_21': x_await_promise__mutmut_21, 
    'x_await_promise__mutmut_22': x_await_promise__mutmut_22, 
    'x_await_promise__mutmut_23': x_await_promise__mutmut_23, 
    'x_await_promise__mutmut_24': x_await_promise__mutmut_24, 
    'x_await_promise__mutmut_25': x_await_promise__mutmut_25, 
    'x_await_promise__mutmut_26': x_await_promise__mutmut_26, 
    'x_await_promise__mutmut_27': x_await_promise__mutmut_27, 
    'x_await_promise__mutmut_28': x_await_promise__mutmut_28, 
    'x_await_promise__mutmut_29': x_await_promise__mutmut_29, 
    'x_await_promise__mutmut_30': x_await_promise__mutmut_30, 
    'x_await_promise__mutmut_31': x_await_promise__mutmut_31, 
    'x_await_promise__mutmut_32': x_await_promise__mutmut_32, 
    'x_await_promise__mutmut_33': x_await_promise__mutmut_33, 
    'x_await_promise__mutmut_34': x_await_promise__mutmut_34, 
    'x_await_promise__mutmut_35': x_await_promise__mutmut_35, 
    'x_await_promise__mutmut_36': x_await_promise__mutmut_36, 
    'x_await_promise__mutmut_37': x_await_promise__mutmut_37, 
    'x_await_promise__mutmut_38': x_await_promise__mutmut_38, 
    'x_await_promise__mutmut_39': x_await_promise__mutmut_39, 
    'x_await_promise__mutmut_40': x_await_promise__mutmut_40, 
    'x_await_promise__mutmut_41': x_await_promise__mutmut_41, 
    'x_await_promise__mutmut_42': x_await_promise__mutmut_42, 
    'x_await_promise__mutmut_43': x_await_promise__mutmut_43, 
    'x_await_promise__mutmut_44': x_await_promise__mutmut_44
}

def await_promise(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_await_promise__mutmut_orig, x_await_promise__mutmut_mutants, args, kwargs)
    return result 

await_promise.__signature__ = _mutmut_signature(x_await_promise__mutmut_orig)
x_await_promise__mutmut_orig.__name__ = 'x_await_promise'


def x_call_function_on__mutmut_orig(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_1(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = None
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_2(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = None
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_3(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["XXfunctionDeclarationXX"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_4(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functiondeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_5(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["FUNCTIONDECLARATION"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_6(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["Functiondeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_7(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_8(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = None
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_9(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["XXobjectIdXX"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_10(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectid"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_11(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["OBJECTID"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_12(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["Objectid"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_13(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_14(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = None
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_15(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["XXargumentsXX"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_16(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["ARGUMENTS"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_17(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["Arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_18(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_19(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = None
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_20(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["XXsilentXX"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_21(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["SILENT"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_22(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["Silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_23(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_24(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = None
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_25(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["XXreturnByValueXX"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_26(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnbyvalue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_27(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["RETURNBYVALUE"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_28(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["Returnbyvalue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_29(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_30(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = None
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_31(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["XXgeneratePreviewXX"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_32(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatepreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_33(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["GENERATEPREVIEW"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_34(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["Generatepreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_35(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_36(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = None
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_37(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["XXuserGestureXX"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_38(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["usergesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_39(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["USERGESTURE"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_40(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["Usergesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_41(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_42(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = None
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_43(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["XXawaitPromiseXX"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_44(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitpromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_45(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["AWAITPROMISE"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_46(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["Awaitpromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_47(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_48(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = None
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_49(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["XXexecutionContextIdXX"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_50(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executioncontextid"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_51(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["EXECUTIONCONTEXTID"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_52(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["Executioncontextid"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_53(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_54(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = None
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_55(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["XXobjectGroupXX"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_56(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectgroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_57(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["OBJECTGROUP"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_58(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["Objectgroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_59(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_60(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = None
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_61(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["XXthrowOnSideEffectXX"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_62(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwonsideeffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_63(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["THROWONSIDEEFFECT"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_64(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["Throwonsideeffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_65(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_66(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = None
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_67(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["XXuniqueContextIdXX"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_68(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniquecontextid"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_69(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["UNIQUECONTEXTID"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_70(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["Uniquecontextid"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_71(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_72(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_73(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["XXserializationOptionsXX"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_74(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationoptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_75(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["SERIALIZATIONOPTIONS"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_76(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["Serializationoptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_77(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_78(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_79(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_80(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_81(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.callFunctionOnXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_82(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.callfunctionon",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_83(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.CALLFUNCTIONON",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_84(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callfunctionon",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_85(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_86(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_87(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_88(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = None
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_89(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(None),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_90(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["XXresultXX"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_91(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["RESULT"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_92(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["Result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_93(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(None) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_94(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["XXexceptionDetailsXX"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_95(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_96(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["EXCEPTIONDETAILS"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_97(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["Exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_call_function_on__mutmut_98(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "XXexceptionDetailsXX" in json else None,
    )


def x_call_function_on__mutmut_99(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptiondetails" in json else None,
    )


def x_call_function_on__mutmut_100(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "EXCEPTIONDETAILS" in json else None,
    )


def x_call_function_on__mutmut_101(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "Exceptiondetails" in json else None,
    )


def x_call_function_on__mutmut_102(
    function_declaration: str,
    object_id: RemoteObjectId | None = None,
    arguments: list[CallArgument] | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    throw_on_side_effect: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.

    :param function_declaration: Declaration of the function to call.
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified.
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by ````serializationOptions````.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````executionContextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Call result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["functionDeclaration"] = function_declaration
    if object_id is not None:
        params["objectId"] = object_id.to_json()
    if arguments is not None:
        params["arguments"] = [i.to_json() for i in arguments]
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.callFunctionOn",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" not in json else None,
    )

x_call_function_on__mutmut_mutants : ClassVar[MutantDict] = {
'x_call_function_on__mutmut_1': x_call_function_on__mutmut_1, 
    'x_call_function_on__mutmut_2': x_call_function_on__mutmut_2, 
    'x_call_function_on__mutmut_3': x_call_function_on__mutmut_3, 
    'x_call_function_on__mutmut_4': x_call_function_on__mutmut_4, 
    'x_call_function_on__mutmut_5': x_call_function_on__mutmut_5, 
    'x_call_function_on__mutmut_6': x_call_function_on__mutmut_6, 
    'x_call_function_on__mutmut_7': x_call_function_on__mutmut_7, 
    'x_call_function_on__mutmut_8': x_call_function_on__mutmut_8, 
    'x_call_function_on__mutmut_9': x_call_function_on__mutmut_9, 
    'x_call_function_on__mutmut_10': x_call_function_on__mutmut_10, 
    'x_call_function_on__mutmut_11': x_call_function_on__mutmut_11, 
    'x_call_function_on__mutmut_12': x_call_function_on__mutmut_12, 
    'x_call_function_on__mutmut_13': x_call_function_on__mutmut_13, 
    'x_call_function_on__mutmut_14': x_call_function_on__mutmut_14, 
    'x_call_function_on__mutmut_15': x_call_function_on__mutmut_15, 
    'x_call_function_on__mutmut_16': x_call_function_on__mutmut_16, 
    'x_call_function_on__mutmut_17': x_call_function_on__mutmut_17, 
    'x_call_function_on__mutmut_18': x_call_function_on__mutmut_18, 
    'x_call_function_on__mutmut_19': x_call_function_on__mutmut_19, 
    'x_call_function_on__mutmut_20': x_call_function_on__mutmut_20, 
    'x_call_function_on__mutmut_21': x_call_function_on__mutmut_21, 
    'x_call_function_on__mutmut_22': x_call_function_on__mutmut_22, 
    'x_call_function_on__mutmut_23': x_call_function_on__mutmut_23, 
    'x_call_function_on__mutmut_24': x_call_function_on__mutmut_24, 
    'x_call_function_on__mutmut_25': x_call_function_on__mutmut_25, 
    'x_call_function_on__mutmut_26': x_call_function_on__mutmut_26, 
    'x_call_function_on__mutmut_27': x_call_function_on__mutmut_27, 
    'x_call_function_on__mutmut_28': x_call_function_on__mutmut_28, 
    'x_call_function_on__mutmut_29': x_call_function_on__mutmut_29, 
    'x_call_function_on__mutmut_30': x_call_function_on__mutmut_30, 
    'x_call_function_on__mutmut_31': x_call_function_on__mutmut_31, 
    'x_call_function_on__mutmut_32': x_call_function_on__mutmut_32, 
    'x_call_function_on__mutmut_33': x_call_function_on__mutmut_33, 
    'x_call_function_on__mutmut_34': x_call_function_on__mutmut_34, 
    'x_call_function_on__mutmut_35': x_call_function_on__mutmut_35, 
    'x_call_function_on__mutmut_36': x_call_function_on__mutmut_36, 
    'x_call_function_on__mutmut_37': x_call_function_on__mutmut_37, 
    'x_call_function_on__mutmut_38': x_call_function_on__mutmut_38, 
    'x_call_function_on__mutmut_39': x_call_function_on__mutmut_39, 
    'x_call_function_on__mutmut_40': x_call_function_on__mutmut_40, 
    'x_call_function_on__mutmut_41': x_call_function_on__mutmut_41, 
    'x_call_function_on__mutmut_42': x_call_function_on__mutmut_42, 
    'x_call_function_on__mutmut_43': x_call_function_on__mutmut_43, 
    'x_call_function_on__mutmut_44': x_call_function_on__mutmut_44, 
    'x_call_function_on__mutmut_45': x_call_function_on__mutmut_45, 
    'x_call_function_on__mutmut_46': x_call_function_on__mutmut_46, 
    'x_call_function_on__mutmut_47': x_call_function_on__mutmut_47, 
    'x_call_function_on__mutmut_48': x_call_function_on__mutmut_48, 
    'x_call_function_on__mutmut_49': x_call_function_on__mutmut_49, 
    'x_call_function_on__mutmut_50': x_call_function_on__mutmut_50, 
    'x_call_function_on__mutmut_51': x_call_function_on__mutmut_51, 
    'x_call_function_on__mutmut_52': x_call_function_on__mutmut_52, 
    'x_call_function_on__mutmut_53': x_call_function_on__mutmut_53, 
    'x_call_function_on__mutmut_54': x_call_function_on__mutmut_54, 
    'x_call_function_on__mutmut_55': x_call_function_on__mutmut_55, 
    'x_call_function_on__mutmut_56': x_call_function_on__mutmut_56, 
    'x_call_function_on__mutmut_57': x_call_function_on__mutmut_57, 
    'x_call_function_on__mutmut_58': x_call_function_on__mutmut_58, 
    'x_call_function_on__mutmut_59': x_call_function_on__mutmut_59, 
    'x_call_function_on__mutmut_60': x_call_function_on__mutmut_60, 
    'x_call_function_on__mutmut_61': x_call_function_on__mutmut_61, 
    'x_call_function_on__mutmut_62': x_call_function_on__mutmut_62, 
    'x_call_function_on__mutmut_63': x_call_function_on__mutmut_63, 
    'x_call_function_on__mutmut_64': x_call_function_on__mutmut_64, 
    'x_call_function_on__mutmut_65': x_call_function_on__mutmut_65, 
    'x_call_function_on__mutmut_66': x_call_function_on__mutmut_66, 
    'x_call_function_on__mutmut_67': x_call_function_on__mutmut_67, 
    'x_call_function_on__mutmut_68': x_call_function_on__mutmut_68, 
    'x_call_function_on__mutmut_69': x_call_function_on__mutmut_69, 
    'x_call_function_on__mutmut_70': x_call_function_on__mutmut_70, 
    'x_call_function_on__mutmut_71': x_call_function_on__mutmut_71, 
    'x_call_function_on__mutmut_72': x_call_function_on__mutmut_72, 
    'x_call_function_on__mutmut_73': x_call_function_on__mutmut_73, 
    'x_call_function_on__mutmut_74': x_call_function_on__mutmut_74, 
    'x_call_function_on__mutmut_75': x_call_function_on__mutmut_75, 
    'x_call_function_on__mutmut_76': x_call_function_on__mutmut_76, 
    'x_call_function_on__mutmut_77': x_call_function_on__mutmut_77, 
    'x_call_function_on__mutmut_78': x_call_function_on__mutmut_78, 
    'x_call_function_on__mutmut_79': x_call_function_on__mutmut_79, 
    'x_call_function_on__mutmut_80': x_call_function_on__mutmut_80, 
    'x_call_function_on__mutmut_81': x_call_function_on__mutmut_81, 
    'x_call_function_on__mutmut_82': x_call_function_on__mutmut_82, 
    'x_call_function_on__mutmut_83': x_call_function_on__mutmut_83, 
    'x_call_function_on__mutmut_84': x_call_function_on__mutmut_84, 
    'x_call_function_on__mutmut_85': x_call_function_on__mutmut_85, 
    'x_call_function_on__mutmut_86': x_call_function_on__mutmut_86, 
    'x_call_function_on__mutmut_87': x_call_function_on__mutmut_87, 
    'x_call_function_on__mutmut_88': x_call_function_on__mutmut_88, 
    'x_call_function_on__mutmut_89': x_call_function_on__mutmut_89, 
    'x_call_function_on__mutmut_90': x_call_function_on__mutmut_90, 
    'x_call_function_on__mutmut_91': x_call_function_on__mutmut_91, 
    'x_call_function_on__mutmut_92': x_call_function_on__mutmut_92, 
    'x_call_function_on__mutmut_93': x_call_function_on__mutmut_93, 
    'x_call_function_on__mutmut_94': x_call_function_on__mutmut_94, 
    'x_call_function_on__mutmut_95': x_call_function_on__mutmut_95, 
    'x_call_function_on__mutmut_96': x_call_function_on__mutmut_96, 
    'x_call_function_on__mutmut_97': x_call_function_on__mutmut_97, 
    'x_call_function_on__mutmut_98': x_call_function_on__mutmut_98, 
    'x_call_function_on__mutmut_99': x_call_function_on__mutmut_99, 
    'x_call_function_on__mutmut_100': x_call_function_on__mutmut_100, 
    'x_call_function_on__mutmut_101': x_call_function_on__mutmut_101, 
    'x_call_function_on__mutmut_102': x_call_function_on__mutmut_102
}

def call_function_on(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_call_function_on__mutmut_orig, x_call_function_on__mutmut_mutants, args, kwargs)
    return result 

call_function_on.__signature__ = _mutmut_signature(x_call_function_on__mutmut_orig)
x_call_function_on__mutmut_orig.__name__ = 'x_call_function_on'


def x_compile_script__mutmut_orig(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_1(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = None
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_2(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = None
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_3(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["XXexpressionXX"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_4(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["EXPRESSION"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_5(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["Expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_6(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = None
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_7(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["XXsourceURLXX"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_8(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceurl"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_9(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["SOURCEURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_10(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["Sourceurl"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_11(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = None
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_12(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["XXpersistScriptXX"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_13(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistscript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_14(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["PERSISTSCRIPT"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_15(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["Persistscript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_16(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_17(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_18(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["XXexecutionContextIdXX"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_19(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executioncontextid"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_20(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["EXECUTIONCONTEXTID"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_21(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["Executioncontextid"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_22(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_23(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_24(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_25(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_26(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.compileScriptXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_27(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.compilescript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_28(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.COMPILESCRIPT",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_29(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compilescript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_30(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_31(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_32(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_33(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = None
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_34(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(None) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_35(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["XXscriptIdXX"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_36(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptid"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_37(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["SCRIPTID"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_38(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["Scriptid"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_39(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "XXscriptIdXX" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_40(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptid" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_41(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "SCRIPTID" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_42(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "Scriptid" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_43(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" not in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_44(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(None) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_45(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["XXexceptionDetailsXX"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_46(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_47(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["EXCEPTIONDETAILS"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_48(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["Exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_compile_script__mutmut_49(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "XXexceptionDetailsXX" in json else None,
    )


def x_compile_script__mutmut_50(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptiondetails" in json else None,
    )


def x_compile_script__mutmut_51(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "EXCEPTIONDETAILS" in json else None,
    )


def x_compile_script__mutmut_52(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "Exceptiondetails" in json else None,
    )


def x_compile_script__mutmut_53(
    expression: str,
    source_url: str,
    persist_script: bool,
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[ScriptId | None, ExceptionDetails | None]]:
    """
    Compiles expression.

    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :returns: A tuple with the following items:

        0. **scriptId** - *(Optional)* Id of the script.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    params["sourceURL"] = source_url
    params["persistScript"] = persist_script
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.compileScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        ScriptId.from_json(json["scriptId"]) if "scriptId" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" not in json else None,
    )

x_compile_script__mutmut_mutants : ClassVar[MutantDict] = {
'x_compile_script__mutmut_1': x_compile_script__mutmut_1, 
    'x_compile_script__mutmut_2': x_compile_script__mutmut_2, 
    'x_compile_script__mutmut_3': x_compile_script__mutmut_3, 
    'x_compile_script__mutmut_4': x_compile_script__mutmut_4, 
    'x_compile_script__mutmut_5': x_compile_script__mutmut_5, 
    'x_compile_script__mutmut_6': x_compile_script__mutmut_6, 
    'x_compile_script__mutmut_7': x_compile_script__mutmut_7, 
    'x_compile_script__mutmut_8': x_compile_script__mutmut_8, 
    'x_compile_script__mutmut_9': x_compile_script__mutmut_9, 
    'x_compile_script__mutmut_10': x_compile_script__mutmut_10, 
    'x_compile_script__mutmut_11': x_compile_script__mutmut_11, 
    'x_compile_script__mutmut_12': x_compile_script__mutmut_12, 
    'x_compile_script__mutmut_13': x_compile_script__mutmut_13, 
    'x_compile_script__mutmut_14': x_compile_script__mutmut_14, 
    'x_compile_script__mutmut_15': x_compile_script__mutmut_15, 
    'x_compile_script__mutmut_16': x_compile_script__mutmut_16, 
    'x_compile_script__mutmut_17': x_compile_script__mutmut_17, 
    'x_compile_script__mutmut_18': x_compile_script__mutmut_18, 
    'x_compile_script__mutmut_19': x_compile_script__mutmut_19, 
    'x_compile_script__mutmut_20': x_compile_script__mutmut_20, 
    'x_compile_script__mutmut_21': x_compile_script__mutmut_21, 
    'x_compile_script__mutmut_22': x_compile_script__mutmut_22, 
    'x_compile_script__mutmut_23': x_compile_script__mutmut_23, 
    'x_compile_script__mutmut_24': x_compile_script__mutmut_24, 
    'x_compile_script__mutmut_25': x_compile_script__mutmut_25, 
    'x_compile_script__mutmut_26': x_compile_script__mutmut_26, 
    'x_compile_script__mutmut_27': x_compile_script__mutmut_27, 
    'x_compile_script__mutmut_28': x_compile_script__mutmut_28, 
    'x_compile_script__mutmut_29': x_compile_script__mutmut_29, 
    'x_compile_script__mutmut_30': x_compile_script__mutmut_30, 
    'x_compile_script__mutmut_31': x_compile_script__mutmut_31, 
    'x_compile_script__mutmut_32': x_compile_script__mutmut_32, 
    'x_compile_script__mutmut_33': x_compile_script__mutmut_33, 
    'x_compile_script__mutmut_34': x_compile_script__mutmut_34, 
    'x_compile_script__mutmut_35': x_compile_script__mutmut_35, 
    'x_compile_script__mutmut_36': x_compile_script__mutmut_36, 
    'x_compile_script__mutmut_37': x_compile_script__mutmut_37, 
    'x_compile_script__mutmut_38': x_compile_script__mutmut_38, 
    'x_compile_script__mutmut_39': x_compile_script__mutmut_39, 
    'x_compile_script__mutmut_40': x_compile_script__mutmut_40, 
    'x_compile_script__mutmut_41': x_compile_script__mutmut_41, 
    'x_compile_script__mutmut_42': x_compile_script__mutmut_42, 
    'x_compile_script__mutmut_43': x_compile_script__mutmut_43, 
    'x_compile_script__mutmut_44': x_compile_script__mutmut_44, 
    'x_compile_script__mutmut_45': x_compile_script__mutmut_45, 
    'x_compile_script__mutmut_46': x_compile_script__mutmut_46, 
    'x_compile_script__mutmut_47': x_compile_script__mutmut_47, 
    'x_compile_script__mutmut_48': x_compile_script__mutmut_48, 
    'x_compile_script__mutmut_49': x_compile_script__mutmut_49, 
    'x_compile_script__mutmut_50': x_compile_script__mutmut_50, 
    'x_compile_script__mutmut_51': x_compile_script__mutmut_51, 
    'x_compile_script__mutmut_52': x_compile_script__mutmut_52, 
    'x_compile_script__mutmut_53': x_compile_script__mutmut_53
}

def compile_script(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_compile_script__mutmut_orig, x_compile_script__mutmut_mutants, args, kwargs)
    return result 

compile_script.__signature__ = _mutmut_signature(x_compile_script__mutmut_orig)
x_compile_script__mutmut_orig.__name__ = 'x_compile_script'


def x_disable__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables reporting of execution contexts creation.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.disable",
    }
    yield cmd_dict


def x_disable__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables reporting of execution contexts creation.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_disable__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables reporting of execution contexts creation.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.disable",
    }
    yield cmd_dict


def x_disable__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables reporting of execution contexts creation.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.disable",
    }
    yield cmd_dict


def x_disable__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables reporting of execution contexts creation.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.disable",
    }
    yield cmd_dict


def x_disable__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables reporting of execution contexts creation.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.disableXX",
    }
    yield cmd_dict


def x_disable__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables reporting of execution contexts creation.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.disable",
    }
    yield cmd_dict


def x_disable__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables reporting of execution contexts creation.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.DISABLE",
    }
    yield cmd_dict

x_disable__mutmut_mutants : ClassVar[MutantDict] = {
'x_disable__mutmut_1': x_disable__mutmut_1, 
    'x_disable__mutmut_2': x_disable__mutmut_2, 
    'x_disable__mutmut_3': x_disable__mutmut_3, 
    'x_disable__mutmut_4': x_disable__mutmut_4, 
    'x_disable__mutmut_5': x_disable__mutmut_5, 
    'x_disable__mutmut_6': x_disable__mutmut_6, 
    'x_disable__mutmut_7': x_disable__mutmut_7
}

def disable(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_disable__mutmut_orig, x_disable__mutmut_mutants, args, kwargs)
    return result 

disable.__signature__ = _mutmut_signature(x_disable__mutmut_orig)
x_disable__mutmut_orig.__name__ = 'x_disable'


def x_discard_console_entries__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards collected exceptions and console API calls.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.discardConsoleEntries",
    }
    yield cmd_dict


def x_discard_console_entries__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards collected exceptions and console API calls.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_discard_console_entries__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards collected exceptions and console API calls.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.discardConsoleEntries",
    }
    yield cmd_dict


def x_discard_console_entries__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards collected exceptions and console API calls.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.discardConsoleEntries",
    }
    yield cmd_dict


def x_discard_console_entries__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards collected exceptions and console API calls.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.discardConsoleEntries",
    }
    yield cmd_dict


def x_discard_console_entries__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards collected exceptions and console API calls.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.discardConsoleEntriesXX",
    }
    yield cmd_dict


def x_discard_console_entries__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards collected exceptions and console API calls.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.discardconsoleentries",
    }
    yield cmd_dict


def x_discard_console_entries__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards collected exceptions and console API calls.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.DISCARDCONSOLEENTRIES",
    }
    yield cmd_dict


def x_discard_console_entries__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Discards collected exceptions and console API calls.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.discardconsoleentries",
    }
    yield cmd_dict

x_discard_console_entries__mutmut_mutants : ClassVar[MutantDict] = {
'x_discard_console_entries__mutmut_1': x_discard_console_entries__mutmut_1, 
    'x_discard_console_entries__mutmut_2': x_discard_console_entries__mutmut_2, 
    'x_discard_console_entries__mutmut_3': x_discard_console_entries__mutmut_3, 
    'x_discard_console_entries__mutmut_4': x_discard_console_entries__mutmut_4, 
    'x_discard_console_entries__mutmut_5': x_discard_console_entries__mutmut_5, 
    'x_discard_console_entries__mutmut_6': x_discard_console_entries__mutmut_6, 
    'x_discard_console_entries__mutmut_7': x_discard_console_entries__mutmut_7, 
    'x_discard_console_entries__mutmut_8': x_discard_console_entries__mutmut_8
}

def discard_console_entries(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_discard_console_entries__mutmut_orig, x_discard_console_entries__mutmut_mutants, args, kwargs)
    return result 

discard_console_entries.__signature__ = _mutmut_signature(x_discard_console_entries__mutmut_orig)
x_discard_console_entries__mutmut_orig.__name__ = 'x_discard_console_entries'


def x_enable__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables reporting of execution contexts creation by means of ``executionContextCreated`` event.
    When the reporting gets enabled the event will be sent immediately for each existing execution
    context.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.enable",
    }
    yield cmd_dict


def x_enable__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables reporting of execution contexts creation by means of ``executionContextCreated`` event.
    When the reporting gets enabled the event will be sent immediately for each existing execution
    context.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_enable__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables reporting of execution contexts creation by means of ``executionContextCreated`` event.
    When the reporting gets enabled the event will be sent immediately for each existing execution
    context.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.enable",
    }
    yield cmd_dict


def x_enable__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables reporting of execution contexts creation by means of ``executionContextCreated`` event.
    When the reporting gets enabled the event will be sent immediately for each existing execution
    context.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.enable",
    }
    yield cmd_dict


def x_enable__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables reporting of execution contexts creation by means of ``executionContextCreated`` event.
    When the reporting gets enabled the event will be sent immediately for each existing execution
    context.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.enable",
    }
    yield cmd_dict


def x_enable__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables reporting of execution contexts creation by means of ``executionContextCreated`` event.
    When the reporting gets enabled the event will be sent immediately for each existing execution
    context.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.enableXX",
    }
    yield cmd_dict


def x_enable__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables reporting of execution contexts creation by means of ``executionContextCreated`` event.
    When the reporting gets enabled the event will be sent immediately for each existing execution
    context.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.enable",
    }
    yield cmd_dict


def x_enable__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables reporting of execution contexts creation by means of ``executionContextCreated`` event.
    When the reporting gets enabled the event will be sent immediately for each existing execution
    context.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.ENABLE",
    }
    yield cmd_dict

x_enable__mutmut_mutants : ClassVar[MutantDict] = {
'x_enable__mutmut_1': x_enable__mutmut_1, 
    'x_enable__mutmut_2': x_enable__mutmut_2, 
    'x_enable__mutmut_3': x_enable__mutmut_3, 
    'x_enable__mutmut_4': x_enable__mutmut_4, 
    'x_enable__mutmut_5': x_enable__mutmut_5, 
    'x_enable__mutmut_6': x_enable__mutmut_6, 
    'x_enable__mutmut_7': x_enable__mutmut_7
}

def enable(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_enable__mutmut_orig, x_enable__mutmut_mutants, args, kwargs)
    return result 

enable.__signature__ = _mutmut_signature(x_enable__mutmut_orig)
x_enable__mutmut_orig.__name__ = 'x_enable'


def x_evaluate__mutmut_orig(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_1(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = None
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_2(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = None
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_3(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["XXexpressionXX"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_4(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["EXPRESSION"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_5(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["Expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_6(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_7(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = None
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_8(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["XXobjectGroupXX"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_9(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectgroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_10(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["OBJECTGROUP"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_11(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["Objectgroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_12(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_13(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = None
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_14(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["XXincludeCommandLineAPIXX"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_15(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includecommandlineapi"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_16(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["INCLUDECOMMANDLINEAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_17(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["Includecommandlineapi"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_18(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_19(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = None
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_20(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["XXsilentXX"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_21(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["SILENT"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_22(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["Silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_23(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_24(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = None
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_25(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["XXcontextIdXX"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_26(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextid"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_27(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["CONTEXTID"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_28(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["Contextid"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_29(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_30(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = None
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_31(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["XXreturnByValueXX"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_32(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnbyvalue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_33(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["RETURNBYVALUE"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_34(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["Returnbyvalue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_35(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_36(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = None
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_37(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["XXgeneratePreviewXX"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_38(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatepreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_39(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["GENERATEPREVIEW"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_40(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["Generatepreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_41(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_42(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = None
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_43(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["XXuserGestureXX"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_44(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["usergesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_45(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["USERGESTURE"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_46(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["Usergesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_47(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_48(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = None
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_49(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["XXawaitPromiseXX"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_50(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitpromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_51(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["AWAITPROMISE"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_52(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["Awaitpromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_53(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_54(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = None
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_55(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["XXthrowOnSideEffectXX"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_56(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwonsideeffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_57(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["THROWONSIDEEFFECT"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_58(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["Throwonsideeffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_59(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_60(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = None
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_61(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["XXtimeoutXX"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_62(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["TIMEOUT"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_63(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["Timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_64(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_65(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = None
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_66(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["XXdisableBreaksXX"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_67(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disablebreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_68(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["DISABLEBREAKS"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_69(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["Disablebreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_70(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_71(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = None
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_72(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["XXreplModeXX"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_73(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replmode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_74(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["REPLMODE"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_75(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["Replmode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_76(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_77(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = None
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_78(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["XXallowUnsafeEvalBlockedByCSPXX"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_79(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowunsafeevalblockedbycsp"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_80(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["ALLOWUNSAFEEVALBLOCKEDBYCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_81(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["Allowunsafeevalblockedbycsp"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_82(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_83(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = None
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_84(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["XXuniqueContextIdXX"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_85(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniquecontextid"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_86(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["UNIQUECONTEXTID"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_87(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["Uniquecontextid"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_88(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_89(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_90(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["XXserializationOptionsXX"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_91(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationoptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_92(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["SERIALIZATIONOPTIONS"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_93(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["Serializationoptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_94(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_95(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_96(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_97(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_98(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.evaluateXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_99(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_100(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.EVALUATE",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_101(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_102(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_103(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_104(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = None
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_105(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(None),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_106(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["XXresultXX"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_107(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["RESULT"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_108(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["Result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_109(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(None) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_110(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["XXexceptionDetailsXX"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_111(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_112(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["EXCEPTIONDETAILS"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_113(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["Exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate__mutmut_114(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "XXexceptionDetailsXX" in json else None,
    )


def x_evaluate__mutmut_115(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptiondetails" in json else None,
    )


def x_evaluate__mutmut_116(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "EXCEPTIONDETAILS" in json else None,
    )


def x_evaluate__mutmut_117(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "Exceptiondetails" in json else None,
    )


def x_evaluate__mutmut_118(
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    context_id: ExecutionContextId | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    user_gesture: bool | None = None,
    await_promise: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: TimeDelta | None = None,
    disable_breaks: bool | None = None,
    repl_mode: bool | None = None,
    allow_unsafe_eval_blocked_by_csp: bool | None = None,
    unique_context_id: str | None = None,
    serialization_options: SerializationOptions | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Evaluates expression on global object.

    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI.
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved.
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution.
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves.
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with ````contextId````.
    :param serialization_options: **(EXPERIMENTAL)** *(Optional)* Specifies the result serialization. If provided, overrides ````generatePreview```` and ````returnByValue```.
    :returns: A tuple with the following items:

        0. **result** - Evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if context_id is not None:
        params["contextId"] = context_id.to_json()
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if user_gesture is not None:
        params["userGesture"] = user_gesture
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    if disable_breaks is not None:
        params["disableBreaks"] = disable_breaks
    if repl_mode is not None:
        params["replMode"] = repl_mode
    if allow_unsafe_eval_blocked_by_csp is not None:
        params["allowUnsafeEvalBlockedByCSP"] = allow_unsafe_eval_blocked_by_csp
    if unique_context_id is not None:
        params["uniqueContextId"] = unique_context_id
    if serialization_options is not None:
        params["serializationOptions"] = serialization_options.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.evaluate",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" not in json else None,
    )

x_evaluate__mutmut_mutants : ClassVar[MutantDict] = {
'x_evaluate__mutmut_1': x_evaluate__mutmut_1, 
    'x_evaluate__mutmut_2': x_evaluate__mutmut_2, 
    'x_evaluate__mutmut_3': x_evaluate__mutmut_3, 
    'x_evaluate__mutmut_4': x_evaluate__mutmut_4, 
    'x_evaluate__mutmut_5': x_evaluate__mutmut_5, 
    'x_evaluate__mutmut_6': x_evaluate__mutmut_6, 
    'x_evaluate__mutmut_7': x_evaluate__mutmut_7, 
    'x_evaluate__mutmut_8': x_evaluate__mutmut_8, 
    'x_evaluate__mutmut_9': x_evaluate__mutmut_9, 
    'x_evaluate__mutmut_10': x_evaluate__mutmut_10, 
    'x_evaluate__mutmut_11': x_evaluate__mutmut_11, 
    'x_evaluate__mutmut_12': x_evaluate__mutmut_12, 
    'x_evaluate__mutmut_13': x_evaluate__mutmut_13, 
    'x_evaluate__mutmut_14': x_evaluate__mutmut_14, 
    'x_evaluate__mutmut_15': x_evaluate__mutmut_15, 
    'x_evaluate__mutmut_16': x_evaluate__mutmut_16, 
    'x_evaluate__mutmut_17': x_evaluate__mutmut_17, 
    'x_evaluate__mutmut_18': x_evaluate__mutmut_18, 
    'x_evaluate__mutmut_19': x_evaluate__mutmut_19, 
    'x_evaluate__mutmut_20': x_evaluate__mutmut_20, 
    'x_evaluate__mutmut_21': x_evaluate__mutmut_21, 
    'x_evaluate__mutmut_22': x_evaluate__mutmut_22, 
    'x_evaluate__mutmut_23': x_evaluate__mutmut_23, 
    'x_evaluate__mutmut_24': x_evaluate__mutmut_24, 
    'x_evaluate__mutmut_25': x_evaluate__mutmut_25, 
    'x_evaluate__mutmut_26': x_evaluate__mutmut_26, 
    'x_evaluate__mutmut_27': x_evaluate__mutmut_27, 
    'x_evaluate__mutmut_28': x_evaluate__mutmut_28, 
    'x_evaluate__mutmut_29': x_evaluate__mutmut_29, 
    'x_evaluate__mutmut_30': x_evaluate__mutmut_30, 
    'x_evaluate__mutmut_31': x_evaluate__mutmut_31, 
    'x_evaluate__mutmut_32': x_evaluate__mutmut_32, 
    'x_evaluate__mutmut_33': x_evaluate__mutmut_33, 
    'x_evaluate__mutmut_34': x_evaluate__mutmut_34, 
    'x_evaluate__mutmut_35': x_evaluate__mutmut_35, 
    'x_evaluate__mutmut_36': x_evaluate__mutmut_36, 
    'x_evaluate__mutmut_37': x_evaluate__mutmut_37, 
    'x_evaluate__mutmut_38': x_evaluate__mutmut_38, 
    'x_evaluate__mutmut_39': x_evaluate__mutmut_39, 
    'x_evaluate__mutmut_40': x_evaluate__mutmut_40, 
    'x_evaluate__mutmut_41': x_evaluate__mutmut_41, 
    'x_evaluate__mutmut_42': x_evaluate__mutmut_42, 
    'x_evaluate__mutmut_43': x_evaluate__mutmut_43, 
    'x_evaluate__mutmut_44': x_evaluate__mutmut_44, 
    'x_evaluate__mutmut_45': x_evaluate__mutmut_45, 
    'x_evaluate__mutmut_46': x_evaluate__mutmut_46, 
    'x_evaluate__mutmut_47': x_evaluate__mutmut_47, 
    'x_evaluate__mutmut_48': x_evaluate__mutmut_48, 
    'x_evaluate__mutmut_49': x_evaluate__mutmut_49, 
    'x_evaluate__mutmut_50': x_evaluate__mutmut_50, 
    'x_evaluate__mutmut_51': x_evaluate__mutmut_51, 
    'x_evaluate__mutmut_52': x_evaluate__mutmut_52, 
    'x_evaluate__mutmut_53': x_evaluate__mutmut_53, 
    'x_evaluate__mutmut_54': x_evaluate__mutmut_54, 
    'x_evaluate__mutmut_55': x_evaluate__mutmut_55, 
    'x_evaluate__mutmut_56': x_evaluate__mutmut_56, 
    'x_evaluate__mutmut_57': x_evaluate__mutmut_57, 
    'x_evaluate__mutmut_58': x_evaluate__mutmut_58, 
    'x_evaluate__mutmut_59': x_evaluate__mutmut_59, 
    'x_evaluate__mutmut_60': x_evaluate__mutmut_60, 
    'x_evaluate__mutmut_61': x_evaluate__mutmut_61, 
    'x_evaluate__mutmut_62': x_evaluate__mutmut_62, 
    'x_evaluate__mutmut_63': x_evaluate__mutmut_63, 
    'x_evaluate__mutmut_64': x_evaluate__mutmut_64, 
    'x_evaluate__mutmut_65': x_evaluate__mutmut_65, 
    'x_evaluate__mutmut_66': x_evaluate__mutmut_66, 
    'x_evaluate__mutmut_67': x_evaluate__mutmut_67, 
    'x_evaluate__mutmut_68': x_evaluate__mutmut_68, 
    'x_evaluate__mutmut_69': x_evaluate__mutmut_69, 
    'x_evaluate__mutmut_70': x_evaluate__mutmut_70, 
    'x_evaluate__mutmut_71': x_evaluate__mutmut_71, 
    'x_evaluate__mutmut_72': x_evaluate__mutmut_72, 
    'x_evaluate__mutmut_73': x_evaluate__mutmut_73, 
    'x_evaluate__mutmut_74': x_evaluate__mutmut_74, 
    'x_evaluate__mutmut_75': x_evaluate__mutmut_75, 
    'x_evaluate__mutmut_76': x_evaluate__mutmut_76, 
    'x_evaluate__mutmut_77': x_evaluate__mutmut_77, 
    'x_evaluate__mutmut_78': x_evaluate__mutmut_78, 
    'x_evaluate__mutmut_79': x_evaluate__mutmut_79, 
    'x_evaluate__mutmut_80': x_evaluate__mutmut_80, 
    'x_evaluate__mutmut_81': x_evaluate__mutmut_81, 
    'x_evaluate__mutmut_82': x_evaluate__mutmut_82, 
    'x_evaluate__mutmut_83': x_evaluate__mutmut_83, 
    'x_evaluate__mutmut_84': x_evaluate__mutmut_84, 
    'x_evaluate__mutmut_85': x_evaluate__mutmut_85, 
    'x_evaluate__mutmut_86': x_evaluate__mutmut_86, 
    'x_evaluate__mutmut_87': x_evaluate__mutmut_87, 
    'x_evaluate__mutmut_88': x_evaluate__mutmut_88, 
    'x_evaluate__mutmut_89': x_evaluate__mutmut_89, 
    'x_evaluate__mutmut_90': x_evaluate__mutmut_90, 
    'x_evaluate__mutmut_91': x_evaluate__mutmut_91, 
    'x_evaluate__mutmut_92': x_evaluate__mutmut_92, 
    'x_evaluate__mutmut_93': x_evaluate__mutmut_93, 
    'x_evaluate__mutmut_94': x_evaluate__mutmut_94, 
    'x_evaluate__mutmut_95': x_evaluate__mutmut_95, 
    'x_evaluate__mutmut_96': x_evaluate__mutmut_96, 
    'x_evaluate__mutmut_97': x_evaluate__mutmut_97, 
    'x_evaluate__mutmut_98': x_evaluate__mutmut_98, 
    'x_evaluate__mutmut_99': x_evaluate__mutmut_99, 
    'x_evaluate__mutmut_100': x_evaluate__mutmut_100, 
    'x_evaluate__mutmut_101': x_evaluate__mutmut_101, 
    'x_evaluate__mutmut_102': x_evaluate__mutmut_102, 
    'x_evaluate__mutmut_103': x_evaluate__mutmut_103, 
    'x_evaluate__mutmut_104': x_evaluate__mutmut_104, 
    'x_evaluate__mutmut_105': x_evaluate__mutmut_105, 
    'x_evaluate__mutmut_106': x_evaluate__mutmut_106, 
    'x_evaluate__mutmut_107': x_evaluate__mutmut_107, 
    'x_evaluate__mutmut_108': x_evaluate__mutmut_108, 
    'x_evaluate__mutmut_109': x_evaluate__mutmut_109, 
    'x_evaluate__mutmut_110': x_evaluate__mutmut_110, 
    'x_evaluate__mutmut_111': x_evaluate__mutmut_111, 
    'x_evaluate__mutmut_112': x_evaluate__mutmut_112, 
    'x_evaluate__mutmut_113': x_evaluate__mutmut_113, 
    'x_evaluate__mutmut_114': x_evaluate__mutmut_114, 
    'x_evaluate__mutmut_115': x_evaluate__mutmut_115, 
    'x_evaluate__mutmut_116': x_evaluate__mutmut_116, 
    'x_evaluate__mutmut_117': x_evaluate__mutmut_117, 
    'x_evaluate__mutmut_118': x_evaluate__mutmut_118
}

def evaluate(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_evaluate__mutmut_orig, x_evaluate__mutmut_mutants, args, kwargs)
    return result 

evaluate.__signature__ = _mutmut_signature(x_evaluate__mutmut_orig)
x_evaluate__mutmut_orig.__name__ = 'x_evaluate'


def x_get_isolate_id__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getIsolateId",
    }
    json = yield cmd_dict
    return str(json["id"])


def x_get_isolate_id__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return str(json["id"])


def x_get_isolate_id__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.getIsolateId",
    }
    json = yield cmd_dict
    return str(json["id"])


def x_get_isolate_id__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.getIsolateId",
    }
    json = yield cmd_dict
    return str(json["id"])


def x_get_isolate_id__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.getIsolateId",
    }
    json = yield cmd_dict
    return str(json["id"])


def x_get_isolate_id__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.getIsolateIdXX",
    }
    json = yield cmd_dict
    return str(json["id"])


def x_get_isolate_id__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.getisolateid",
    }
    json = yield cmd_dict
    return str(json["id"])


def x_get_isolate_id__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.GETISOLATEID",
    }
    json = yield cmd_dict
    return str(json["id"])


def x_get_isolate_id__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getisolateid",
    }
    json = yield cmd_dict
    return str(json["id"])


def x_get_isolate_id__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getIsolateId",
    }
    json = None
    return str(json["id"])


def x_get_isolate_id__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getIsolateId",
    }
    json = yield cmd_dict
    return str(None)


def x_get_isolate_id__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getIsolateId",
    }
    json = yield cmd_dict
    return str(json["XXidXX"])


def x_get_isolate_id__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getIsolateId",
    }
    json = yield cmd_dict
    return str(json["ID"])


def x_get_isolate_id__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the isolate id.

    **EXPERIMENTAL**

    :returns: The isolate id.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getIsolateId",
    }
    json = yield cmd_dict
    return str(json["Id"])

x_get_isolate_id__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_isolate_id__mutmut_1': x_get_isolate_id__mutmut_1, 
    'x_get_isolate_id__mutmut_2': x_get_isolate_id__mutmut_2, 
    'x_get_isolate_id__mutmut_3': x_get_isolate_id__mutmut_3, 
    'x_get_isolate_id__mutmut_4': x_get_isolate_id__mutmut_4, 
    'x_get_isolate_id__mutmut_5': x_get_isolate_id__mutmut_5, 
    'x_get_isolate_id__mutmut_6': x_get_isolate_id__mutmut_6, 
    'x_get_isolate_id__mutmut_7': x_get_isolate_id__mutmut_7, 
    'x_get_isolate_id__mutmut_8': x_get_isolate_id__mutmut_8, 
    'x_get_isolate_id__mutmut_9': x_get_isolate_id__mutmut_9, 
    'x_get_isolate_id__mutmut_10': x_get_isolate_id__mutmut_10, 
    'x_get_isolate_id__mutmut_11': x_get_isolate_id__mutmut_11, 
    'x_get_isolate_id__mutmut_12': x_get_isolate_id__mutmut_12, 
    'x_get_isolate_id__mutmut_13': x_get_isolate_id__mutmut_13
}

def get_isolate_id(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_isolate_id__mutmut_orig, x_get_isolate_id__mutmut_mutants, args, kwargs)
    return result 

get_isolate_id.__signature__ = _mutmut_signature(x_get_isolate_id__mutmut_orig)
x_get_isolate_id__mutmut_orig.__name__ = 'x_get_isolate_id'


def x_get_heap_usage__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.getHeapUsageXX",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.getheapusage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.GETHEAPUSAGE",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getheapusage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_9() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = None
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_10() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(None),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_11() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["XXusedSizeXX"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_12() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedsize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_13() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["USEDSIZE"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_14() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["Usedsize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_15() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(None),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_16() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["XXtotalSizeXX"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_17() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalsize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_18() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["TOTALSIZE"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_19() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["Totalsize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_20() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(None),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_21() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["XXembedderHeapUsedSizeXX"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_22() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderheapusedsize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_23() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["EMBEDDERHEAPUSEDSIZE"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_24() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["Embedderheapusedsize"]),
        float(json["backingStorageSize"]),
    )


def x_get_heap_usage__mutmut_25() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(None),
    )


def x_get_heap_usage__mutmut_26() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["XXbackingStorageSizeXX"]),
    )


def x_get_heap_usage__mutmut_27() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["backingstoragesize"]),
    )


def x_get_heap_usage__mutmut_28() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["BACKINGSTORAGESIZE"]),
    )


def x_get_heap_usage__mutmut_29() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float, float, float]]:
    """
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.

    **EXPERIMENTAL**

    :returns: A tuple with the following items:

        0. **usedSize** - Used JavaScript heap size in bytes.
        1. **totalSize** - Allocated JavaScript heap size in bytes.
        2. **embedderHeapUsedSize** - Used size in bytes in the embedder's garbage-collected heap.
        3. **backingStorageSize** - Size in bytes of backing storage for array buffers and external strings.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getHeapUsage",
    }
    json = yield cmd_dict
    return (
        float(json["usedSize"]),
        float(json["totalSize"]),
        float(json["embedderHeapUsedSize"]),
        float(json["Backingstoragesize"]),
    )

x_get_heap_usage__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_heap_usage__mutmut_1': x_get_heap_usage__mutmut_1, 
    'x_get_heap_usage__mutmut_2': x_get_heap_usage__mutmut_2, 
    'x_get_heap_usage__mutmut_3': x_get_heap_usage__mutmut_3, 
    'x_get_heap_usage__mutmut_4': x_get_heap_usage__mutmut_4, 
    'x_get_heap_usage__mutmut_5': x_get_heap_usage__mutmut_5, 
    'x_get_heap_usage__mutmut_6': x_get_heap_usage__mutmut_6, 
    'x_get_heap_usage__mutmut_7': x_get_heap_usage__mutmut_7, 
    'x_get_heap_usage__mutmut_8': x_get_heap_usage__mutmut_8, 
    'x_get_heap_usage__mutmut_9': x_get_heap_usage__mutmut_9, 
    'x_get_heap_usage__mutmut_10': x_get_heap_usage__mutmut_10, 
    'x_get_heap_usage__mutmut_11': x_get_heap_usage__mutmut_11, 
    'x_get_heap_usage__mutmut_12': x_get_heap_usage__mutmut_12, 
    'x_get_heap_usage__mutmut_13': x_get_heap_usage__mutmut_13, 
    'x_get_heap_usage__mutmut_14': x_get_heap_usage__mutmut_14, 
    'x_get_heap_usage__mutmut_15': x_get_heap_usage__mutmut_15, 
    'x_get_heap_usage__mutmut_16': x_get_heap_usage__mutmut_16, 
    'x_get_heap_usage__mutmut_17': x_get_heap_usage__mutmut_17, 
    'x_get_heap_usage__mutmut_18': x_get_heap_usage__mutmut_18, 
    'x_get_heap_usage__mutmut_19': x_get_heap_usage__mutmut_19, 
    'x_get_heap_usage__mutmut_20': x_get_heap_usage__mutmut_20, 
    'x_get_heap_usage__mutmut_21': x_get_heap_usage__mutmut_21, 
    'x_get_heap_usage__mutmut_22': x_get_heap_usage__mutmut_22, 
    'x_get_heap_usage__mutmut_23': x_get_heap_usage__mutmut_23, 
    'x_get_heap_usage__mutmut_24': x_get_heap_usage__mutmut_24, 
    'x_get_heap_usage__mutmut_25': x_get_heap_usage__mutmut_25, 
    'x_get_heap_usage__mutmut_26': x_get_heap_usage__mutmut_26, 
    'x_get_heap_usage__mutmut_27': x_get_heap_usage__mutmut_27, 
    'x_get_heap_usage__mutmut_28': x_get_heap_usage__mutmut_28, 
    'x_get_heap_usage__mutmut_29': x_get_heap_usage__mutmut_29
}

def get_heap_usage(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_heap_usage__mutmut_orig, x_get_heap_usage__mutmut_mutants, args, kwargs)
    return result 

get_heap_usage.__signature__ = _mutmut_signature(x_get_heap_usage__mutmut_orig)
x_get_heap_usage__mutmut_orig.__name__ = 'x_get_heap_usage'


def x_get_properties__mutmut_orig(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_1(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = None
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_2(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = None
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_3(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["XXobjectIdXX"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_4(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectid"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_5(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["OBJECTID"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_6(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["Objectid"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_7(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_8(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = None
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_9(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["XXownPropertiesXX"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_10(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownproperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_11(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["OWNPROPERTIES"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_12(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["Ownproperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_13(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_14(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = None
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_15(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["XXaccessorPropertiesOnlyXX"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_16(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorpropertiesonly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_17(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["ACCESSORPROPERTIESONLY"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_18(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["Accessorpropertiesonly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_19(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_20(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = None
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_21(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["XXgeneratePreviewXX"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_22(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatepreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_23(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["GENERATEPREVIEW"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_24(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["Generatepreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_25(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_26(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_27(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["XXnonIndexedPropertiesOnlyXX"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_28(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonindexedpropertiesonly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_29(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["NONINDEXEDPROPERTIESONLY"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_30(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["Nonindexedpropertiesonly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_31(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_32(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_33(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_34(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_35(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.getPropertiesXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_36(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.getproperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_37(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.GETPROPERTIES",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_38(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getproperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_39(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_40(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_41(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_42(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = None
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_43(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(None) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_44(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["XXresultXX"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_45(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["RESULT"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_46(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["Result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_47(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(None) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_48(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["XXinternalPropertiesXX"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_49(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalproperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_50(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["INTERNALPROPERTIES"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_51(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["Internalproperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_52(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "XXinternalPropertiesXX" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_53(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalproperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_54(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "INTERNALPROPERTIES" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_55(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "Internalproperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_56(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" not in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_57(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(None) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_58(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["XXprivatePropertiesXX"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_59(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateproperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_60(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["PRIVATEPROPERTIES"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_61(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["Privateproperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_62(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "XXprivatePropertiesXX" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_63(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateproperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_64(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "PRIVATEPROPERTIES" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_65(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "Privateproperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_66(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" not in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_67(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(None) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_68(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["XXexceptionDetailsXX"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_69(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_70(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["EXCEPTIONDETAILS"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_71(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["Exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_get_properties__mutmut_72(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "XXexceptionDetailsXX" in json else None,
    )


def x_get_properties__mutmut_73(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptiondetails" in json else None,
    )


def x_get_properties__mutmut_74(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "EXCEPTIONDETAILS" in json else None,
    )


def x_get_properties__mutmut_75(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "Exceptiondetails" in json else None,
    )


def x_get_properties__mutmut_76(
    object_id: RemoteObjectId,
    own_properties: bool | None = None,
    accessor_properties_only: bool | None = None,
    generate_preview: bool | None = None,
    non_indexed_properties_only: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[PropertyDescriptor], list[InternalPropertyDescriptor] | None, list[PrivatePropertyDescriptor] | None, ExceptionDetails | None]]:
    """
    Returns properties of a given object. Object group of the result is inherited from the target
    object.

    :param object_id: Identifier of the object to return properties for.
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain.
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results.
    :param non_indexed_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns non-indexed properties only.
    :returns: A tuple with the following items:

        0. **result** - Object properties.
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself).
        2. **privateProperties** - *(Optional)* Object private properties.
        3. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if own_properties is not None:
        params["ownProperties"] = own_properties
    if accessor_properties_only is not None:
        params["accessorPropertiesOnly"] = accessor_properties_only
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if non_indexed_properties_only is not None:
        params["nonIndexedPropertiesOnly"] = non_indexed_properties_only
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getProperties",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [PropertyDescriptor.from_json(i) for i in json["result"]],
        [InternalPropertyDescriptor.from_json(i) for i in json["internalProperties"]] if "internalProperties" in json else None,
        [PrivatePropertyDescriptor.from_json(i) for i in json["privateProperties"]] if "privateProperties" in json else None,
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" not in json else None,
    )

x_get_properties__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_properties__mutmut_1': x_get_properties__mutmut_1, 
    'x_get_properties__mutmut_2': x_get_properties__mutmut_2, 
    'x_get_properties__mutmut_3': x_get_properties__mutmut_3, 
    'x_get_properties__mutmut_4': x_get_properties__mutmut_4, 
    'x_get_properties__mutmut_5': x_get_properties__mutmut_5, 
    'x_get_properties__mutmut_6': x_get_properties__mutmut_6, 
    'x_get_properties__mutmut_7': x_get_properties__mutmut_7, 
    'x_get_properties__mutmut_8': x_get_properties__mutmut_8, 
    'x_get_properties__mutmut_9': x_get_properties__mutmut_9, 
    'x_get_properties__mutmut_10': x_get_properties__mutmut_10, 
    'x_get_properties__mutmut_11': x_get_properties__mutmut_11, 
    'x_get_properties__mutmut_12': x_get_properties__mutmut_12, 
    'x_get_properties__mutmut_13': x_get_properties__mutmut_13, 
    'x_get_properties__mutmut_14': x_get_properties__mutmut_14, 
    'x_get_properties__mutmut_15': x_get_properties__mutmut_15, 
    'x_get_properties__mutmut_16': x_get_properties__mutmut_16, 
    'x_get_properties__mutmut_17': x_get_properties__mutmut_17, 
    'x_get_properties__mutmut_18': x_get_properties__mutmut_18, 
    'x_get_properties__mutmut_19': x_get_properties__mutmut_19, 
    'x_get_properties__mutmut_20': x_get_properties__mutmut_20, 
    'x_get_properties__mutmut_21': x_get_properties__mutmut_21, 
    'x_get_properties__mutmut_22': x_get_properties__mutmut_22, 
    'x_get_properties__mutmut_23': x_get_properties__mutmut_23, 
    'x_get_properties__mutmut_24': x_get_properties__mutmut_24, 
    'x_get_properties__mutmut_25': x_get_properties__mutmut_25, 
    'x_get_properties__mutmut_26': x_get_properties__mutmut_26, 
    'x_get_properties__mutmut_27': x_get_properties__mutmut_27, 
    'x_get_properties__mutmut_28': x_get_properties__mutmut_28, 
    'x_get_properties__mutmut_29': x_get_properties__mutmut_29, 
    'x_get_properties__mutmut_30': x_get_properties__mutmut_30, 
    'x_get_properties__mutmut_31': x_get_properties__mutmut_31, 
    'x_get_properties__mutmut_32': x_get_properties__mutmut_32, 
    'x_get_properties__mutmut_33': x_get_properties__mutmut_33, 
    'x_get_properties__mutmut_34': x_get_properties__mutmut_34, 
    'x_get_properties__mutmut_35': x_get_properties__mutmut_35, 
    'x_get_properties__mutmut_36': x_get_properties__mutmut_36, 
    'x_get_properties__mutmut_37': x_get_properties__mutmut_37, 
    'x_get_properties__mutmut_38': x_get_properties__mutmut_38, 
    'x_get_properties__mutmut_39': x_get_properties__mutmut_39, 
    'x_get_properties__mutmut_40': x_get_properties__mutmut_40, 
    'x_get_properties__mutmut_41': x_get_properties__mutmut_41, 
    'x_get_properties__mutmut_42': x_get_properties__mutmut_42, 
    'x_get_properties__mutmut_43': x_get_properties__mutmut_43, 
    'x_get_properties__mutmut_44': x_get_properties__mutmut_44, 
    'x_get_properties__mutmut_45': x_get_properties__mutmut_45, 
    'x_get_properties__mutmut_46': x_get_properties__mutmut_46, 
    'x_get_properties__mutmut_47': x_get_properties__mutmut_47, 
    'x_get_properties__mutmut_48': x_get_properties__mutmut_48, 
    'x_get_properties__mutmut_49': x_get_properties__mutmut_49, 
    'x_get_properties__mutmut_50': x_get_properties__mutmut_50, 
    'x_get_properties__mutmut_51': x_get_properties__mutmut_51, 
    'x_get_properties__mutmut_52': x_get_properties__mutmut_52, 
    'x_get_properties__mutmut_53': x_get_properties__mutmut_53, 
    'x_get_properties__mutmut_54': x_get_properties__mutmut_54, 
    'x_get_properties__mutmut_55': x_get_properties__mutmut_55, 
    'x_get_properties__mutmut_56': x_get_properties__mutmut_56, 
    'x_get_properties__mutmut_57': x_get_properties__mutmut_57, 
    'x_get_properties__mutmut_58': x_get_properties__mutmut_58, 
    'x_get_properties__mutmut_59': x_get_properties__mutmut_59, 
    'x_get_properties__mutmut_60': x_get_properties__mutmut_60, 
    'x_get_properties__mutmut_61': x_get_properties__mutmut_61, 
    'x_get_properties__mutmut_62': x_get_properties__mutmut_62, 
    'x_get_properties__mutmut_63': x_get_properties__mutmut_63, 
    'x_get_properties__mutmut_64': x_get_properties__mutmut_64, 
    'x_get_properties__mutmut_65': x_get_properties__mutmut_65, 
    'x_get_properties__mutmut_66': x_get_properties__mutmut_66, 
    'x_get_properties__mutmut_67': x_get_properties__mutmut_67, 
    'x_get_properties__mutmut_68': x_get_properties__mutmut_68, 
    'x_get_properties__mutmut_69': x_get_properties__mutmut_69, 
    'x_get_properties__mutmut_70': x_get_properties__mutmut_70, 
    'x_get_properties__mutmut_71': x_get_properties__mutmut_71, 
    'x_get_properties__mutmut_72': x_get_properties__mutmut_72, 
    'x_get_properties__mutmut_73': x_get_properties__mutmut_73, 
    'x_get_properties__mutmut_74': x_get_properties__mutmut_74, 
    'x_get_properties__mutmut_75': x_get_properties__mutmut_75, 
    'x_get_properties__mutmut_76': x_get_properties__mutmut_76
}

def get_properties(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_properties__mutmut_orig, x_get_properties__mutmut_mutants, args, kwargs)
    return result 

get_properties.__signature__ = _mutmut_signature(x_get_properties__mutmut_orig)
x_get_properties__mutmut_orig.__name__ = 'x_get_properties'


def x_global_lexical_scope_names__mutmut_orig(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_1(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = None
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_2(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_3(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_4(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["XXexecutionContextIdXX"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_5(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executioncontextid"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_6(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["EXECUTIONCONTEXTID"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_7(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["Executioncontextid"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_8(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_9(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_10(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_11(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_12(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.globalLexicalScopeNamesXX",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_13(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.globallexicalscopenames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_14(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.GLOBALLEXICALSCOPENAMES",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_15(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globallexicalscopenames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_16(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_17(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_18(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "Params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_19(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = None
    return [str(i) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_20(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(None) for i in json["names"]]


def x_global_lexical_scope_names__mutmut_21(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["XXnamesXX"]]


def x_global_lexical_scope_names__mutmut_22(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["NAMES"]]


def x_global_lexical_scope_names__mutmut_23(
    execution_context_id: ExecutionContextId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all let, const and class variables from global scope.

    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables.
    :returns:
    """
    params: T_JSON_DICT = {}
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.globalLexicalScopeNames",
        "params": params,
    }
    json = yield cmd_dict
    return [str(i) for i in json["Names"]]

x_global_lexical_scope_names__mutmut_mutants : ClassVar[MutantDict] = {
'x_global_lexical_scope_names__mutmut_1': x_global_lexical_scope_names__mutmut_1, 
    'x_global_lexical_scope_names__mutmut_2': x_global_lexical_scope_names__mutmut_2, 
    'x_global_lexical_scope_names__mutmut_3': x_global_lexical_scope_names__mutmut_3, 
    'x_global_lexical_scope_names__mutmut_4': x_global_lexical_scope_names__mutmut_4, 
    'x_global_lexical_scope_names__mutmut_5': x_global_lexical_scope_names__mutmut_5, 
    'x_global_lexical_scope_names__mutmut_6': x_global_lexical_scope_names__mutmut_6, 
    'x_global_lexical_scope_names__mutmut_7': x_global_lexical_scope_names__mutmut_7, 
    'x_global_lexical_scope_names__mutmut_8': x_global_lexical_scope_names__mutmut_8, 
    'x_global_lexical_scope_names__mutmut_9': x_global_lexical_scope_names__mutmut_9, 
    'x_global_lexical_scope_names__mutmut_10': x_global_lexical_scope_names__mutmut_10, 
    'x_global_lexical_scope_names__mutmut_11': x_global_lexical_scope_names__mutmut_11, 
    'x_global_lexical_scope_names__mutmut_12': x_global_lexical_scope_names__mutmut_12, 
    'x_global_lexical_scope_names__mutmut_13': x_global_lexical_scope_names__mutmut_13, 
    'x_global_lexical_scope_names__mutmut_14': x_global_lexical_scope_names__mutmut_14, 
    'x_global_lexical_scope_names__mutmut_15': x_global_lexical_scope_names__mutmut_15, 
    'x_global_lexical_scope_names__mutmut_16': x_global_lexical_scope_names__mutmut_16, 
    'x_global_lexical_scope_names__mutmut_17': x_global_lexical_scope_names__mutmut_17, 
    'x_global_lexical_scope_names__mutmut_18': x_global_lexical_scope_names__mutmut_18, 
    'x_global_lexical_scope_names__mutmut_19': x_global_lexical_scope_names__mutmut_19, 
    'x_global_lexical_scope_names__mutmut_20': x_global_lexical_scope_names__mutmut_20, 
    'x_global_lexical_scope_names__mutmut_21': x_global_lexical_scope_names__mutmut_21, 
    'x_global_lexical_scope_names__mutmut_22': x_global_lexical_scope_names__mutmut_22, 
    'x_global_lexical_scope_names__mutmut_23': x_global_lexical_scope_names__mutmut_23
}

def global_lexical_scope_names(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_global_lexical_scope_names__mutmut_orig, x_global_lexical_scope_names__mutmut_mutants, args, kwargs)
    return result 

global_lexical_scope_names.__signature__ = _mutmut_signature(x_global_lexical_scope_names__mutmut_orig)
x_global_lexical_scope_names__mutmut_orig.__name__ = 'x_global_lexical_scope_names'


def x_query_objects__mutmut_orig(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_1(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = None
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_2(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = None
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_3(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["XXprototypeObjectIdXX"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_4(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeobjectid"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_5(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["PROTOTYPEOBJECTID"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_6(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["Prototypeobjectid"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_7(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_8(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_9(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["XXobjectGroupXX"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_10(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectgroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_11(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["OBJECTGROUP"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_12(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["Objectgroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_13(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_14(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_15(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_16(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_17(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.queryObjectsXX",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_18(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.queryobjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_19(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.QUERYOBJECTS",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_20(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryobjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_21(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_22(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_23(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "Params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_24(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = None
    return RemoteObject.from_json(json["objects"])


def x_query_objects__mutmut_25(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(None)


def x_query_objects__mutmut_26(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["XXobjectsXX"])


def x_query_objects__mutmut_27(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["OBJECTS"])


def x_query_objects__mutmut_28(
    prototype_object_id: RemoteObjectId,
    object_group: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, RemoteObject]:
    """
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    """
    params: T_JSON_DICT = {}
    params["prototypeObjectId"] = prototype_object_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.queryObjects",
        "params": params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json["Objects"])

x_query_objects__mutmut_mutants : ClassVar[MutantDict] = {
'x_query_objects__mutmut_1': x_query_objects__mutmut_1, 
    'x_query_objects__mutmut_2': x_query_objects__mutmut_2, 
    'x_query_objects__mutmut_3': x_query_objects__mutmut_3, 
    'x_query_objects__mutmut_4': x_query_objects__mutmut_4, 
    'x_query_objects__mutmut_5': x_query_objects__mutmut_5, 
    'x_query_objects__mutmut_6': x_query_objects__mutmut_6, 
    'x_query_objects__mutmut_7': x_query_objects__mutmut_7, 
    'x_query_objects__mutmut_8': x_query_objects__mutmut_8, 
    'x_query_objects__mutmut_9': x_query_objects__mutmut_9, 
    'x_query_objects__mutmut_10': x_query_objects__mutmut_10, 
    'x_query_objects__mutmut_11': x_query_objects__mutmut_11, 
    'x_query_objects__mutmut_12': x_query_objects__mutmut_12, 
    'x_query_objects__mutmut_13': x_query_objects__mutmut_13, 
    'x_query_objects__mutmut_14': x_query_objects__mutmut_14, 
    'x_query_objects__mutmut_15': x_query_objects__mutmut_15, 
    'x_query_objects__mutmut_16': x_query_objects__mutmut_16, 
    'x_query_objects__mutmut_17': x_query_objects__mutmut_17, 
    'x_query_objects__mutmut_18': x_query_objects__mutmut_18, 
    'x_query_objects__mutmut_19': x_query_objects__mutmut_19, 
    'x_query_objects__mutmut_20': x_query_objects__mutmut_20, 
    'x_query_objects__mutmut_21': x_query_objects__mutmut_21, 
    'x_query_objects__mutmut_22': x_query_objects__mutmut_22, 
    'x_query_objects__mutmut_23': x_query_objects__mutmut_23, 
    'x_query_objects__mutmut_24': x_query_objects__mutmut_24, 
    'x_query_objects__mutmut_25': x_query_objects__mutmut_25, 
    'x_query_objects__mutmut_26': x_query_objects__mutmut_26, 
    'x_query_objects__mutmut_27': x_query_objects__mutmut_27, 
    'x_query_objects__mutmut_28': x_query_objects__mutmut_28
}

def query_objects(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_query_objects__mutmut_orig, x_query_objects__mutmut_mutants, args, kwargs)
    return result 

query_objects.__signature__ = _mutmut_signature(x_query_objects__mutmut_orig)
x_query_objects__mutmut_orig.__name__ = 'x_query_objects'


def x_release_object__mutmut_orig(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_1(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = None
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_2(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_3(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["XXobjectIdXX"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_4(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_5(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["OBJECTID"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_6(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["Objectid"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_7(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_release_object__mutmut_8(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.releaseObject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_9(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.releaseObject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_10(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.releaseObject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_11(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.releaseObjectXX",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_12(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.releaseobject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_13(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.RELEASEOBJECT",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_14(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseobject",
        "params": params,
    }
    yield cmd_dict


def x_release_object__mutmut_15(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObject",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_release_object__mutmut_16(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObject",
        "PARAMS": params,
    }
    yield cmd_dict


def x_release_object__mutmut_17(
    object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases remote object with given id.

    :param object_id: Identifier of the object to release.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObject",
        "Params": params,
    }
    yield cmd_dict

x_release_object__mutmut_mutants : ClassVar[MutantDict] = {
'x_release_object__mutmut_1': x_release_object__mutmut_1, 
    'x_release_object__mutmut_2': x_release_object__mutmut_2, 
    'x_release_object__mutmut_3': x_release_object__mutmut_3, 
    'x_release_object__mutmut_4': x_release_object__mutmut_4, 
    'x_release_object__mutmut_5': x_release_object__mutmut_5, 
    'x_release_object__mutmut_6': x_release_object__mutmut_6, 
    'x_release_object__mutmut_7': x_release_object__mutmut_7, 
    'x_release_object__mutmut_8': x_release_object__mutmut_8, 
    'x_release_object__mutmut_9': x_release_object__mutmut_9, 
    'x_release_object__mutmut_10': x_release_object__mutmut_10, 
    'x_release_object__mutmut_11': x_release_object__mutmut_11, 
    'x_release_object__mutmut_12': x_release_object__mutmut_12, 
    'x_release_object__mutmut_13': x_release_object__mutmut_13, 
    'x_release_object__mutmut_14': x_release_object__mutmut_14, 
    'x_release_object__mutmut_15': x_release_object__mutmut_15, 
    'x_release_object__mutmut_16': x_release_object__mutmut_16, 
    'x_release_object__mutmut_17': x_release_object__mutmut_17
}

def release_object(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_release_object__mutmut_orig, x_release_object__mutmut_mutants, args, kwargs)
    return result 

release_object.__signature__ = _mutmut_signature(x_release_object__mutmut_orig)
x_release_object__mutmut_orig.__name__ = 'x_release_object'


def x_release_object_group__mutmut_orig(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObjectGroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_1(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = None
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObjectGroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_2(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObjectGroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_3(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["XXobjectGroupXX"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObjectGroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_4(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectgroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObjectGroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_5(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["OBJECTGROUP"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObjectGroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_6(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["Objectgroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObjectGroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_7(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_release_object_group__mutmut_8(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.releaseObjectGroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_9(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.releaseObjectGroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_10(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.releaseObjectGroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_11(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.releaseObjectGroupXX",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_12(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.releaseobjectgroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_13(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.RELEASEOBJECTGROUP",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_14(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseobjectgroup",
        "params": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_15(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObjectGroup",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_16(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObjectGroup",
        "PARAMS": params,
    }
    yield cmd_dict


def x_release_object_group__mutmut_17(
    object_group: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Releases all remote objects that belong to a given group.

    :param object_group: Symbolic object group name.
    """
    params: T_JSON_DICT = {}
    params["objectGroup"] = object_group
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.releaseObjectGroup",
        "Params": params,
    }
    yield cmd_dict

x_release_object_group__mutmut_mutants : ClassVar[MutantDict] = {
'x_release_object_group__mutmut_1': x_release_object_group__mutmut_1, 
    'x_release_object_group__mutmut_2': x_release_object_group__mutmut_2, 
    'x_release_object_group__mutmut_3': x_release_object_group__mutmut_3, 
    'x_release_object_group__mutmut_4': x_release_object_group__mutmut_4, 
    'x_release_object_group__mutmut_5': x_release_object_group__mutmut_5, 
    'x_release_object_group__mutmut_6': x_release_object_group__mutmut_6, 
    'x_release_object_group__mutmut_7': x_release_object_group__mutmut_7, 
    'x_release_object_group__mutmut_8': x_release_object_group__mutmut_8, 
    'x_release_object_group__mutmut_9': x_release_object_group__mutmut_9, 
    'x_release_object_group__mutmut_10': x_release_object_group__mutmut_10, 
    'x_release_object_group__mutmut_11': x_release_object_group__mutmut_11, 
    'x_release_object_group__mutmut_12': x_release_object_group__mutmut_12, 
    'x_release_object_group__mutmut_13': x_release_object_group__mutmut_13, 
    'x_release_object_group__mutmut_14': x_release_object_group__mutmut_14, 
    'x_release_object_group__mutmut_15': x_release_object_group__mutmut_15, 
    'x_release_object_group__mutmut_16': x_release_object_group__mutmut_16, 
    'x_release_object_group__mutmut_17': x_release_object_group__mutmut_17
}

def release_object_group(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_release_object_group__mutmut_orig, x_release_object_group__mutmut_mutants, args, kwargs)
    return result 

release_object_group.__signature__ = _mutmut_signature(x_release_object_group__mutmut_orig)
x_release_object_group__mutmut_orig.__name__ = 'x_release_object_group'


def x_run_if_waiting_for_debugger__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tells inspected instance to run if it was waiting for debugger to attach.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runIfWaitingForDebugger",
    }
    yield cmd_dict


def x_run_if_waiting_for_debugger__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tells inspected instance to run if it was waiting for debugger to attach.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_run_if_waiting_for_debugger__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tells inspected instance to run if it was waiting for debugger to attach.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.runIfWaitingForDebugger",
    }
    yield cmd_dict


def x_run_if_waiting_for_debugger__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tells inspected instance to run if it was waiting for debugger to attach.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.runIfWaitingForDebugger",
    }
    yield cmd_dict


def x_run_if_waiting_for_debugger__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tells inspected instance to run if it was waiting for debugger to attach.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.runIfWaitingForDebugger",
    }
    yield cmd_dict


def x_run_if_waiting_for_debugger__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tells inspected instance to run if it was waiting for debugger to attach.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.runIfWaitingForDebuggerXX",
    }
    yield cmd_dict


def x_run_if_waiting_for_debugger__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tells inspected instance to run if it was waiting for debugger to attach.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.runifwaitingfordebugger",
    }
    yield cmd_dict


def x_run_if_waiting_for_debugger__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tells inspected instance to run if it was waiting for debugger to attach.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.RUNIFWAITINGFORDEBUGGER",
    }
    yield cmd_dict


def x_run_if_waiting_for_debugger__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Tells inspected instance to run if it was waiting for debugger to attach.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runifwaitingfordebugger",
    }
    yield cmd_dict

x_run_if_waiting_for_debugger__mutmut_mutants : ClassVar[MutantDict] = {
'x_run_if_waiting_for_debugger__mutmut_1': x_run_if_waiting_for_debugger__mutmut_1, 
    'x_run_if_waiting_for_debugger__mutmut_2': x_run_if_waiting_for_debugger__mutmut_2, 
    'x_run_if_waiting_for_debugger__mutmut_3': x_run_if_waiting_for_debugger__mutmut_3, 
    'x_run_if_waiting_for_debugger__mutmut_4': x_run_if_waiting_for_debugger__mutmut_4, 
    'x_run_if_waiting_for_debugger__mutmut_5': x_run_if_waiting_for_debugger__mutmut_5, 
    'x_run_if_waiting_for_debugger__mutmut_6': x_run_if_waiting_for_debugger__mutmut_6, 
    'x_run_if_waiting_for_debugger__mutmut_7': x_run_if_waiting_for_debugger__mutmut_7, 
    'x_run_if_waiting_for_debugger__mutmut_8': x_run_if_waiting_for_debugger__mutmut_8
}

def run_if_waiting_for_debugger(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_run_if_waiting_for_debugger__mutmut_orig, x_run_if_waiting_for_debugger__mutmut_mutants, args, kwargs)
    return result 

run_if_waiting_for_debugger.__signature__ = _mutmut_signature(x_run_if_waiting_for_debugger__mutmut_orig)
x_run_if_waiting_for_debugger__mutmut_orig.__name__ = 'x_run_if_waiting_for_debugger'


def x_run_script__mutmut_orig(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_1(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = None
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_2(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = None
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_3(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["XXscriptIdXX"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_4(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptid"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_5(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["SCRIPTID"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_6(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["Scriptid"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_7(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_8(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = None
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_9(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["XXexecutionContextIdXX"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_10(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executioncontextid"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_11(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["EXECUTIONCONTEXTID"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_12(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["Executioncontextid"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_13(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_14(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = None
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_15(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["XXobjectGroupXX"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_16(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectgroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_17(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["OBJECTGROUP"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_18(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["Objectgroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_19(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_20(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = None
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_21(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["XXsilentXX"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_22(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["SILENT"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_23(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["Silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_24(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_25(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = None
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_26(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["XXincludeCommandLineAPIXX"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_27(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includecommandlineapi"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_28(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["INCLUDECOMMANDLINEAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_29(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["Includecommandlineapi"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_30(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_31(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = None
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_32(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["XXreturnByValueXX"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_33(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnbyvalue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_34(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["RETURNBYVALUE"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_35(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["Returnbyvalue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_36(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_37(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = None
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_38(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["XXgeneratePreviewXX"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_39(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatepreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_40(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["GENERATEPREVIEW"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_41(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["Generatepreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_42(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_43(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_44(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["XXawaitPromiseXX"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_45(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitpromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_46(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["AWAITPROMISE"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_47(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["Awaitpromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_48(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_49(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_50(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_51(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_52(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.runScriptXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_53(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.runscript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_54(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.RUNSCRIPT",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_55(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runscript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_56(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_57(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_58(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_59(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = None
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_60(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(None),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_61(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["XXresultXX"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_62(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["RESULT"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_63(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["Result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_64(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(None) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_65(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["XXexceptionDetailsXX"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_66(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_67(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["EXCEPTIONDETAILS"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_68(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["Exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_run_script__mutmut_69(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "XXexceptionDetailsXX" in json else None,
    )


def x_run_script__mutmut_70(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptiondetails" in json else None,
    )


def x_run_script__mutmut_71(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "EXCEPTIONDETAILS" in json else None,
    )


def x_run_script__mutmut_72(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "Exceptiondetails" in json else None,
    )


def x_run_script__mutmut_73(
    script_id: ScriptId,
    execution_context_id: ExecutionContextId | None = None,
    object_group: str | None = None,
    silent: bool | None = None,
    include_command_line_api: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    await_promise: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[RemoteObject, ExceptionDetails | None]]:
    """
    Runs script with given id in a given context.

    :param script_id: Id of the script to run.
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state.
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: *(Optional)* Whether preview should be generated for the result.
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved.
    :returns: A tuple with the following items:

        0. **result** - Run result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if object_group is not None:
        params["objectGroup"] = object_group
    if silent is not None:
        params["silent"] = silent
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if await_promise is not None:
        params["awaitPromise"] = await_promise
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.runScript",
        "params": params,
    }
    json = yield cmd_dict
    return (
        RemoteObject.from_json(json["result"]),
        ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" not in json else None,
    )

x_run_script__mutmut_mutants : ClassVar[MutantDict] = {
'x_run_script__mutmut_1': x_run_script__mutmut_1, 
    'x_run_script__mutmut_2': x_run_script__mutmut_2, 
    'x_run_script__mutmut_3': x_run_script__mutmut_3, 
    'x_run_script__mutmut_4': x_run_script__mutmut_4, 
    'x_run_script__mutmut_5': x_run_script__mutmut_5, 
    'x_run_script__mutmut_6': x_run_script__mutmut_6, 
    'x_run_script__mutmut_7': x_run_script__mutmut_7, 
    'x_run_script__mutmut_8': x_run_script__mutmut_8, 
    'x_run_script__mutmut_9': x_run_script__mutmut_9, 
    'x_run_script__mutmut_10': x_run_script__mutmut_10, 
    'x_run_script__mutmut_11': x_run_script__mutmut_11, 
    'x_run_script__mutmut_12': x_run_script__mutmut_12, 
    'x_run_script__mutmut_13': x_run_script__mutmut_13, 
    'x_run_script__mutmut_14': x_run_script__mutmut_14, 
    'x_run_script__mutmut_15': x_run_script__mutmut_15, 
    'x_run_script__mutmut_16': x_run_script__mutmut_16, 
    'x_run_script__mutmut_17': x_run_script__mutmut_17, 
    'x_run_script__mutmut_18': x_run_script__mutmut_18, 
    'x_run_script__mutmut_19': x_run_script__mutmut_19, 
    'x_run_script__mutmut_20': x_run_script__mutmut_20, 
    'x_run_script__mutmut_21': x_run_script__mutmut_21, 
    'x_run_script__mutmut_22': x_run_script__mutmut_22, 
    'x_run_script__mutmut_23': x_run_script__mutmut_23, 
    'x_run_script__mutmut_24': x_run_script__mutmut_24, 
    'x_run_script__mutmut_25': x_run_script__mutmut_25, 
    'x_run_script__mutmut_26': x_run_script__mutmut_26, 
    'x_run_script__mutmut_27': x_run_script__mutmut_27, 
    'x_run_script__mutmut_28': x_run_script__mutmut_28, 
    'x_run_script__mutmut_29': x_run_script__mutmut_29, 
    'x_run_script__mutmut_30': x_run_script__mutmut_30, 
    'x_run_script__mutmut_31': x_run_script__mutmut_31, 
    'x_run_script__mutmut_32': x_run_script__mutmut_32, 
    'x_run_script__mutmut_33': x_run_script__mutmut_33, 
    'x_run_script__mutmut_34': x_run_script__mutmut_34, 
    'x_run_script__mutmut_35': x_run_script__mutmut_35, 
    'x_run_script__mutmut_36': x_run_script__mutmut_36, 
    'x_run_script__mutmut_37': x_run_script__mutmut_37, 
    'x_run_script__mutmut_38': x_run_script__mutmut_38, 
    'x_run_script__mutmut_39': x_run_script__mutmut_39, 
    'x_run_script__mutmut_40': x_run_script__mutmut_40, 
    'x_run_script__mutmut_41': x_run_script__mutmut_41, 
    'x_run_script__mutmut_42': x_run_script__mutmut_42, 
    'x_run_script__mutmut_43': x_run_script__mutmut_43, 
    'x_run_script__mutmut_44': x_run_script__mutmut_44, 
    'x_run_script__mutmut_45': x_run_script__mutmut_45, 
    'x_run_script__mutmut_46': x_run_script__mutmut_46, 
    'x_run_script__mutmut_47': x_run_script__mutmut_47, 
    'x_run_script__mutmut_48': x_run_script__mutmut_48, 
    'x_run_script__mutmut_49': x_run_script__mutmut_49, 
    'x_run_script__mutmut_50': x_run_script__mutmut_50, 
    'x_run_script__mutmut_51': x_run_script__mutmut_51, 
    'x_run_script__mutmut_52': x_run_script__mutmut_52, 
    'x_run_script__mutmut_53': x_run_script__mutmut_53, 
    'x_run_script__mutmut_54': x_run_script__mutmut_54, 
    'x_run_script__mutmut_55': x_run_script__mutmut_55, 
    'x_run_script__mutmut_56': x_run_script__mutmut_56, 
    'x_run_script__mutmut_57': x_run_script__mutmut_57, 
    'x_run_script__mutmut_58': x_run_script__mutmut_58, 
    'x_run_script__mutmut_59': x_run_script__mutmut_59, 
    'x_run_script__mutmut_60': x_run_script__mutmut_60, 
    'x_run_script__mutmut_61': x_run_script__mutmut_61, 
    'x_run_script__mutmut_62': x_run_script__mutmut_62, 
    'x_run_script__mutmut_63': x_run_script__mutmut_63, 
    'x_run_script__mutmut_64': x_run_script__mutmut_64, 
    'x_run_script__mutmut_65': x_run_script__mutmut_65, 
    'x_run_script__mutmut_66': x_run_script__mutmut_66, 
    'x_run_script__mutmut_67': x_run_script__mutmut_67, 
    'x_run_script__mutmut_68': x_run_script__mutmut_68, 
    'x_run_script__mutmut_69': x_run_script__mutmut_69, 
    'x_run_script__mutmut_70': x_run_script__mutmut_70, 
    'x_run_script__mutmut_71': x_run_script__mutmut_71, 
    'x_run_script__mutmut_72': x_run_script__mutmut_72, 
    'x_run_script__mutmut_73': x_run_script__mutmut_73
}

def run_script(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_run_script__mutmut_orig, x_run_script__mutmut_mutants, args, kwargs)
    return result 

run_script.__signature__ = _mutmut_signature(x_run_script__mutmut_orig)
x_run_script__mutmut_orig.__name__ = 'x_run_script'


def x_set_async_call_stack_depth__mutmut_orig(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_1(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = None
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_2(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_3(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["XXmaxDepthXX"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_4(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxdepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_5(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["MAXDEPTH"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_6(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["Maxdepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_7(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_8(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_9(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_10(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_11(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.setAsyncCallStackDepthXX",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_12(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.setasynccallstackdepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_13(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.SETASYNCCALLSTACKDEPTH",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_14(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setasynccallstackdepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_15(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setAsyncCallStackDepth",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_16(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setAsyncCallStackDepth",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_17(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setAsyncCallStackDepth",
        "Params": params,
    }
    yield cmd_dict

x_set_async_call_stack_depth__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_async_call_stack_depth__mutmut_1': x_set_async_call_stack_depth__mutmut_1, 
    'x_set_async_call_stack_depth__mutmut_2': x_set_async_call_stack_depth__mutmut_2, 
    'x_set_async_call_stack_depth__mutmut_3': x_set_async_call_stack_depth__mutmut_3, 
    'x_set_async_call_stack_depth__mutmut_4': x_set_async_call_stack_depth__mutmut_4, 
    'x_set_async_call_stack_depth__mutmut_5': x_set_async_call_stack_depth__mutmut_5, 
    'x_set_async_call_stack_depth__mutmut_6': x_set_async_call_stack_depth__mutmut_6, 
    'x_set_async_call_stack_depth__mutmut_7': x_set_async_call_stack_depth__mutmut_7, 
    'x_set_async_call_stack_depth__mutmut_8': x_set_async_call_stack_depth__mutmut_8, 
    'x_set_async_call_stack_depth__mutmut_9': x_set_async_call_stack_depth__mutmut_9, 
    'x_set_async_call_stack_depth__mutmut_10': x_set_async_call_stack_depth__mutmut_10, 
    'x_set_async_call_stack_depth__mutmut_11': x_set_async_call_stack_depth__mutmut_11, 
    'x_set_async_call_stack_depth__mutmut_12': x_set_async_call_stack_depth__mutmut_12, 
    'x_set_async_call_stack_depth__mutmut_13': x_set_async_call_stack_depth__mutmut_13, 
    'x_set_async_call_stack_depth__mutmut_14': x_set_async_call_stack_depth__mutmut_14, 
    'x_set_async_call_stack_depth__mutmut_15': x_set_async_call_stack_depth__mutmut_15, 
    'x_set_async_call_stack_depth__mutmut_16': x_set_async_call_stack_depth__mutmut_16, 
    'x_set_async_call_stack_depth__mutmut_17': x_set_async_call_stack_depth__mutmut_17
}

def set_async_call_stack_depth(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_async_call_stack_depth__mutmut_orig, x_set_async_call_stack_depth__mutmut_mutants, args, kwargs)
    return result 

set_async_call_stack_depth.__signature__ = _mutmut_signature(x_set_async_call_stack_depth__mutmut_orig)
x_set_async_call_stack_depth__mutmut_orig.__name__ = 'x_set_async_call_stack_depth'


def x_set_custom_object_formatter_enabled__mutmut_orig(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setCustomObjectFormatterEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_1(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = None
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setCustomObjectFormatterEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_2(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setCustomObjectFormatterEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_3(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["XXenabledXX"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setCustomObjectFormatterEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_4(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["ENABLED"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setCustomObjectFormatterEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_5(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["Enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setCustomObjectFormatterEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_6(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_7(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.setCustomObjectFormatterEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_8(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.setCustomObjectFormatterEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_9(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.setCustomObjectFormatterEnabled",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_10(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.setCustomObjectFormatterEnabledXX",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_11(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.setcustomobjectformatterenabled",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_12(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.SETCUSTOMOBJECTFORMATTERENABLED",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_13(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setcustomobjectformatterenabled",
        "params": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_14(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setCustomObjectFormatterEnabled",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_15(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setCustomObjectFormatterEnabled",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_custom_object_formatter_enabled__mutmut_16(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setCustomObjectFormatterEnabled",
        "Params": params,
    }
    yield cmd_dict

x_set_custom_object_formatter_enabled__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_custom_object_formatter_enabled__mutmut_1': x_set_custom_object_formatter_enabled__mutmut_1, 
    'x_set_custom_object_formatter_enabled__mutmut_2': x_set_custom_object_formatter_enabled__mutmut_2, 
    'x_set_custom_object_formatter_enabled__mutmut_3': x_set_custom_object_formatter_enabled__mutmut_3, 
    'x_set_custom_object_formatter_enabled__mutmut_4': x_set_custom_object_formatter_enabled__mutmut_4, 
    'x_set_custom_object_formatter_enabled__mutmut_5': x_set_custom_object_formatter_enabled__mutmut_5, 
    'x_set_custom_object_formatter_enabled__mutmut_6': x_set_custom_object_formatter_enabled__mutmut_6, 
    'x_set_custom_object_formatter_enabled__mutmut_7': x_set_custom_object_formatter_enabled__mutmut_7, 
    'x_set_custom_object_formatter_enabled__mutmut_8': x_set_custom_object_formatter_enabled__mutmut_8, 
    'x_set_custom_object_formatter_enabled__mutmut_9': x_set_custom_object_formatter_enabled__mutmut_9, 
    'x_set_custom_object_formatter_enabled__mutmut_10': x_set_custom_object_formatter_enabled__mutmut_10, 
    'x_set_custom_object_formatter_enabled__mutmut_11': x_set_custom_object_formatter_enabled__mutmut_11, 
    'x_set_custom_object_formatter_enabled__mutmut_12': x_set_custom_object_formatter_enabled__mutmut_12, 
    'x_set_custom_object_formatter_enabled__mutmut_13': x_set_custom_object_formatter_enabled__mutmut_13, 
    'x_set_custom_object_formatter_enabled__mutmut_14': x_set_custom_object_formatter_enabled__mutmut_14, 
    'x_set_custom_object_formatter_enabled__mutmut_15': x_set_custom_object_formatter_enabled__mutmut_15, 
    'x_set_custom_object_formatter_enabled__mutmut_16': x_set_custom_object_formatter_enabled__mutmut_16
}

def set_custom_object_formatter_enabled(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_custom_object_formatter_enabled__mutmut_orig, x_set_custom_object_formatter_enabled__mutmut_mutants, args, kwargs)
    return result 

set_custom_object_formatter_enabled.__signature__ = _mutmut_signature(x_set_custom_object_formatter_enabled__mutmut_orig)
x_set_custom_object_formatter_enabled__mutmut_orig.__name__ = 'x_set_custom_object_formatter_enabled'


def x_set_max_call_stack_size_to_capture__mutmut_orig(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setMaxCallStackSizeToCapture",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_1(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = None
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setMaxCallStackSizeToCapture",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_2(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setMaxCallStackSizeToCapture",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_3(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["XXsizeXX"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setMaxCallStackSizeToCapture",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_4(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["SIZE"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setMaxCallStackSizeToCapture",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_5(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["Size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setMaxCallStackSizeToCapture",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_6(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_7(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.setMaxCallStackSizeToCapture",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_8(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.setMaxCallStackSizeToCapture",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_9(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.setMaxCallStackSizeToCapture",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_10(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.setMaxCallStackSizeToCaptureXX",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_11(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.setmaxcallstacksizetocapture",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_12(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.SETMAXCALLSTACKSIZETOCAPTURE",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_13(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setmaxcallstacksizetocapture",
        "params": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_14(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setMaxCallStackSizeToCapture",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_15(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setMaxCallStackSizeToCapture",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_max_call_stack_size_to_capture__mutmut_16(
    size: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param size:
    """
    params: T_JSON_DICT = {}
    params["size"] = size
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.setMaxCallStackSizeToCapture",
        "Params": params,
    }
    yield cmd_dict

x_set_max_call_stack_size_to_capture__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_max_call_stack_size_to_capture__mutmut_1': x_set_max_call_stack_size_to_capture__mutmut_1, 
    'x_set_max_call_stack_size_to_capture__mutmut_2': x_set_max_call_stack_size_to_capture__mutmut_2, 
    'x_set_max_call_stack_size_to_capture__mutmut_3': x_set_max_call_stack_size_to_capture__mutmut_3, 
    'x_set_max_call_stack_size_to_capture__mutmut_4': x_set_max_call_stack_size_to_capture__mutmut_4, 
    'x_set_max_call_stack_size_to_capture__mutmut_5': x_set_max_call_stack_size_to_capture__mutmut_5, 
    'x_set_max_call_stack_size_to_capture__mutmut_6': x_set_max_call_stack_size_to_capture__mutmut_6, 
    'x_set_max_call_stack_size_to_capture__mutmut_7': x_set_max_call_stack_size_to_capture__mutmut_7, 
    'x_set_max_call_stack_size_to_capture__mutmut_8': x_set_max_call_stack_size_to_capture__mutmut_8, 
    'x_set_max_call_stack_size_to_capture__mutmut_9': x_set_max_call_stack_size_to_capture__mutmut_9, 
    'x_set_max_call_stack_size_to_capture__mutmut_10': x_set_max_call_stack_size_to_capture__mutmut_10, 
    'x_set_max_call_stack_size_to_capture__mutmut_11': x_set_max_call_stack_size_to_capture__mutmut_11, 
    'x_set_max_call_stack_size_to_capture__mutmut_12': x_set_max_call_stack_size_to_capture__mutmut_12, 
    'x_set_max_call_stack_size_to_capture__mutmut_13': x_set_max_call_stack_size_to_capture__mutmut_13, 
    'x_set_max_call_stack_size_to_capture__mutmut_14': x_set_max_call_stack_size_to_capture__mutmut_14, 
    'x_set_max_call_stack_size_to_capture__mutmut_15': x_set_max_call_stack_size_to_capture__mutmut_15, 
    'x_set_max_call_stack_size_to_capture__mutmut_16': x_set_max_call_stack_size_to_capture__mutmut_16
}

def set_max_call_stack_size_to_capture(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_max_call_stack_size_to_capture__mutmut_orig, x_set_max_call_stack_size_to_capture__mutmut_mutants, args, kwargs)
    return result 

set_max_call_stack_size_to_capture.__signature__ = _mutmut_signature(x_set_max_call_stack_size_to_capture__mutmut_orig)
x_set_max_call_stack_size_to_capture__mutmut_orig.__name__ = 'x_set_max_call_stack_size_to_capture'


def x_terminate_execution__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Terminate current or next JavaScript execution.
    Will cancel the termination when the outer-most script execution ends.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.terminateExecution",
    }
    yield cmd_dict


def x_terminate_execution__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Terminate current or next JavaScript execution.
    Will cancel the termination when the outer-most script execution ends.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_terminate_execution__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Terminate current or next JavaScript execution.
    Will cancel the termination when the outer-most script execution ends.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.terminateExecution",
    }
    yield cmd_dict


def x_terminate_execution__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Terminate current or next JavaScript execution.
    Will cancel the termination when the outer-most script execution ends.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.terminateExecution",
    }
    yield cmd_dict


def x_terminate_execution__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Terminate current or next JavaScript execution.
    Will cancel the termination when the outer-most script execution ends.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.terminateExecution",
    }
    yield cmd_dict


def x_terminate_execution__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Terminate current or next JavaScript execution.
    Will cancel the termination when the outer-most script execution ends.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.terminateExecutionXX",
    }
    yield cmd_dict


def x_terminate_execution__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Terminate current or next JavaScript execution.
    Will cancel the termination when the outer-most script execution ends.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.terminateexecution",
    }
    yield cmd_dict


def x_terminate_execution__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Terminate current or next JavaScript execution.
    Will cancel the termination when the outer-most script execution ends.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.TERMINATEEXECUTION",
    }
    yield cmd_dict


def x_terminate_execution__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Terminate current or next JavaScript execution.
    Will cancel the termination when the outer-most script execution ends.

    **EXPERIMENTAL**
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.terminateexecution",
    }
    yield cmd_dict

x_terminate_execution__mutmut_mutants : ClassVar[MutantDict] = {
'x_terminate_execution__mutmut_1': x_terminate_execution__mutmut_1, 
    'x_terminate_execution__mutmut_2': x_terminate_execution__mutmut_2, 
    'x_terminate_execution__mutmut_3': x_terminate_execution__mutmut_3, 
    'x_terminate_execution__mutmut_4': x_terminate_execution__mutmut_4, 
    'x_terminate_execution__mutmut_5': x_terminate_execution__mutmut_5, 
    'x_terminate_execution__mutmut_6': x_terminate_execution__mutmut_6, 
    'x_terminate_execution__mutmut_7': x_terminate_execution__mutmut_7, 
    'x_terminate_execution__mutmut_8': x_terminate_execution__mutmut_8
}

def terminate_execution(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_terminate_execution__mutmut_orig, x_terminate_execution__mutmut_mutants, args, kwargs)
    return result 

terminate_execution.__signature__ = _mutmut_signature(x_terminate_execution__mutmut_orig)
x_terminate_execution__mutmut_orig.__name__ = 'x_terminate_execution'


def x_add_binding__mutmut_orig(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_1(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = None
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_2(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = None
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_3(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["XXnameXX"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_4(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["NAME"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_5(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["Name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_6(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_7(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = None
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_8(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["XXexecutionContextIdXX"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_9(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executioncontextid"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_10(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["EXECUTIONCONTEXTID"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_11(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["Executioncontextid"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_12(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_13(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_14(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["XXexecutionContextNameXX"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_15(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executioncontextname"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_16(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["EXECUTIONCONTEXTNAME"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_17(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["Executioncontextname"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_18(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_add_binding__mutmut_19(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_20(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_21(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.addBinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_22(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.addBindingXX",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_23(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.addbinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_24(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.ADDBINDING",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_25(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addbinding",
        "params": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_26(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_27(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "PARAMS": params,
    }
    yield cmd_dict


def x_add_binding__mutmut_28(
    name: str,
    execution_context_id: ExecutionContextId | None = None,
    execution_context_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.

    :param name:
    :param execution_context_id: **(EXPERIMENTAL)** *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. Deprecated in favor of ````executionContextName```` due to an unclear use case and bugs in implementation (crbug.com/1169639). ````executionContextId```` will be removed in the future.
    :param execution_context_name: *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```.
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    if execution_context_id is not None:
        params["executionContextId"] = execution_context_id.to_json()
    if execution_context_name is not None:
        params["executionContextName"] = execution_context_name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.addBinding",
        "Params": params,
    }
    yield cmd_dict

x_add_binding__mutmut_mutants : ClassVar[MutantDict] = {
'x_add_binding__mutmut_1': x_add_binding__mutmut_1, 
    'x_add_binding__mutmut_2': x_add_binding__mutmut_2, 
    'x_add_binding__mutmut_3': x_add_binding__mutmut_3, 
    'x_add_binding__mutmut_4': x_add_binding__mutmut_4, 
    'x_add_binding__mutmut_5': x_add_binding__mutmut_5, 
    'x_add_binding__mutmut_6': x_add_binding__mutmut_6, 
    'x_add_binding__mutmut_7': x_add_binding__mutmut_7, 
    'x_add_binding__mutmut_8': x_add_binding__mutmut_8, 
    'x_add_binding__mutmut_9': x_add_binding__mutmut_9, 
    'x_add_binding__mutmut_10': x_add_binding__mutmut_10, 
    'x_add_binding__mutmut_11': x_add_binding__mutmut_11, 
    'x_add_binding__mutmut_12': x_add_binding__mutmut_12, 
    'x_add_binding__mutmut_13': x_add_binding__mutmut_13, 
    'x_add_binding__mutmut_14': x_add_binding__mutmut_14, 
    'x_add_binding__mutmut_15': x_add_binding__mutmut_15, 
    'x_add_binding__mutmut_16': x_add_binding__mutmut_16, 
    'x_add_binding__mutmut_17': x_add_binding__mutmut_17, 
    'x_add_binding__mutmut_18': x_add_binding__mutmut_18, 
    'x_add_binding__mutmut_19': x_add_binding__mutmut_19, 
    'x_add_binding__mutmut_20': x_add_binding__mutmut_20, 
    'x_add_binding__mutmut_21': x_add_binding__mutmut_21, 
    'x_add_binding__mutmut_22': x_add_binding__mutmut_22, 
    'x_add_binding__mutmut_23': x_add_binding__mutmut_23, 
    'x_add_binding__mutmut_24': x_add_binding__mutmut_24, 
    'x_add_binding__mutmut_25': x_add_binding__mutmut_25, 
    'x_add_binding__mutmut_26': x_add_binding__mutmut_26, 
    'x_add_binding__mutmut_27': x_add_binding__mutmut_27, 
    'x_add_binding__mutmut_28': x_add_binding__mutmut_28
}

def add_binding(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_add_binding__mutmut_orig, x_add_binding__mutmut_mutants, args, kwargs)
    return result 

add_binding.__signature__ = _mutmut_signature(x_add_binding__mutmut_orig)
x_add_binding__mutmut_orig.__name__ = 'x_add_binding'


def x_remove_binding__mutmut_orig(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.removeBinding",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_1(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = None
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.removeBinding",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_2(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.removeBinding",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_3(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["XXnameXX"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.removeBinding",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_4(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["NAME"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.removeBinding",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_5(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["Name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.removeBinding",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_6(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_remove_binding__mutmut_7(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.removeBinding",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_8(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.removeBinding",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_9(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.removeBinding",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_10(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.removeBindingXX",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_11(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.removebinding",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_12(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.REMOVEBINDING",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_13(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.removebinding",
        "params": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_14(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.removeBinding",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_15(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.removeBinding",
        "PARAMS": params,
    }
    yield cmd_dict


def x_remove_binding__mutmut_16(
    name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.

    :param name:
    """
    params: T_JSON_DICT = {}
    params["name"] = name
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.removeBinding",
        "Params": params,
    }
    yield cmd_dict

x_remove_binding__mutmut_mutants : ClassVar[MutantDict] = {
'x_remove_binding__mutmut_1': x_remove_binding__mutmut_1, 
    'x_remove_binding__mutmut_2': x_remove_binding__mutmut_2, 
    'x_remove_binding__mutmut_3': x_remove_binding__mutmut_3, 
    'x_remove_binding__mutmut_4': x_remove_binding__mutmut_4, 
    'x_remove_binding__mutmut_5': x_remove_binding__mutmut_5, 
    'x_remove_binding__mutmut_6': x_remove_binding__mutmut_6, 
    'x_remove_binding__mutmut_7': x_remove_binding__mutmut_7, 
    'x_remove_binding__mutmut_8': x_remove_binding__mutmut_8, 
    'x_remove_binding__mutmut_9': x_remove_binding__mutmut_9, 
    'x_remove_binding__mutmut_10': x_remove_binding__mutmut_10, 
    'x_remove_binding__mutmut_11': x_remove_binding__mutmut_11, 
    'x_remove_binding__mutmut_12': x_remove_binding__mutmut_12, 
    'x_remove_binding__mutmut_13': x_remove_binding__mutmut_13, 
    'x_remove_binding__mutmut_14': x_remove_binding__mutmut_14, 
    'x_remove_binding__mutmut_15': x_remove_binding__mutmut_15, 
    'x_remove_binding__mutmut_16': x_remove_binding__mutmut_16
}

def remove_binding(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_remove_binding__mutmut_orig, x_remove_binding__mutmut_mutants, args, kwargs)
    return result 

remove_binding.__signature__ = _mutmut_signature(x_remove_binding__mutmut_orig)
x_remove_binding__mutmut_orig.__name__ = 'x_remove_binding'


def x_get_exception_details__mutmut_orig(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_1(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = None
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_2(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_3(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["XXerrorObjectIdXX"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_4(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorobjectid"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_5(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["ERROROBJECTID"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_6(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["Errorobjectid"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_7(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_8(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_9(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_10(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_11(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXRuntime.getExceptionDetailsXX",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_12(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "runtime.getexceptiondetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_13(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "RUNTIME.GETEXCEPTIONDETAILS",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_14(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getexceptiondetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_15(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_16(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_17(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "Params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_18(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = None
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_19(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(None) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_20(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["XXexceptionDetailsXX"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_21(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptiondetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_22(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["EXCEPTIONDETAILS"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_23(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["Exceptiondetails"]) if "exceptionDetails" in json else None


def x_get_exception_details__mutmut_24(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "XXexceptionDetailsXX" in json else None


def x_get_exception_details__mutmut_25(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptiondetails" in json else None


def x_get_exception_details__mutmut_26(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "EXCEPTIONDETAILS" in json else None


def x_get_exception_details__mutmut_27(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "Exceptiondetails" in json else None


def x_get_exception_details__mutmut_28(
    error_object_id: RemoteObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ExceptionDetails | None]:
    """
    This method tries to lookup and populate exception details for a
    JavaScript Error object.
    Note that the stackTrace portion of the resulting exceptionDetails will
    only be populated if the Runtime domain was enabled at the time when the
    Error was thrown.

    **EXPERIMENTAL**

    :param error_object_id: The error object for which to resolve the exception details.
    :returns:
    """
    params: T_JSON_DICT = {}
    params["errorObjectId"] = error_object_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Runtime.getExceptionDetails",
        "params": params,
    }
    json = yield cmd_dict
    return ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" not in json else None

x_get_exception_details__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_exception_details__mutmut_1': x_get_exception_details__mutmut_1, 
    'x_get_exception_details__mutmut_2': x_get_exception_details__mutmut_2, 
    'x_get_exception_details__mutmut_3': x_get_exception_details__mutmut_3, 
    'x_get_exception_details__mutmut_4': x_get_exception_details__mutmut_4, 
    'x_get_exception_details__mutmut_5': x_get_exception_details__mutmut_5, 
    'x_get_exception_details__mutmut_6': x_get_exception_details__mutmut_6, 
    'x_get_exception_details__mutmut_7': x_get_exception_details__mutmut_7, 
    'x_get_exception_details__mutmut_8': x_get_exception_details__mutmut_8, 
    'x_get_exception_details__mutmut_9': x_get_exception_details__mutmut_9, 
    'x_get_exception_details__mutmut_10': x_get_exception_details__mutmut_10, 
    'x_get_exception_details__mutmut_11': x_get_exception_details__mutmut_11, 
    'x_get_exception_details__mutmut_12': x_get_exception_details__mutmut_12, 
    'x_get_exception_details__mutmut_13': x_get_exception_details__mutmut_13, 
    'x_get_exception_details__mutmut_14': x_get_exception_details__mutmut_14, 
    'x_get_exception_details__mutmut_15': x_get_exception_details__mutmut_15, 
    'x_get_exception_details__mutmut_16': x_get_exception_details__mutmut_16, 
    'x_get_exception_details__mutmut_17': x_get_exception_details__mutmut_17, 
    'x_get_exception_details__mutmut_18': x_get_exception_details__mutmut_18, 
    'x_get_exception_details__mutmut_19': x_get_exception_details__mutmut_19, 
    'x_get_exception_details__mutmut_20': x_get_exception_details__mutmut_20, 
    'x_get_exception_details__mutmut_21': x_get_exception_details__mutmut_21, 
    'x_get_exception_details__mutmut_22': x_get_exception_details__mutmut_22, 
    'x_get_exception_details__mutmut_23': x_get_exception_details__mutmut_23, 
    'x_get_exception_details__mutmut_24': x_get_exception_details__mutmut_24, 
    'x_get_exception_details__mutmut_25': x_get_exception_details__mutmut_25, 
    'x_get_exception_details__mutmut_26': x_get_exception_details__mutmut_26, 
    'x_get_exception_details__mutmut_27': x_get_exception_details__mutmut_27, 
    'x_get_exception_details__mutmut_28': x_get_exception_details__mutmut_28
}

def get_exception_details(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_exception_details__mutmut_orig, x_get_exception_details__mutmut_mutants, args, kwargs)
    return result 

get_exception_details.__signature__ = _mutmut_signature(x_get_exception_details__mutmut_orig)
x_get_exception_details__mutmut_orig.__name__ = 'x_get_exception_details'


@event_class("Runtime.bindingCalled")
@dataclass
class BindingCalled:
    """
    **EXPERIMENTAL**

    Notification is issued every time when binding is called.
    """
    name: str
    payload: str
    #: Identifier of the context where the call was made.
    execution_context_id: ExecutionContextId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BindingCalled:
        return cls(
            name=str(json["name"]),
            payload=str(json["payload"]),
            execution_context_id=ExecutionContextId.from_json(json["executionContextId"]),
        )


@event_class("Runtime.consoleAPICalled")
@dataclass
class ConsoleAPICalled:
    """
    Issued when console API was called.
    """
    #: Type of the call.
    type_: str
    #: Call arguments.
    args: list[RemoteObject]
    #: Identifier of the context where the call was made.
    execution_context_id: ExecutionContextId
    #: Call timestamp.
    timestamp: Timestamp
    #: Stack trace captured when the call was made. The async stack chain is automatically reported for
    #: the following call types: ``assert``, ``error``, ``trace``, ``warning``. For other types the async call
    #: chain can be retrieved using ``Debugger.getStackTrace`` and ``stackTrace.parentId`` field.
    stack_trace: StackTrace | None
    #: Console context descriptor for calls on non-default console context (not console.*):
    #: 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call
    #: on named context.
    context: str | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ConsoleAPICalled:
        return cls(
            type_=str(json["type"]),
            args=[RemoteObject.from_json(i) for i in json["args"]],
            execution_context_id=ExecutionContextId.from_json(json["executionContextId"]),
            timestamp=Timestamp.from_json(json["timestamp"]),
            stack_trace=StackTrace.from_json(json["stackTrace"]) if "stackTrace" in json else None,
            context=str(json["context"]) if "context" in json else None,
        )


@event_class("Runtime.exceptionRevoked")
@dataclass
class ExceptionRevoked:
    """
    Issued when unhandled exception was revoked.
    """
    #: Reason describing why exception was revoked.
    reason: str
    #: The id of revoked exception, as reported in ``exceptionThrown``.
    exception_id: int

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ExceptionRevoked:
        return cls(
            reason=str(json["reason"]),
            exception_id=int(json["exceptionId"]),
        )


@event_class("Runtime.exceptionThrown")
@dataclass
class ExceptionThrown:
    """
    Issued when exception was thrown and unhandled.
    """
    #: Timestamp of the exception.
    timestamp: Timestamp
    exception_details: ExceptionDetails

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ExceptionThrown:
        return cls(
            timestamp=Timestamp.from_json(json["timestamp"]),
            exception_details=ExceptionDetails.from_json(json["exceptionDetails"]),
        )


@event_class("Runtime.executionContextCreated")
@dataclass
class ExecutionContextCreated:
    """
    Issued when new execution context is created.
    """
    #: A newly created execution context.
    context: ExecutionContextDescription

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ExecutionContextCreated:
        return cls(
            context=ExecutionContextDescription.from_json(json["context"]),
        )


@event_class("Runtime.executionContextDestroyed")
@dataclass
class ExecutionContextDestroyed:
    """
    Issued when execution context is destroyed.
    """
    #: Id of the destroyed context
    execution_context_id: ExecutionContextId
    #: Unique Id of the destroyed context
    execution_context_unique_id: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ExecutionContextDestroyed:
        return cls(
            execution_context_id=ExecutionContextId.from_json(json["executionContextId"]),
            execution_context_unique_id=str(json["executionContextUniqueId"]),
        )


@event_class("Runtime.executionContextsCleared")
@dataclass
class ExecutionContextsCleared:
    """
    Issued when all executionContexts were cleared in browser
    """


    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ExecutionContextsCleared:
        return cls(

        )


@event_class("Runtime.inspectRequested")
@dataclass
class InspectRequested:
    """
    Issued when object should be inspected (for example, as a result of inspect() command line API
    call).
    """
    object_: RemoteObject
    hints: dict
    #: Identifier of the context where the call was made.
    execution_context_id: ExecutionContextId | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> InspectRequested:
        return cls(
            object_=RemoteObject.from_json(json["object"]),
            hints=dict(json["hints"]),
            execution_context_id=ExecutionContextId.from_json(json["executionContextId"]) if "executionContextId" in json else None,
        )
