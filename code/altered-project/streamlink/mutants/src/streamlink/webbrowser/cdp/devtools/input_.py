# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all modules.
#
# CDP version: v0.0.1438564
# CDP domain: Input

from __future__ import annotations

import enum
from collections.abc import Generator
from dataclasses import dataclass
from typing import Any

from streamlink.webbrowser.cdp.devtools.util import T_JSON_DICT, event_class
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


@dataclass
class TouchPoint:
    #: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    x: float

    #: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
    #: the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    y: float

    #: X radius of the touch area (default: 1.0).
    radius_x: float | None = None

    #: Y radius of the touch area (default: 1.0).
    radius_y: float | None = None

    #: Rotation angle (default: 0.0).
    rotation_angle: float | None = None

    #: Force (default: 1.0).
    force: float | None = None

    #: The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    tangential_pressure: float | None = None

    #: The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)
    tilt_x: float | None = None

    #: The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    tilt_y: float | None = None

    #: The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    twist: int | None = None

    #: Identifier used to track touch sources between events, must be unique within an event.
    id_: float | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["x"] = self.x
        json["y"] = self.y
        if self.radius_x is not None:
            json["radiusX"] = self.radius_x
        if self.radius_y is not None:
            json["radiusY"] = self.radius_y
        if self.rotation_angle is not None:
            json["rotationAngle"] = self.rotation_angle
        if self.force is not None:
            json["force"] = self.force
        if self.tangential_pressure is not None:
            json["tangentialPressure"] = self.tangential_pressure
        if self.tilt_x is not None:
            json["tiltX"] = self.tilt_x
        if self.tilt_y is not None:
            json["tiltY"] = self.tilt_y
        if self.twist is not None:
            json["twist"] = self.twist
        if self.id_ is not None:
            json["id"] = self.id_
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> TouchPoint:
        return cls(
            x=float(json["x"]),
            y=float(json["y"]),
            radius_x=float(json["radiusX"]) if "radiusX" in json else None,
            radius_y=float(json["radiusY"]) if "radiusY" in json else None,
            rotation_angle=float(json["rotationAngle"]) if "rotationAngle" in json else None,
            force=float(json["force"]) if "force" in json else None,
            tangential_pressure=float(json["tangentialPressure"]) if "tangentialPressure" in json else None,
            tilt_x=float(json["tiltX"]) if "tiltX" in json else None,
            tilt_y=float(json["tiltY"]) if "tiltY" in json else None,
            twist=int(json["twist"]) if "twist" in json else None,
            id_=float(json["id"]) if "id" in json else None,
        )


class GestureSourceType(enum.Enum):
    DEFAULT = "default"
    TOUCH = "touch"
    MOUSE = "mouse"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> GestureSourceType:
        return cls(json)


class MouseButton(enum.Enum):
    NONE = "none"
    LEFT = "left"
    MIDDLE = "middle"
    RIGHT = "right"
    BACK = "back"
    FORWARD = "forward"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> MouseButton:
        return cls(json)


class TimeSinceEpoch(float):
    """
    UTC time in seconds, counted from January 1, 1970.
    """
    def to_json(self) -> float:
        return self

    @classmethod
    def from_json(cls, json: float) -> TimeSinceEpoch:
        return cls(json)

    def __repr__(self):
        return f"TimeSinceEpoch({super().__repr__()})"


@dataclass
class DragDataItem:
    #: Mime type of the dragged data.
    mime_type: str

    #: Depending of the value of ``mimeType``, it contains the dragged link,
    #: text, HTML markup or any other data.
    data: str

    #: Title associated with a link. Only valid when ``mimeType`` == "text/uri-list".
    title: str | None = None

    #: Stores the base URL for the contained markup. Only valid when ``mimeType``
    #: == "text/html".
    base_url: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["mimeType"] = self.mime_type
        json["data"] = self.data
        if self.title is not None:
            json["title"] = self.title
        if self.base_url is not None:
            json["baseURL"] = self.base_url
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DragDataItem:
        return cls(
            mime_type=str(json["mimeType"]),
            data=str(json["data"]),
            title=str(json["title"]) if "title" in json else None,
            base_url=str(json["baseURL"]) if "baseURL" in json else None,
        )


@dataclass
class DragData:
    items: list[DragDataItem]

    #: Bit field representing allowed drag operations. Copy = 1, Link = 2, Move = 16
    drag_operations_mask: int

    #: List of filenames that should be included when dropping
    files: list[str] | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["items"] = [i.to_json() for i in self.items]
        json["dragOperationsMask"] = self.drag_operations_mask
        if self.files is not None:
            json["files"] = list(self.files)
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DragData:
        return cls(
            items=[DragDataItem.from_json(i) for i in json["items"]],
            drag_operations_mask=int(json["dragOperationsMask"]),
            files=[str(i) for i in json["files"]] if "files" in json else None,
        )


def x_dispatch_drag_event__mutmut_orig(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_1(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = None
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_2(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = None
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_3(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["XXtypeXX"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_4(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["TYPE"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_5(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["Type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_6(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = None
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_7(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["XXxXX"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_8(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["X"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_9(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["X"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_10(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = None
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_11(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["XXyXX"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_12(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["Y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_13(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["Y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_14(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = None
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_15(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["XXdataXX"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_16(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["DATA"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_17(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["Data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_18(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_19(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_20(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["XXmodifiersXX"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_21(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["MODIFIERS"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_22(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["Modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_23(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_dispatch_drag_event__mutmut_24(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_25(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_26(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.dispatchDragEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_27(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.dispatchDragEventXX",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_28(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "input.dispatchdragevent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_29(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.DISPATCHDRAGEVENT",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_30(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchdragevent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_31(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_32(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "PARAMS": params,
    }
    yield cmd_dict


def x_dispatch_drag_event__mutmut_33(
    type_: str,
    x: float,
    y: float,
    data: DragData,
    modifiers: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a drag event into the page.

    **EXPERIMENTAL**

    :param type_: Type of the drag event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param data:
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["data"] = data.to_json()
    if modifiers is not None:
        params["modifiers"] = modifiers
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchDragEvent",
        "Params": params,
    }
    yield cmd_dict

x_dispatch_drag_event__mutmut_mutants : ClassVar[MutantDict] = {
'x_dispatch_drag_event__mutmut_1': x_dispatch_drag_event__mutmut_1, 
    'x_dispatch_drag_event__mutmut_2': x_dispatch_drag_event__mutmut_2, 
    'x_dispatch_drag_event__mutmut_3': x_dispatch_drag_event__mutmut_3, 
    'x_dispatch_drag_event__mutmut_4': x_dispatch_drag_event__mutmut_4, 
    'x_dispatch_drag_event__mutmut_5': x_dispatch_drag_event__mutmut_5, 
    'x_dispatch_drag_event__mutmut_6': x_dispatch_drag_event__mutmut_6, 
    'x_dispatch_drag_event__mutmut_7': x_dispatch_drag_event__mutmut_7, 
    'x_dispatch_drag_event__mutmut_8': x_dispatch_drag_event__mutmut_8, 
    'x_dispatch_drag_event__mutmut_9': x_dispatch_drag_event__mutmut_9, 
    'x_dispatch_drag_event__mutmut_10': x_dispatch_drag_event__mutmut_10, 
    'x_dispatch_drag_event__mutmut_11': x_dispatch_drag_event__mutmut_11, 
    'x_dispatch_drag_event__mutmut_12': x_dispatch_drag_event__mutmut_12, 
    'x_dispatch_drag_event__mutmut_13': x_dispatch_drag_event__mutmut_13, 
    'x_dispatch_drag_event__mutmut_14': x_dispatch_drag_event__mutmut_14, 
    'x_dispatch_drag_event__mutmut_15': x_dispatch_drag_event__mutmut_15, 
    'x_dispatch_drag_event__mutmut_16': x_dispatch_drag_event__mutmut_16, 
    'x_dispatch_drag_event__mutmut_17': x_dispatch_drag_event__mutmut_17, 
    'x_dispatch_drag_event__mutmut_18': x_dispatch_drag_event__mutmut_18, 
    'x_dispatch_drag_event__mutmut_19': x_dispatch_drag_event__mutmut_19, 
    'x_dispatch_drag_event__mutmut_20': x_dispatch_drag_event__mutmut_20, 
    'x_dispatch_drag_event__mutmut_21': x_dispatch_drag_event__mutmut_21, 
    'x_dispatch_drag_event__mutmut_22': x_dispatch_drag_event__mutmut_22, 
    'x_dispatch_drag_event__mutmut_23': x_dispatch_drag_event__mutmut_23, 
    'x_dispatch_drag_event__mutmut_24': x_dispatch_drag_event__mutmut_24, 
    'x_dispatch_drag_event__mutmut_25': x_dispatch_drag_event__mutmut_25, 
    'x_dispatch_drag_event__mutmut_26': x_dispatch_drag_event__mutmut_26, 
    'x_dispatch_drag_event__mutmut_27': x_dispatch_drag_event__mutmut_27, 
    'x_dispatch_drag_event__mutmut_28': x_dispatch_drag_event__mutmut_28, 
    'x_dispatch_drag_event__mutmut_29': x_dispatch_drag_event__mutmut_29, 
    'x_dispatch_drag_event__mutmut_30': x_dispatch_drag_event__mutmut_30, 
    'x_dispatch_drag_event__mutmut_31': x_dispatch_drag_event__mutmut_31, 
    'x_dispatch_drag_event__mutmut_32': x_dispatch_drag_event__mutmut_32, 
    'x_dispatch_drag_event__mutmut_33': x_dispatch_drag_event__mutmut_33
}

def dispatch_drag_event(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_dispatch_drag_event__mutmut_orig, x_dispatch_drag_event__mutmut_mutants, args, kwargs)
    return result 

dispatch_drag_event.__signature__ = _mutmut_signature(x_dispatch_drag_event__mutmut_orig)
x_dispatch_drag_event__mutmut_orig.__name__ = 'x_dispatch_drag_event'


def x_dispatch_key_event__mutmut_orig(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_1(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = None
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_2(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = None
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_3(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["XXtypeXX"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_4(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["TYPE"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_5(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["Type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_6(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_7(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = None
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_8(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["XXmodifiersXX"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_9(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["MODIFIERS"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_10(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["Modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_11(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_12(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = None
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_13(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["XXtimestampXX"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_14(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["TIMESTAMP"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_15(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["Timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_16(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_17(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = None
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_18(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["XXtextXX"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_19(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["TEXT"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_20(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["Text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_21(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_22(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = None
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_23(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["XXunmodifiedTextXX"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_24(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedtext"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_25(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["UNMODIFIEDTEXT"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_26(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["Unmodifiedtext"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_27(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_28(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = None
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_29(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["XXkeyIdentifierXX"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_30(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyidentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_31(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["KEYIDENTIFIER"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_32(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["Keyidentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_33(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_34(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = None
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_35(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["XXcodeXX"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_36(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["CODE"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_37(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["Code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_38(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_39(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = None
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_40(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["XXkeyXX"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_41(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["KEY"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_42(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["Key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_43(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_44(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = None
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_45(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["XXwindowsVirtualKeyCodeXX"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_46(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsvirtualkeycode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_47(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["WINDOWSVIRTUALKEYCODE"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_48(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["Windowsvirtualkeycode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_49(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_50(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = None
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_51(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["XXnativeVirtualKeyCodeXX"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_52(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativevirtualkeycode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_53(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["NATIVEVIRTUALKEYCODE"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_54(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["Nativevirtualkeycode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_55(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_56(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = None
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_57(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["XXautoRepeatXX"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_58(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autorepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_59(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["AUTOREPEAT"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_60(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["Autorepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_61(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_62(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = None
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_63(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["XXisKeypadXX"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_64(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["iskeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_65(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["ISKEYPAD"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_66(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["Iskeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_67(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_68(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = None
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_69(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["XXisSystemKeyXX"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_70(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["issystemkey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_71(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["ISSYSTEMKEY"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_72(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["Issystemkey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_73(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_74(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = None
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_75(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["XXlocationXX"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_76(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["LOCATION"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_77(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["Location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_78(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_79(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_80(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["XXcommandsXX"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_81(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["COMMANDS"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_82(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["Commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_83(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(None)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_84(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_dispatch_key_event__mutmut_85(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_86(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_87(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.dispatchKeyEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_88(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.dispatchKeyEventXX",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_89(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "input.dispatchkeyevent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_90(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.DISPATCHKEYEVENT",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_91(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchkeyevent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_92(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_93(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "PARAMS": params,
    }
    yield cmd_dict


def x_dispatch_key_event__mutmut_94(
    type_: str,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    text: str | None = None,
    unmodified_text: str | None = None,
    key_identifier: str | None = None,
    code: str | None = None,
    key: str | None = None,
    windows_virtual_key_code: int | None = None,
    native_virtual_key_code: int | None = None,
    auto_repeat: bool | None = None,
    is_keypad: bool | None = None,
    is_system_key: bool | None = None,
    location: int | None = None,
    commands: list[str] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a key event to the page.

    :param type_: Type of the key event.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param text: *(Optional)* Text as generated by processing a virtual key code with a keyboard layout. Not needed for for ```keyUp```` and ````rawKeyDown```` events (default: "")
    :param unmodified_text: *(Optional)* Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
    :param key_identifier: *(Optional)* Unique key identifier (e.g., 'U+0041') (default: "").
    :param code: *(Optional)* Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    :param key: *(Optional)* Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    :param windows_virtual_key_code: *(Optional)* Windows virtual key code (default: 0).
    :param native_virtual_key_code: *(Optional)* Native virtual key code (default: 0).
    :param auto_repeat: *(Optional)* Whether the event was generated from auto repeat (default: false).
    :param is_keypad: *(Optional)* Whether the event was generated from the keypad (default: false).
    :param is_system_key: *(Optional)* Whether the event was a system key event (default: false).
    :param location: *(Optional)* Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
    :param commands: **(EXPERIMENTAL)** *(Optional)* Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in ````document.execCommand``` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if text is not None:
        params["text"] = text
    if unmodified_text is not None:
        params["unmodifiedText"] = unmodified_text
    if key_identifier is not None:
        params["keyIdentifier"] = key_identifier
    if code is not None:
        params["code"] = code
    if key is not None:
        params["key"] = key
    if windows_virtual_key_code is not None:
        params["windowsVirtualKeyCode"] = windows_virtual_key_code
    if native_virtual_key_code is not None:
        params["nativeVirtualKeyCode"] = native_virtual_key_code
    if auto_repeat is not None:
        params["autoRepeat"] = auto_repeat
    if is_keypad is not None:
        params["isKeypad"] = is_keypad
    if is_system_key is not None:
        params["isSystemKey"] = is_system_key
    if location is not None:
        params["location"] = location
    if commands is not None:
        params["commands"] = list(commands)
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchKeyEvent",
        "Params": params,
    }
    yield cmd_dict

x_dispatch_key_event__mutmut_mutants : ClassVar[MutantDict] = {
'x_dispatch_key_event__mutmut_1': x_dispatch_key_event__mutmut_1, 
    'x_dispatch_key_event__mutmut_2': x_dispatch_key_event__mutmut_2, 
    'x_dispatch_key_event__mutmut_3': x_dispatch_key_event__mutmut_3, 
    'x_dispatch_key_event__mutmut_4': x_dispatch_key_event__mutmut_4, 
    'x_dispatch_key_event__mutmut_5': x_dispatch_key_event__mutmut_5, 
    'x_dispatch_key_event__mutmut_6': x_dispatch_key_event__mutmut_6, 
    'x_dispatch_key_event__mutmut_7': x_dispatch_key_event__mutmut_7, 
    'x_dispatch_key_event__mutmut_8': x_dispatch_key_event__mutmut_8, 
    'x_dispatch_key_event__mutmut_9': x_dispatch_key_event__mutmut_9, 
    'x_dispatch_key_event__mutmut_10': x_dispatch_key_event__mutmut_10, 
    'x_dispatch_key_event__mutmut_11': x_dispatch_key_event__mutmut_11, 
    'x_dispatch_key_event__mutmut_12': x_dispatch_key_event__mutmut_12, 
    'x_dispatch_key_event__mutmut_13': x_dispatch_key_event__mutmut_13, 
    'x_dispatch_key_event__mutmut_14': x_dispatch_key_event__mutmut_14, 
    'x_dispatch_key_event__mutmut_15': x_dispatch_key_event__mutmut_15, 
    'x_dispatch_key_event__mutmut_16': x_dispatch_key_event__mutmut_16, 
    'x_dispatch_key_event__mutmut_17': x_dispatch_key_event__mutmut_17, 
    'x_dispatch_key_event__mutmut_18': x_dispatch_key_event__mutmut_18, 
    'x_dispatch_key_event__mutmut_19': x_dispatch_key_event__mutmut_19, 
    'x_dispatch_key_event__mutmut_20': x_dispatch_key_event__mutmut_20, 
    'x_dispatch_key_event__mutmut_21': x_dispatch_key_event__mutmut_21, 
    'x_dispatch_key_event__mutmut_22': x_dispatch_key_event__mutmut_22, 
    'x_dispatch_key_event__mutmut_23': x_dispatch_key_event__mutmut_23, 
    'x_dispatch_key_event__mutmut_24': x_dispatch_key_event__mutmut_24, 
    'x_dispatch_key_event__mutmut_25': x_dispatch_key_event__mutmut_25, 
    'x_dispatch_key_event__mutmut_26': x_dispatch_key_event__mutmut_26, 
    'x_dispatch_key_event__mutmut_27': x_dispatch_key_event__mutmut_27, 
    'x_dispatch_key_event__mutmut_28': x_dispatch_key_event__mutmut_28, 
    'x_dispatch_key_event__mutmut_29': x_dispatch_key_event__mutmut_29, 
    'x_dispatch_key_event__mutmut_30': x_dispatch_key_event__mutmut_30, 
    'x_dispatch_key_event__mutmut_31': x_dispatch_key_event__mutmut_31, 
    'x_dispatch_key_event__mutmut_32': x_dispatch_key_event__mutmut_32, 
    'x_dispatch_key_event__mutmut_33': x_dispatch_key_event__mutmut_33, 
    'x_dispatch_key_event__mutmut_34': x_dispatch_key_event__mutmut_34, 
    'x_dispatch_key_event__mutmut_35': x_dispatch_key_event__mutmut_35, 
    'x_dispatch_key_event__mutmut_36': x_dispatch_key_event__mutmut_36, 
    'x_dispatch_key_event__mutmut_37': x_dispatch_key_event__mutmut_37, 
    'x_dispatch_key_event__mutmut_38': x_dispatch_key_event__mutmut_38, 
    'x_dispatch_key_event__mutmut_39': x_dispatch_key_event__mutmut_39, 
    'x_dispatch_key_event__mutmut_40': x_dispatch_key_event__mutmut_40, 
    'x_dispatch_key_event__mutmut_41': x_dispatch_key_event__mutmut_41, 
    'x_dispatch_key_event__mutmut_42': x_dispatch_key_event__mutmut_42, 
    'x_dispatch_key_event__mutmut_43': x_dispatch_key_event__mutmut_43, 
    'x_dispatch_key_event__mutmut_44': x_dispatch_key_event__mutmut_44, 
    'x_dispatch_key_event__mutmut_45': x_dispatch_key_event__mutmut_45, 
    'x_dispatch_key_event__mutmut_46': x_dispatch_key_event__mutmut_46, 
    'x_dispatch_key_event__mutmut_47': x_dispatch_key_event__mutmut_47, 
    'x_dispatch_key_event__mutmut_48': x_dispatch_key_event__mutmut_48, 
    'x_dispatch_key_event__mutmut_49': x_dispatch_key_event__mutmut_49, 
    'x_dispatch_key_event__mutmut_50': x_dispatch_key_event__mutmut_50, 
    'x_dispatch_key_event__mutmut_51': x_dispatch_key_event__mutmut_51, 
    'x_dispatch_key_event__mutmut_52': x_dispatch_key_event__mutmut_52, 
    'x_dispatch_key_event__mutmut_53': x_dispatch_key_event__mutmut_53, 
    'x_dispatch_key_event__mutmut_54': x_dispatch_key_event__mutmut_54, 
    'x_dispatch_key_event__mutmut_55': x_dispatch_key_event__mutmut_55, 
    'x_dispatch_key_event__mutmut_56': x_dispatch_key_event__mutmut_56, 
    'x_dispatch_key_event__mutmut_57': x_dispatch_key_event__mutmut_57, 
    'x_dispatch_key_event__mutmut_58': x_dispatch_key_event__mutmut_58, 
    'x_dispatch_key_event__mutmut_59': x_dispatch_key_event__mutmut_59, 
    'x_dispatch_key_event__mutmut_60': x_dispatch_key_event__mutmut_60, 
    'x_dispatch_key_event__mutmut_61': x_dispatch_key_event__mutmut_61, 
    'x_dispatch_key_event__mutmut_62': x_dispatch_key_event__mutmut_62, 
    'x_dispatch_key_event__mutmut_63': x_dispatch_key_event__mutmut_63, 
    'x_dispatch_key_event__mutmut_64': x_dispatch_key_event__mutmut_64, 
    'x_dispatch_key_event__mutmut_65': x_dispatch_key_event__mutmut_65, 
    'x_dispatch_key_event__mutmut_66': x_dispatch_key_event__mutmut_66, 
    'x_dispatch_key_event__mutmut_67': x_dispatch_key_event__mutmut_67, 
    'x_dispatch_key_event__mutmut_68': x_dispatch_key_event__mutmut_68, 
    'x_dispatch_key_event__mutmut_69': x_dispatch_key_event__mutmut_69, 
    'x_dispatch_key_event__mutmut_70': x_dispatch_key_event__mutmut_70, 
    'x_dispatch_key_event__mutmut_71': x_dispatch_key_event__mutmut_71, 
    'x_dispatch_key_event__mutmut_72': x_dispatch_key_event__mutmut_72, 
    'x_dispatch_key_event__mutmut_73': x_dispatch_key_event__mutmut_73, 
    'x_dispatch_key_event__mutmut_74': x_dispatch_key_event__mutmut_74, 
    'x_dispatch_key_event__mutmut_75': x_dispatch_key_event__mutmut_75, 
    'x_dispatch_key_event__mutmut_76': x_dispatch_key_event__mutmut_76, 
    'x_dispatch_key_event__mutmut_77': x_dispatch_key_event__mutmut_77, 
    'x_dispatch_key_event__mutmut_78': x_dispatch_key_event__mutmut_78, 
    'x_dispatch_key_event__mutmut_79': x_dispatch_key_event__mutmut_79, 
    'x_dispatch_key_event__mutmut_80': x_dispatch_key_event__mutmut_80, 
    'x_dispatch_key_event__mutmut_81': x_dispatch_key_event__mutmut_81, 
    'x_dispatch_key_event__mutmut_82': x_dispatch_key_event__mutmut_82, 
    'x_dispatch_key_event__mutmut_83': x_dispatch_key_event__mutmut_83, 
    'x_dispatch_key_event__mutmut_84': x_dispatch_key_event__mutmut_84, 
    'x_dispatch_key_event__mutmut_85': x_dispatch_key_event__mutmut_85, 
    'x_dispatch_key_event__mutmut_86': x_dispatch_key_event__mutmut_86, 
    'x_dispatch_key_event__mutmut_87': x_dispatch_key_event__mutmut_87, 
    'x_dispatch_key_event__mutmut_88': x_dispatch_key_event__mutmut_88, 
    'x_dispatch_key_event__mutmut_89': x_dispatch_key_event__mutmut_89, 
    'x_dispatch_key_event__mutmut_90': x_dispatch_key_event__mutmut_90, 
    'x_dispatch_key_event__mutmut_91': x_dispatch_key_event__mutmut_91, 
    'x_dispatch_key_event__mutmut_92': x_dispatch_key_event__mutmut_92, 
    'x_dispatch_key_event__mutmut_93': x_dispatch_key_event__mutmut_93, 
    'x_dispatch_key_event__mutmut_94': x_dispatch_key_event__mutmut_94
}

def dispatch_key_event(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_dispatch_key_event__mutmut_orig, x_dispatch_key_event__mutmut_mutants, args, kwargs)
    return result 

dispatch_key_event.__signature__ = _mutmut_signature(x_dispatch_key_event__mutmut_orig)
x_dispatch_key_event__mutmut_orig.__name__ = 'x_dispatch_key_event'


def x_insert_text__mutmut_orig(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "Input.insertText",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_1(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = None
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "Input.insertText",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_2(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.insertText",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_3(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["XXtextXX"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "Input.insertText",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_4(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["TEXT"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "Input.insertText",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_5(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["Text"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "Input.insertText",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_6(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_insert_text__mutmut_7(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.insertText",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_8(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.insertText",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_9(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.insertText",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_10(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.insertTextXX",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_11(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "input.inserttext",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_12(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.INSERTTEXT",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_13(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "Input.inserttext",
        "params": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_14(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "Input.insertText",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_15(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "Input.insertText",
        "PARAMS": params,
    }
    yield cmd_dict


def x_insert_text__mutmut_16(
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method emulates inserting text that doesn't come from a key press,
    for example an emoji keyboard or an IME.

    **EXPERIMENTAL**

    :param text: The text to insert.
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    cmd_dict: T_JSON_DICT = {
        "method": "Input.insertText",
        "Params": params,
    }
    yield cmd_dict

x_insert_text__mutmut_mutants : ClassVar[MutantDict] = {
'x_insert_text__mutmut_1': x_insert_text__mutmut_1, 
    'x_insert_text__mutmut_2': x_insert_text__mutmut_2, 
    'x_insert_text__mutmut_3': x_insert_text__mutmut_3, 
    'x_insert_text__mutmut_4': x_insert_text__mutmut_4, 
    'x_insert_text__mutmut_5': x_insert_text__mutmut_5, 
    'x_insert_text__mutmut_6': x_insert_text__mutmut_6, 
    'x_insert_text__mutmut_7': x_insert_text__mutmut_7, 
    'x_insert_text__mutmut_8': x_insert_text__mutmut_8, 
    'x_insert_text__mutmut_9': x_insert_text__mutmut_9, 
    'x_insert_text__mutmut_10': x_insert_text__mutmut_10, 
    'x_insert_text__mutmut_11': x_insert_text__mutmut_11, 
    'x_insert_text__mutmut_12': x_insert_text__mutmut_12, 
    'x_insert_text__mutmut_13': x_insert_text__mutmut_13, 
    'x_insert_text__mutmut_14': x_insert_text__mutmut_14, 
    'x_insert_text__mutmut_15': x_insert_text__mutmut_15, 
    'x_insert_text__mutmut_16': x_insert_text__mutmut_16
}

def insert_text(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_insert_text__mutmut_orig, x_insert_text__mutmut_mutants, args, kwargs)
    return result 

insert_text.__signature__ = _mutmut_signature(x_insert_text__mutmut_orig)
x_insert_text__mutmut_orig.__name__ = 'x_insert_text'


def x_ime_set_composition__mutmut_orig(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_1(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = None
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_2(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = None
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_3(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["XXtextXX"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_4(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["TEXT"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_5(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["Text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_6(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = None
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_7(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["XXselectionStartXX"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_8(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionstart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_9(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["SELECTIONSTART"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_10(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["Selectionstart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_11(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = None
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_12(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["XXselectionEndXX"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_13(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionend"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_14(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["SELECTIONEND"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_15(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["Selectionend"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_16(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_17(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = None
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_18(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["XXreplacementStartXX"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_19(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementstart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_20(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["REPLACEMENTSTART"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_21(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["Replacementstart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_22(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_23(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_24(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["XXreplacementEndXX"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_25(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementend"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_26(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["REPLACEMENTEND"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_27(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["Replacementend"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_28(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_ime_set_composition__mutmut_29(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_30(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_31(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.imeSetComposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_32(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.imeSetCompositionXX",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_33(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "input.imesetcomposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_34(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.IMESETCOMPOSITION",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_35(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imesetcomposition",
        "params": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_36(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_37(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "PARAMS": params,
    }
    yield cmd_dict


def x_ime_set_composition__mutmut_38(
    text: str,
    selection_start: int,
    selection_end: int,
    replacement_start: int | None = None,
    replacement_end: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    This method sets the current candidate text for IME.
    Use imeCommitComposition to commit the final text.
    Use imeSetComposition with empty string as text to cancel composition.

    **EXPERIMENTAL**

    :param text: The text to insert
    :param selection_start: selection start
    :param selection_end: selection end
    :param replacement_start: *(Optional)* replacement start
    :param replacement_end: *(Optional)* replacement end
    """
    params: T_JSON_DICT = {}
    params["text"] = text
    params["selectionStart"] = selection_start
    params["selectionEnd"] = selection_end
    if replacement_start is not None:
        params["replacementStart"] = replacement_start
    if replacement_end is not None:
        params["replacementEnd"] = replacement_end
    cmd_dict: T_JSON_DICT = {
        "method": "Input.imeSetComposition",
        "Params": params,
    }
    yield cmd_dict

x_ime_set_composition__mutmut_mutants : ClassVar[MutantDict] = {
'x_ime_set_composition__mutmut_1': x_ime_set_composition__mutmut_1, 
    'x_ime_set_composition__mutmut_2': x_ime_set_composition__mutmut_2, 
    'x_ime_set_composition__mutmut_3': x_ime_set_composition__mutmut_3, 
    'x_ime_set_composition__mutmut_4': x_ime_set_composition__mutmut_4, 
    'x_ime_set_composition__mutmut_5': x_ime_set_composition__mutmut_5, 
    'x_ime_set_composition__mutmut_6': x_ime_set_composition__mutmut_6, 
    'x_ime_set_composition__mutmut_7': x_ime_set_composition__mutmut_7, 
    'x_ime_set_composition__mutmut_8': x_ime_set_composition__mutmut_8, 
    'x_ime_set_composition__mutmut_9': x_ime_set_composition__mutmut_9, 
    'x_ime_set_composition__mutmut_10': x_ime_set_composition__mutmut_10, 
    'x_ime_set_composition__mutmut_11': x_ime_set_composition__mutmut_11, 
    'x_ime_set_composition__mutmut_12': x_ime_set_composition__mutmut_12, 
    'x_ime_set_composition__mutmut_13': x_ime_set_composition__mutmut_13, 
    'x_ime_set_composition__mutmut_14': x_ime_set_composition__mutmut_14, 
    'x_ime_set_composition__mutmut_15': x_ime_set_composition__mutmut_15, 
    'x_ime_set_composition__mutmut_16': x_ime_set_composition__mutmut_16, 
    'x_ime_set_composition__mutmut_17': x_ime_set_composition__mutmut_17, 
    'x_ime_set_composition__mutmut_18': x_ime_set_composition__mutmut_18, 
    'x_ime_set_composition__mutmut_19': x_ime_set_composition__mutmut_19, 
    'x_ime_set_composition__mutmut_20': x_ime_set_composition__mutmut_20, 
    'x_ime_set_composition__mutmut_21': x_ime_set_composition__mutmut_21, 
    'x_ime_set_composition__mutmut_22': x_ime_set_composition__mutmut_22, 
    'x_ime_set_composition__mutmut_23': x_ime_set_composition__mutmut_23, 
    'x_ime_set_composition__mutmut_24': x_ime_set_composition__mutmut_24, 
    'x_ime_set_composition__mutmut_25': x_ime_set_composition__mutmut_25, 
    'x_ime_set_composition__mutmut_26': x_ime_set_composition__mutmut_26, 
    'x_ime_set_composition__mutmut_27': x_ime_set_composition__mutmut_27, 
    'x_ime_set_composition__mutmut_28': x_ime_set_composition__mutmut_28, 
    'x_ime_set_composition__mutmut_29': x_ime_set_composition__mutmut_29, 
    'x_ime_set_composition__mutmut_30': x_ime_set_composition__mutmut_30, 
    'x_ime_set_composition__mutmut_31': x_ime_set_composition__mutmut_31, 
    'x_ime_set_composition__mutmut_32': x_ime_set_composition__mutmut_32, 
    'x_ime_set_composition__mutmut_33': x_ime_set_composition__mutmut_33, 
    'x_ime_set_composition__mutmut_34': x_ime_set_composition__mutmut_34, 
    'x_ime_set_composition__mutmut_35': x_ime_set_composition__mutmut_35, 
    'x_ime_set_composition__mutmut_36': x_ime_set_composition__mutmut_36, 
    'x_ime_set_composition__mutmut_37': x_ime_set_composition__mutmut_37, 
    'x_ime_set_composition__mutmut_38': x_ime_set_composition__mutmut_38
}

def ime_set_composition(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_ime_set_composition__mutmut_orig, x_ime_set_composition__mutmut_mutants, args, kwargs)
    return result 

ime_set_composition.__signature__ = _mutmut_signature(x_ime_set_composition__mutmut_orig)
x_ime_set_composition__mutmut_orig.__name__ = 'x_ime_set_composition'


def x_dispatch_mouse_event__mutmut_orig(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_1(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = None
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_2(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = None
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_3(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["XXtypeXX"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_4(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["TYPE"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_5(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["Type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_6(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = None
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_7(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["XXxXX"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_8(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["X"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_9(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["X"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_10(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = None
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_11(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["XXyXX"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_12(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["Y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_13(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["Y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_14(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_15(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = None
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_16(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["XXmodifiersXX"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_17(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["MODIFIERS"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_18(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["Modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_19(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_20(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = None
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_21(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["XXtimestampXX"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_22(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["TIMESTAMP"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_23(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["Timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_24(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_25(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = None
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_26(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["XXbuttonXX"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_27(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["BUTTON"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_28(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["Button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_29(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_30(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = None
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_31(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["XXbuttonsXX"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_32(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["BUTTONS"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_33(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["Buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_34(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_35(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = None
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_36(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["XXclickCountXX"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_37(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickcount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_38(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["CLICKCOUNT"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_39(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["Clickcount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_40(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_41(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = None
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_42(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["XXforceXX"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_43(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["FORCE"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_44(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["Force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_45(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_46(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = None
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_47(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["XXtangentialPressureXX"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_48(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialpressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_49(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["TANGENTIALPRESSURE"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_50(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["Tangentialpressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_51(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_52(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = None
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_53(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["XXtiltXXX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_54(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltx"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_55(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["TILTX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_56(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["Tiltx"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_57(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_58(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = None
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_59(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["XXtiltYXX"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_60(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tilty"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_61(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["TILTY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_62(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["Tilty"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_63(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_64(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = None
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_65(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["XXtwistXX"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_66(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["TWIST"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_67(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["Twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_68(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_69(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = None
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_70(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["XXdeltaXXX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_71(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltax"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_72(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["DELTAX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_73(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["Deltax"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_74(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_75(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = None
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_76(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["XXdeltaYXX"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_77(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltay"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_78(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["DELTAY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_79(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["Deltay"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_80(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_81(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_82(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["XXpointerTypeXX"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_83(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointertype"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_84(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["POINTERTYPE"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_85(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["Pointertype"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_86(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_87(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_88(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_89(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.dispatchMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_90(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.dispatchMouseEventXX",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_91(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "input.dispatchmouseevent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_92(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.DISPATCHMOUSEEVENT",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_93(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchmouseevent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_94(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_95(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "PARAMS": params,
    }
    yield cmd_dict


def x_dispatch_mouse_event__mutmut_96(
    type_: str,
    x: float,
    y: float,
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
    button: MouseButton | None = None,
    buttons: int | None = None,
    click_count: int | None = None,
    force: float | None = None,
    tangential_pressure: float | None = None,
    tilt_x: float | None = None,
    tilt_y: float | None = None,
    twist: int | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    pointer_type: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a mouse event to the page.

    :param type_: Type of the mouse event.
    :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
    :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    :param button: *(Optional)* Mouse button (default: "none").
    :param buttons: *(Optional)* A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    :param force: **(EXPERIMENTAL)** *(Optional)* The normalized pressure, which has a range of [0,1] (default: 0).
    :param tangential_pressure: **(EXPERIMENTAL)** *(Optional)* The normalized tangential pressure, which has a range of [-1,1] (default: 0).
    :param tilt_x: *(Optional)* The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
    :param tilt_y: *(Optional)* The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
    :param twist: **(EXPERIMENTAL)** *(Optional)* The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
    :param delta_x: *(Optional)* X delta in CSS pixels for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in CSS pixels for mouse wheel event (default: 0).
    :param pointer_type: *(Optional)* Pointer type (default: "mouse").
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if button is not None:
        params["button"] = button.to_json()
    if buttons is not None:
        params["buttons"] = buttons
    if click_count is not None:
        params["clickCount"] = click_count
    if force is not None:
        params["force"] = force
    if tangential_pressure is not None:
        params["tangentialPressure"] = tangential_pressure
    if tilt_x is not None:
        params["tiltX"] = tilt_x
    if tilt_y is not None:
        params["tiltY"] = tilt_y
    if twist is not None:
        params["twist"] = twist
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if pointer_type is not None:
        params["pointerType"] = pointer_type
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchMouseEvent",
        "Params": params,
    }
    yield cmd_dict

x_dispatch_mouse_event__mutmut_mutants : ClassVar[MutantDict] = {
'x_dispatch_mouse_event__mutmut_1': x_dispatch_mouse_event__mutmut_1, 
    'x_dispatch_mouse_event__mutmut_2': x_dispatch_mouse_event__mutmut_2, 
    'x_dispatch_mouse_event__mutmut_3': x_dispatch_mouse_event__mutmut_3, 
    'x_dispatch_mouse_event__mutmut_4': x_dispatch_mouse_event__mutmut_4, 
    'x_dispatch_mouse_event__mutmut_5': x_dispatch_mouse_event__mutmut_5, 
    'x_dispatch_mouse_event__mutmut_6': x_dispatch_mouse_event__mutmut_6, 
    'x_dispatch_mouse_event__mutmut_7': x_dispatch_mouse_event__mutmut_7, 
    'x_dispatch_mouse_event__mutmut_8': x_dispatch_mouse_event__mutmut_8, 
    'x_dispatch_mouse_event__mutmut_9': x_dispatch_mouse_event__mutmut_9, 
    'x_dispatch_mouse_event__mutmut_10': x_dispatch_mouse_event__mutmut_10, 
    'x_dispatch_mouse_event__mutmut_11': x_dispatch_mouse_event__mutmut_11, 
    'x_dispatch_mouse_event__mutmut_12': x_dispatch_mouse_event__mutmut_12, 
    'x_dispatch_mouse_event__mutmut_13': x_dispatch_mouse_event__mutmut_13, 
    'x_dispatch_mouse_event__mutmut_14': x_dispatch_mouse_event__mutmut_14, 
    'x_dispatch_mouse_event__mutmut_15': x_dispatch_mouse_event__mutmut_15, 
    'x_dispatch_mouse_event__mutmut_16': x_dispatch_mouse_event__mutmut_16, 
    'x_dispatch_mouse_event__mutmut_17': x_dispatch_mouse_event__mutmut_17, 
    'x_dispatch_mouse_event__mutmut_18': x_dispatch_mouse_event__mutmut_18, 
    'x_dispatch_mouse_event__mutmut_19': x_dispatch_mouse_event__mutmut_19, 
    'x_dispatch_mouse_event__mutmut_20': x_dispatch_mouse_event__mutmut_20, 
    'x_dispatch_mouse_event__mutmut_21': x_dispatch_mouse_event__mutmut_21, 
    'x_dispatch_mouse_event__mutmut_22': x_dispatch_mouse_event__mutmut_22, 
    'x_dispatch_mouse_event__mutmut_23': x_dispatch_mouse_event__mutmut_23, 
    'x_dispatch_mouse_event__mutmut_24': x_dispatch_mouse_event__mutmut_24, 
    'x_dispatch_mouse_event__mutmut_25': x_dispatch_mouse_event__mutmut_25, 
    'x_dispatch_mouse_event__mutmut_26': x_dispatch_mouse_event__mutmut_26, 
    'x_dispatch_mouse_event__mutmut_27': x_dispatch_mouse_event__mutmut_27, 
    'x_dispatch_mouse_event__mutmut_28': x_dispatch_mouse_event__mutmut_28, 
    'x_dispatch_mouse_event__mutmut_29': x_dispatch_mouse_event__mutmut_29, 
    'x_dispatch_mouse_event__mutmut_30': x_dispatch_mouse_event__mutmut_30, 
    'x_dispatch_mouse_event__mutmut_31': x_dispatch_mouse_event__mutmut_31, 
    'x_dispatch_mouse_event__mutmut_32': x_dispatch_mouse_event__mutmut_32, 
    'x_dispatch_mouse_event__mutmut_33': x_dispatch_mouse_event__mutmut_33, 
    'x_dispatch_mouse_event__mutmut_34': x_dispatch_mouse_event__mutmut_34, 
    'x_dispatch_mouse_event__mutmut_35': x_dispatch_mouse_event__mutmut_35, 
    'x_dispatch_mouse_event__mutmut_36': x_dispatch_mouse_event__mutmut_36, 
    'x_dispatch_mouse_event__mutmut_37': x_dispatch_mouse_event__mutmut_37, 
    'x_dispatch_mouse_event__mutmut_38': x_dispatch_mouse_event__mutmut_38, 
    'x_dispatch_mouse_event__mutmut_39': x_dispatch_mouse_event__mutmut_39, 
    'x_dispatch_mouse_event__mutmut_40': x_dispatch_mouse_event__mutmut_40, 
    'x_dispatch_mouse_event__mutmut_41': x_dispatch_mouse_event__mutmut_41, 
    'x_dispatch_mouse_event__mutmut_42': x_dispatch_mouse_event__mutmut_42, 
    'x_dispatch_mouse_event__mutmut_43': x_dispatch_mouse_event__mutmut_43, 
    'x_dispatch_mouse_event__mutmut_44': x_dispatch_mouse_event__mutmut_44, 
    'x_dispatch_mouse_event__mutmut_45': x_dispatch_mouse_event__mutmut_45, 
    'x_dispatch_mouse_event__mutmut_46': x_dispatch_mouse_event__mutmut_46, 
    'x_dispatch_mouse_event__mutmut_47': x_dispatch_mouse_event__mutmut_47, 
    'x_dispatch_mouse_event__mutmut_48': x_dispatch_mouse_event__mutmut_48, 
    'x_dispatch_mouse_event__mutmut_49': x_dispatch_mouse_event__mutmut_49, 
    'x_dispatch_mouse_event__mutmut_50': x_dispatch_mouse_event__mutmut_50, 
    'x_dispatch_mouse_event__mutmut_51': x_dispatch_mouse_event__mutmut_51, 
    'x_dispatch_mouse_event__mutmut_52': x_dispatch_mouse_event__mutmut_52, 
    'x_dispatch_mouse_event__mutmut_53': x_dispatch_mouse_event__mutmut_53, 
    'x_dispatch_mouse_event__mutmut_54': x_dispatch_mouse_event__mutmut_54, 
    'x_dispatch_mouse_event__mutmut_55': x_dispatch_mouse_event__mutmut_55, 
    'x_dispatch_mouse_event__mutmut_56': x_dispatch_mouse_event__mutmut_56, 
    'x_dispatch_mouse_event__mutmut_57': x_dispatch_mouse_event__mutmut_57, 
    'x_dispatch_mouse_event__mutmut_58': x_dispatch_mouse_event__mutmut_58, 
    'x_dispatch_mouse_event__mutmut_59': x_dispatch_mouse_event__mutmut_59, 
    'x_dispatch_mouse_event__mutmut_60': x_dispatch_mouse_event__mutmut_60, 
    'x_dispatch_mouse_event__mutmut_61': x_dispatch_mouse_event__mutmut_61, 
    'x_dispatch_mouse_event__mutmut_62': x_dispatch_mouse_event__mutmut_62, 
    'x_dispatch_mouse_event__mutmut_63': x_dispatch_mouse_event__mutmut_63, 
    'x_dispatch_mouse_event__mutmut_64': x_dispatch_mouse_event__mutmut_64, 
    'x_dispatch_mouse_event__mutmut_65': x_dispatch_mouse_event__mutmut_65, 
    'x_dispatch_mouse_event__mutmut_66': x_dispatch_mouse_event__mutmut_66, 
    'x_dispatch_mouse_event__mutmut_67': x_dispatch_mouse_event__mutmut_67, 
    'x_dispatch_mouse_event__mutmut_68': x_dispatch_mouse_event__mutmut_68, 
    'x_dispatch_mouse_event__mutmut_69': x_dispatch_mouse_event__mutmut_69, 
    'x_dispatch_mouse_event__mutmut_70': x_dispatch_mouse_event__mutmut_70, 
    'x_dispatch_mouse_event__mutmut_71': x_dispatch_mouse_event__mutmut_71, 
    'x_dispatch_mouse_event__mutmut_72': x_dispatch_mouse_event__mutmut_72, 
    'x_dispatch_mouse_event__mutmut_73': x_dispatch_mouse_event__mutmut_73, 
    'x_dispatch_mouse_event__mutmut_74': x_dispatch_mouse_event__mutmut_74, 
    'x_dispatch_mouse_event__mutmut_75': x_dispatch_mouse_event__mutmut_75, 
    'x_dispatch_mouse_event__mutmut_76': x_dispatch_mouse_event__mutmut_76, 
    'x_dispatch_mouse_event__mutmut_77': x_dispatch_mouse_event__mutmut_77, 
    'x_dispatch_mouse_event__mutmut_78': x_dispatch_mouse_event__mutmut_78, 
    'x_dispatch_mouse_event__mutmut_79': x_dispatch_mouse_event__mutmut_79, 
    'x_dispatch_mouse_event__mutmut_80': x_dispatch_mouse_event__mutmut_80, 
    'x_dispatch_mouse_event__mutmut_81': x_dispatch_mouse_event__mutmut_81, 
    'x_dispatch_mouse_event__mutmut_82': x_dispatch_mouse_event__mutmut_82, 
    'x_dispatch_mouse_event__mutmut_83': x_dispatch_mouse_event__mutmut_83, 
    'x_dispatch_mouse_event__mutmut_84': x_dispatch_mouse_event__mutmut_84, 
    'x_dispatch_mouse_event__mutmut_85': x_dispatch_mouse_event__mutmut_85, 
    'x_dispatch_mouse_event__mutmut_86': x_dispatch_mouse_event__mutmut_86, 
    'x_dispatch_mouse_event__mutmut_87': x_dispatch_mouse_event__mutmut_87, 
    'x_dispatch_mouse_event__mutmut_88': x_dispatch_mouse_event__mutmut_88, 
    'x_dispatch_mouse_event__mutmut_89': x_dispatch_mouse_event__mutmut_89, 
    'x_dispatch_mouse_event__mutmut_90': x_dispatch_mouse_event__mutmut_90, 
    'x_dispatch_mouse_event__mutmut_91': x_dispatch_mouse_event__mutmut_91, 
    'x_dispatch_mouse_event__mutmut_92': x_dispatch_mouse_event__mutmut_92, 
    'x_dispatch_mouse_event__mutmut_93': x_dispatch_mouse_event__mutmut_93, 
    'x_dispatch_mouse_event__mutmut_94': x_dispatch_mouse_event__mutmut_94, 
    'x_dispatch_mouse_event__mutmut_95': x_dispatch_mouse_event__mutmut_95, 
    'x_dispatch_mouse_event__mutmut_96': x_dispatch_mouse_event__mutmut_96
}

def dispatch_mouse_event(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_dispatch_mouse_event__mutmut_orig, x_dispatch_mouse_event__mutmut_mutants, args, kwargs)
    return result 

dispatch_mouse_event.__signature__ = _mutmut_signature(x_dispatch_mouse_event__mutmut_orig)
x_dispatch_mouse_event__mutmut_orig.__name__ = 'x_dispatch_mouse_event'


def x_dispatch_touch_event__mutmut_orig(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_1(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = None
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_2(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = None
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_3(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["XXtypeXX"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_4(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["TYPE"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_5(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["Type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_6(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = None
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_7(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["XXtouchPointsXX"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_8(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchpoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_9(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["TOUCHPOINTS"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_10(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["Touchpoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_11(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_12(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = None
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_13(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["XXmodifiersXX"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_14(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["MODIFIERS"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_15(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["Modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_16(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_17(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_18(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["XXtimestampXX"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_19(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["TIMESTAMP"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_20(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["Timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_21(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_dispatch_touch_event__mutmut_22(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_23(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_24(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.dispatchTouchEvent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_25(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.dispatchTouchEventXX",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_26(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "input.dispatchtouchevent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_27(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.DISPATCHTOUCHEVENT",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_28(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchtouchevent",
        "params": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_29(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_30(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "PARAMS": params,
    }
    yield cmd_dict


def x_dispatch_touch_event__mutmut_31(
    type_: str,
    touch_points: list[TouchPoint],
    modifiers: int | None = None,
    timestamp: TimeSinceEpoch | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Dispatches a touch event to the page.

    :param type_: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
    :param touch_points: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param timestamp: *(Optional)* Time at which the event occurred.
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["touchPoints"] = [i.to_json() for i in touch_points]
    if modifiers is not None:
        params["modifiers"] = modifiers
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.dispatchTouchEvent",
        "Params": params,
    }
    yield cmd_dict

x_dispatch_touch_event__mutmut_mutants : ClassVar[MutantDict] = {
'x_dispatch_touch_event__mutmut_1': x_dispatch_touch_event__mutmut_1, 
    'x_dispatch_touch_event__mutmut_2': x_dispatch_touch_event__mutmut_2, 
    'x_dispatch_touch_event__mutmut_3': x_dispatch_touch_event__mutmut_3, 
    'x_dispatch_touch_event__mutmut_4': x_dispatch_touch_event__mutmut_4, 
    'x_dispatch_touch_event__mutmut_5': x_dispatch_touch_event__mutmut_5, 
    'x_dispatch_touch_event__mutmut_6': x_dispatch_touch_event__mutmut_6, 
    'x_dispatch_touch_event__mutmut_7': x_dispatch_touch_event__mutmut_7, 
    'x_dispatch_touch_event__mutmut_8': x_dispatch_touch_event__mutmut_8, 
    'x_dispatch_touch_event__mutmut_9': x_dispatch_touch_event__mutmut_9, 
    'x_dispatch_touch_event__mutmut_10': x_dispatch_touch_event__mutmut_10, 
    'x_dispatch_touch_event__mutmut_11': x_dispatch_touch_event__mutmut_11, 
    'x_dispatch_touch_event__mutmut_12': x_dispatch_touch_event__mutmut_12, 
    'x_dispatch_touch_event__mutmut_13': x_dispatch_touch_event__mutmut_13, 
    'x_dispatch_touch_event__mutmut_14': x_dispatch_touch_event__mutmut_14, 
    'x_dispatch_touch_event__mutmut_15': x_dispatch_touch_event__mutmut_15, 
    'x_dispatch_touch_event__mutmut_16': x_dispatch_touch_event__mutmut_16, 
    'x_dispatch_touch_event__mutmut_17': x_dispatch_touch_event__mutmut_17, 
    'x_dispatch_touch_event__mutmut_18': x_dispatch_touch_event__mutmut_18, 
    'x_dispatch_touch_event__mutmut_19': x_dispatch_touch_event__mutmut_19, 
    'x_dispatch_touch_event__mutmut_20': x_dispatch_touch_event__mutmut_20, 
    'x_dispatch_touch_event__mutmut_21': x_dispatch_touch_event__mutmut_21, 
    'x_dispatch_touch_event__mutmut_22': x_dispatch_touch_event__mutmut_22, 
    'x_dispatch_touch_event__mutmut_23': x_dispatch_touch_event__mutmut_23, 
    'x_dispatch_touch_event__mutmut_24': x_dispatch_touch_event__mutmut_24, 
    'x_dispatch_touch_event__mutmut_25': x_dispatch_touch_event__mutmut_25, 
    'x_dispatch_touch_event__mutmut_26': x_dispatch_touch_event__mutmut_26, 
    'x_dispatch_touch_event__mutmut_27': x_dispatch_touch_event__mutmut_27, 
    'x_dispatch_touch_event__mutmut_28': x_dispatch_touch_event__mutmut_28, 
    'x_dispatch_touch_event__mutmut_29': x_dispatch_touch_event__mutmut_29, 
    'x_dispatch_touch_event__mutmut_30': x_dispatch_touch_event__mutmut_30, 
    'x_dispatch_touch_event__mutmut_31': x_dispatch_touch_event__mutmut_31
}

def dispatch_touch_event(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_dispatch_touch_event__mutmut_orig, x_dispatch_touch_event__mutmut_mutants, args, kwargs)
    return result 

dispatch_touch_event.__signature__ = _mutmut_signature(x_dispatch_touch_event__mutmut_orig)
x_dispatch_touch_event__mutmut_orig.__name__ = 'x_dispatch_touch_event'


def x_cancel_dragging__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Cancels any active dragging in the page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Input.cancelDragging",
    }
    yield cmd_dict


def x_cancel_dragging__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Cancels any active dragging in the page.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_cancel_dragging__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Cancels any active dragging in the page.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.cancelDragging",
    }
    yield cmd_dict


def x_cancel_dragging__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Cancels any active dragging in the page.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.cancelDragging",
    }
    yield cmd_dict


def x_cancel_dragging__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Cancels any active dragging in the page.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.cancelDragging",
    }
    yield cmd_dict


def x_cancel_dragging__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Cancels any active dragging in the page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.cancelDraggingXX",
    }
    yield cmd_dict


def x_cancel_dragging__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Cancels any active dragging in the page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "input.canceldragging",
    }
    yield cmd_dict


def x_cancel_dragging__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Cancels any active dragging in the page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.CANCELDRAGGING",
    }
    yield cmd_dict


def x_cancel_dragging__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Cancels any active dragging in the page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Input.canceldragging",
    }
    yield cmd_dict

x_cancel_dragging__mutmut_mutants : ClassVar[MutantDict] = {
'x_cancel_dragging__mutmut_1': x_cancel_dragging__mutmut_1, 
    'x_cancel_dragging__mutmut_2': x_cancel_dragging__mutmut_2, 
    'x_cancel_dragging__mutmut_3': x_cancel_dragging__mutmut_3, 
    'x_cancel_dragging__mutmut_4': x_cancel_dragging__mutmut_4, 
    'x_cancel_dragging__mutmut_5': x_cancel_dragging__mutmut_5, 
    'x_cancel_dragging__mutmut_6': x_cancel_dragging__mutmut_6, 
    'x_cancel_dragging__mutmut_7': x_cancel_dragging__mutmut_7, 
    'x_cancel_dragging__mutmut_8': x_cancel_dragging__mutmut_8
}

def cancel_dragging(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_cancel_dragging__mutmut_orig, x_cancel_dragging__mutmut_mutants, args, kwargs)
    return result 

cancel_dragging.__signature__ = _mutmut_signature(x_cancel_dragging__mutmut_orig)
x_cancel_dragging__mutmut_orig.__name__ = 'x_cancel_dragging'


def x_emulate_touch_from_mouse_event__mutmut_orig(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_1(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = None
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_2(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = None
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_3(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["XXtypeXX"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_4(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["TYPE"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_5(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["Type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_6(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = None
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_7(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["XXxXX"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_8(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["X"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_9(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["X"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_10(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = None
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_11(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["XXyXX"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_12(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["Y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_13(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["Y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_14(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = None
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_15(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["XXbuttonXX"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_16(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["BUTTON"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_17(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["Button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_18(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_19(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = None
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_20(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["XXtimestampXX"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_21(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["TIMESTAMP"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_22(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["Timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_23(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_24(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = None
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_25(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["XXdeltaXXX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_26(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltax"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_27(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["DELTAX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_28(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["Deltax"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_29(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_30(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = None
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_31(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["XXdeltaYXX"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_32(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltay"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_33(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["DELTAY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_34(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["Deltay"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_35(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_36(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = None
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_37(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["XXmodifiersXX"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_38(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["MODIFIERS"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_39(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["Modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_40(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_41(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_42(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["XXclickCountXX"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_43(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickcount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_44(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["CLICKCOUNT"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_45(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["Clickcount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_46(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_47(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_48(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_49(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.emulateTouchFromMouseEvent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_50(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.emulateTouchFromMouseEventXX",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_51(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "input.emulatetouchfrommouseevent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_52(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.EMULATETOUCHFROMMOUSEEVENT",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_53(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulatetouchfrommouseevent",
        "params": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_54(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_55(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "PARAMS": params,
    }
    yield cmd_dict


def x_emulate_touch_from_mouse_event__mutmut_56(
    type_: str,
    x: int,
    y: int,
    button: MouseButton,
    timestamp: TimeSinceEpoch | None = None,
    delta_x: float | None = None,
    delta_y: float | None = None,
    modifiers: int | None = None,
    click_count: int | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Emulates touch event from the mouse event parameters.

    **EXPERIMENTAL**

    :param type_: Type of the mouse event.
    :param x: X coordinate of the mouse pointer in DIP.
    :param y: Y coordinate of the mouse pointer in DIP.
    :param button: Mouse button. Only "none", "left", "right" are supported.
    :param timestamp: *(Optional)* Time at which the event occurred (default: current time).
    :param delta_x: *(Optional)* X delta in DIP for mouse wheel event (default: 0).
    :param delta_y: *(Optional)* Y delta in DIP for mouse wheel event (default: 0).
    :param modifiers: *(Optional)* Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
    :param click_count: *(Optional)* Number of times the mouse button was clicked (default: 0).
    """
    params: T_JSON_DICT = {}
    params["type"] = type_
    params["x"] = x
    params["y"] = y
    params["button"] = button.to_json()
    if timestamp is not None:
        params["timestamp"] = timestamp.to_json()
    if delta_x is not None:
        params["deltaX"] = delta_x
    if delta_y is not None:
        params["deltaY"] = delta_y
    if modifiers is not None:
        params["modifiers"] = modifiers
    if click_count is not None:
        params["clickCount"] = click_count
    cmd_dict: T_JSON_DICT = {
        "method": "Input.emulateTouchFromMouseEvent",
        "Params": params,
    }
    yield cmd_dict

x_emulate_touch_from_mouse_event__mutmut_mutants : ClassVar[MutantDict] = {
'x_emulate_touch_from_mouse_event__mutmut_1': x_emulate_touch_from_mouse_event__mutmut_1, 
    'x_emulate_touch_from_mouse_event__mutmut_2': x_emulate_touch_from_mouse_event__mutmut_2, 
    'x_emulate_touch_from_mouse_event__mutmut_3': x_emulate_touch_from_mouse_event__mutmut_3, 
    'x_emulate_touch_from_mouse_event__mutmut_4': x_emulate_touch_from_mouse_event__mutmut_4, 
    'x_emulate_touch_from_mouse_event__mutmut_5': x_emulate_touch_from_mouse_event__mutmut_5, 
    'x_emulate_touch_from_mouse_event__mutmut_6': x_emulate_touch_from_mouse_event__mutmut_6, 
    'x_emulate_touch_from_mouse_event__mutmut_7': x_emulate_touch_from_mouse_event__mutmut_7, 
    'x_emulate_touch_from_mouse_event__mutmut_8': x_emulate_touch_from_mouse_event__mutmut_8, 
    'x_emulate_touch_from_mouse_event__mutmut_9': x_emulate_touch_from_mouse_event__mutmut_9, 
    'x_emulate_touch_from_mouse_event__mutmut_10': x_emulate_touch_from_mouse_event__mutmut_10, 
    'x_emulate_touch_from_mouse_event__mutmut_11': x_emulate_touch_from_mouse_event__mutmut_11, 
    'x_emulate_touch_from_mouse_event__mutmut_12': x_emulate_touch_from_mouse_event__mutmut_12, 
    'x_emulate_touch_from_mouse_event__mutmut_13': x_emulate_touch_from_mouse_event__mutmut_13, 
    'x_emulate_touch_from_mouse_event__mutmut_14': x_emulate_touch_from_mouse_event__mutmut_14, 
    'x_emulate_touch_from_mouse_event__mutmut_15': x_emulate_touch_from_mouse_event__mutmut_15, 
    'x_emulate_touch_from_mouse_event__mutmut_16': x_emulate_touch_from_mouse_event__mutmut_16, 
    'x_emulate_touch_from_mouse_event__mutmut_17': x_emulate_touch_from_mouse_event__mutmut_17, 
    'x_emulate_touch_from_mouse_event__mutmut_18': x_emulate_touch_from_mouse_event__mutmut_18, 
    'x_emulate_touch_from_mouse_event__mutmut_19': x_emulate_touch_from_mouse_event__mutmut_19, 
    'x_emulate_touch_from_mouse_event__mutmut_20': x_emulate_touch_from_mouse_event__mutmut_20, 
    'x_emulate_touch_from_mouse_event__mutmut_21': x_emulate_touch_from_mouse_event__mutmut_21, 
    'x_emulate_touch_from_mouse_event__mutmut_22': x_emulate_touch_from_mouse_event__mutmut_22, 
    'x_emulate_touch_from_mouse_event__mutmut_23': x_emulate_touch_from_mouse_event__mutmut_23, 
    'x_emulate_touch_from_mouse_event__mutmut_24': x_emulate_touch_from_mouse_event__mutmut_24, 
    'x_emulate_touch_from_mouse_event__mutmut_25': x_emulate_touch_from_mouse_event__mutmut_25, 
    'x_emulate_touch_from_mouse_event__mutmut_26': x_emulate_touch_from_mouse_event__mutmut_26, 
    'x_emulate_touch_from_mouse_event__mutmut_27': x_emulate_touch_from_mouse_event__mutmut_27, 
    'x_emulate_touch_from_mouse_event__mutmut_28': x_emulate_touch_from_mouse_event__mutmut_28, 
    'x_emulate_touch_from_mouse_event__mutmut_29': x_emulate_touch_from_mouse_event__mutmut_29, 
    'x_emulate_touch_from_mouse_event__mutmut_30': x_emulate_touch_from_mouse_event__mutmut_30, 
    'x_emulate_touch_from_mouse_event__mutmut_31': x_emulate_touch_from_mouse_event__mutmut_31, 
    'x_emulate_touch_from_mouse_event__mutmut_32': x_emulate_touch_from_mouse_event__mutmut_32, 
    'x_emulate_touch_from_mouse_event__mutmut_33': x_emulate_touch_from_mouse_event__mutmut_33, 
    'x_emulate_touch_from_mouse_event__mutmut_34': x_emulate_touch_from_mouse_event__mutmut_34, 
    'x_emulate_touch_from_mouse_event__mutmut_35': x_emulate_touch_from_mouse_event__mutmut_35, 
    'x_emulate_touch_from_mouse_event__mutmut_36': x_emulate_touch_from_mouse_event__mutmut_36, 
    'x_emulate_touch_from_mouse_event__mutmut_37': x_emulate_touch_from_mouse_event__mutmut_37, 
    'x_emulate_touch_from_mouse_event__mutmut_38': x_emulate_touch_from_mouse_event__mutmut_38, 
    'x_emulate_touch_from_mouse_event__mutmut_39': x_emulate_touch_from_mouse_event__mutmut_39, 
    'x_emulate_touch_from_mouse_event__mutmut_40': x_emulate_touch_from_mouse_event__mutmut_40, 
    'x_emulate_touch_from_mouse_event__mutmut_41': x_emulate_touch_from_mouse_event__mutmut_41, 
    'x_emulate_touch_from_mouse_event__mutmut_42': x_emulate_touch_from_mouse_event__mutmut_42, 
    'x_emulate_touch_from_mouse_event__mutmut_43': x_emulate_touch_from_mouse_event__mutmut_43, 
    'x_emulate_touch_from_mouse_event__mutmut_44': x_emulate_touch_from_mouse_event__mutmut_44, 
    'x_emulate_touch_from_mouse_event__mutmut_45': x_emulate_touch_from_mouse_event__mutmut_45, 
    'x_emulate_touch_from_mouse_event__mutmut_46': x_emulate_touch_from_mouse_event__mutmut_46, 
    'x_emulate_touch_from_mouse_event__mutmut_47': x_emulate_touch_from_mouse_event__mutmut_47, 
    'x_emulate_touch_from_mouse_event__mutmut_48': x_emulate_touch_from_mouse_event__mutmut_48, 
    'x_emulate_touch_from_mouse_event__mutmut_49': x_emulate_touch_from_mouse_event__mutmut_49, 
    'x_emulate_touch_from_mouse_event__mutmut_50': x_emulate_touch_from_mouse_event__mutmut_50, 
    'x_emulate_touch_from_mouse_event__mutmut_51': x_emulate_touch_from_mouse_event__mutmut_51, 
    'x_emulate_touch_from_mouse_event__mutmut_52': x_emulate_touch_from_mouse_event__mutmut_52, 
    'x_emulate_touch_from_mouse_event__mutmut_53': x_emulate_touch_from_mouse_event__mutmut_53, 
    'x_emulate_touch_from_mouse_event__mutmut_54': x_emulate_touch_from_mouse_event__mutmut_54, 
    'x_emulate_touch_from_mouse_event__mutmut_55': x_emulate_touch_from_mouse_event__mutmut_55, 
    'x_emulate_touch_from_mouse_event__mutmut_56': x_emulate_touch_from_mouse_event__mutmut_56
}

def emulate_touch_from_mouse_event(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_emulate_touch_from_mouse_event__mutmut_orig, x_emulate_touch_from_mouse_event__mutmut_mutants, args, kwargs)
    return result 

emulate_touch_from_mouse_event.__signature__ = _mutmut_signature(x_emulate_touch_from_mouse_event__mutmut_orig)
x_emulate_touch_from_mouse_event__mutmut_orig.__name__ = 'x_emulate_touch_from_mouse_event'


def x_set_ignore_input_events__mutmut_orig(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setIgnoreInputEvents",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_1(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = None
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setIgnoreInputEvents",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_2(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setIgnoreInputEvents",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_3(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["XXignoreXX"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setIgnoreInputEvents",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_4(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["IGNORE"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setIgnoreInputEvents",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_5(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["Ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setIgnoreInputEvents",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_6(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_ignore_input_events__mutmut_7(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.setIgnoreInputEvents",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_8(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.setIgnoreInputEvents",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_9(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.setIgnoreInputEvents",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_10(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.setIgnoreInputEventsXX",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_11(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "input.setignoreinputevents",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_12(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.SETIGNOREINPUTEVENTS",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_13(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setignoreinputevents",
        "params": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_14(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setIgnoreInputEvents",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_15(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setIgnoreInputEvents",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_ignore_input_events__mutmut_16(
    ignore: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Ignores input events (useful while auditing page).

    :param ignore: Ignores input events processing when set to true.
    """
    params: T_JSON_DICT = {}
    params["ignore"] = ignore
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setIgnoreInputEvents",
        "Params": params,
    }
    yield cmd_dict

x_set_ignore_input_events__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_ignore_input_events__mutmut_1': x_set_ignore_input_events__mutmut_1, 
    'x_set_ignore_input_events__mutmut_2': x_set_ignore_input_events__mutmut_2, 
    'x_set_ignore_input_events__mutmut_3': x_set_ignore_input_events__mutmut_3, 
    'x_set_ignore_input_events__mutmut_4': x_set_ignore_input_events__mutmut_4, 
    'x_set_ignore_input_events__mutmut_5': x_set_ignore_input_events__mutmut_5, 
    'x_set_ignore_input_events__mutmut_6': x_set_ignore_input_events__mutmut_6, 
    'x_set_ignore_input_events__mutmut_7': x_set_ignore_input_events__mutmut_7, 
    'x_set_ignore_input_events__mutmut_8': x_set_ignore_input_events__mutmut_8, 
    'x_set_ignore_input_events__mutmut_9': x_set_ignore_input_events__mutmut_9, 
    'x_set_ignore_input_events__mutmut_10': x_set_ignore_input_events__mutmut_10, 
    'x_set_ignore_input_events__mutmut_11': x_set_ignore_input_events__mutmut_11, 
    'x_set_ignore_input_events__mutmut_12': x_set_ignore_input_events__mutmut_12, 
    'x_set_ignore_input_events__mutmut_13': x_set_ignore_input_events__mutmut_13, 
    'x_set_ignore_input_events__mutmut_14': x_set_ignore_input_events__mutmut_14, 
    'x_set_ignore_input_events__mutmut_15': x_set_ignore_input_events__mutmut_15, 
    'x_set_ignore_input_events__mutmut_16': x_set_ignore_input_events__mutmut_16
}

def set_ignore_input_events(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_ignore_input_events__mutmut_orig, x_set_ignore_input_events__mutmut_mutants, args, kwargs)
    return result 

set_ignore_input_events.__signature__ = _mutmut_signature(x_set_ignore_input_events__mutmut_orig)
x_set_ignore_input_events__mutmut_orig.__name__ = 'x_set_ignore_input_events'


def x_set_intercept_drags__mutmut_orig(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setInterceptDrags",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_1(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = None
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setInterceptDrags",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_2(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setInterceptDrags",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_3(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["XXenabledXX"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setInterceptDrags",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_4(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["ENABLED"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setInterceptDrags",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_5(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["Enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setInterceptDrags",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_6(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_intercept_drags__mutmut_7(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.setInterceptDrags",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_8(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.setInterceptDrags",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_9(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.setInterceptDrags",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_10(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.setInterceptDragsXX",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_11(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "input.setinterceptdrags",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_12(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.SETINTERCEPTDRAGS",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_13(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setinterceptdrags",
        "params": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_14(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setInterceptDrags",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_15(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setInterceptDrags",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_intercept_drags__mutmut_16(
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Prevents default drag and drop behavior and instead emits ``Input.dragIntercepted`` events.
    Drag and drop behavior can be directly controlled via ``Input.dispatchDragEvent``.

    **EXPERIMENTAL**

    :param enabled:
    """
    params: T_JSON_DICT = {}
    params["enabled"] = enabled
    cmd_dict: T_JSON_DICT = {
        "method": "Input.setInterceptDrags",
        "Params": params,
    }
    yield cmd_dict

x_set_intercept_drags__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_intercept_drags__mutmut_1': x_set_intercept_drags__mutmut_1, 
    'x_set_intercept_drags__mutmut_2': x_set_intercept_drags__mutmut_2, 
    'x_set_intercept_drags__mutmut_3': x_set_intercept_drags__mutmut_3, 
    'x_set_intercept_drags__mutmut_4': x_set_intercept_drags__mutmut_4, 
    'x_set_intercept_drags__mutmut_5': x_set_intercept_drags__mutmut_5, 
    'x_set_intercept_drags__mutmut_6': x_set_intercept_drags__mutmut_6, 
    'x_set_intercept_drags__mutmut_7': x_set_intercept_drags__mutmut_7, 
    'x_set_intercept_drags__mutmut_8': x_set_intercept_drags__mutmut_8, 
    'x_set_intercept_drags__mutmut_9': x_set_intercept_drags__mutmut_9, 
    'x_set_intercept_drags__mutmut_10': x_set_intercept_drags__mutmut_10, 
    'x_set_intercept_drags__mutmut_11': x_set_intercept_drags__mutmut_11, 
    'x_set_intercept_drags__mutmut_12': x_set_intercept_drags__mutmut_12, 
    'x_set_intercept_drags__mutmut_13': x_set_intercept_drags__mutmut_13, 
    'x_set_intercept_drags__mutmut_14': x_set_intercept_drags__mutmut_14, 
    'x_set_intercept_drags__mutmut_15': x_set_intercept_drags__mutmut_15, 
    'x_set_intercept_drags__mutmut_16': x_set_intercept_drags__mutmut_16
}

def set_intercept_drags(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_intercept_drags__mutmut_orig, x_set_intercept_drags__mutmut_mutants, args, kwargs)
    return result 

set_intercept_drags.__signature__ = _mutmut_signature(x_set_intercept_drags__mutmut_orig)
x_set_intercept_drags__mutmut_orig.__name__ = 'x_set_intercept_drags'


def x_synthesize_pinch_gesture__mutmut_orig(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_1(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = None
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_2(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = None
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_3(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["XXxXX"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_4(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["X"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_5(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["X"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_6(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = None
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_7(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["XXyXX"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_8(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["Y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_9(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["Y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_10(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = None
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_11(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["XXscaleFactorXX"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_12(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scalefactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_13(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["SCALEFACTOR"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_14(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["Scalefactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_15(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_16(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = None
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_17(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["XXrelativeSpeedXX"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_18(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativespeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_19(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["RELATIVESPEED"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_20(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["Relativespeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_21(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_22(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_23(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["XXgestureSourceTypeXX"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_24(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gesturesourcetype"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_25(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["GESTURESOURCETYPE"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_26(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["Gesturesourcetype"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_27(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_28(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_29(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_30(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.synthesizePinchGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_31(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.synthesizePinchGestureXX",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_32(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "input.synthesizepinchgesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_33(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.SYNTHESIZEPINCHGESTURE",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_34(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizepinchgesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_35(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_36(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "PARAMS": params,
    }
    yield cmd_dict


def x_synthesize_pinch_gesture__mutmut_37(
    x: float,
    y: float,
    scale_factor: float,
    relative_speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param scale_factor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    :param relative_speed: *(Optional)* Relative pointer speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    params["scaleFactor"] = scale_factor
    if relative_speed is not None:
        params["relativeSpeed"] = relative_speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizePinchGesture",
        "Params": params,
    }
    yield cmd_dict

x_synthesize_pinch_gesture__mutmut_mutants : ClassVar[MutantDict] = {
'x_synthesize_pinch_gesture__mutmut_1': x_synthesize_pinch_gesture__mutmut_1, 
    'x_synthesize_pinch_gesture__mutmut_2': x_synthesize_pinch_gesture__mutmut_2, 
    'x_synthesize_pinch_gesture__mutmut_3': x_synthesize_pinch_gesture__mutmut_3, 
    'x_synthesize_pinch_gesture__mutmut_4': x_synthesize_pinch_gesture__mutmut_4, 
    'x_synthesize_pinch_gesture__mutmut_5': x_synthesize_pinch_gesture__mutmut_5, 
    'x_synthesize_pinch_gesture__mutmut_6': x_synthesize_pinch_gesture__mutmut_6, 
    'x_synthesize_pinch_gesture__mutmut_7': x_synthesize_pinch_gesture__mutmut_7, 
    'x_synthesize_pinch_gesture__mutmut_8': x_synthesize_pinch_gesture__mutmut_8, 
    'x_synthesize_pinch_gesture__mutmut_9': x_synthesize_pinch_gesture__mutmut_9, 
    'x_synthesize_pinch_gesture__mutmut_10': x_synthesize_pinch_gesture__mutmut_10, 
    'x_synthesize_pinch_gesture__mutmut_11': x_synthesize_pinch_gesture__mutmut_11, 
    'x_synthesize_pinch_gesture__mutmut_12': x_synthesize_pinch_gesture__mutmut_12, 
    'x_synthesize_pinch_gesture__mutmut_13': x_synthesize_pinch_gesture__mutmut_13, 
    'x_synthesize_pinch_gesture__mutmut_14': x_synthesize_pinch_gesture__mutmut_14, 
    'x_synthesize_pinch_gesture__mutmut_15': x_synthesize_pinch_gesture__mutmut_15, 
    'x_synthesize_pinch_gesture__mutmut_16': x_synthesize_pinch_gesture__mutmut_16, 
    'x_synthesize_pinch_gesture__mutmut_17': x_synthesize_pinch_gesture__mutmut_17, 
    'x_synthesize_pinch_gesture__mutmut_18': x_synthesize_pinch_gesture__mutmut_18, 
    'x_synthesize_pinch_gesture__mutmut_19': x_synthesize_pinch_gesture__mutmut_19, 
    'x_synthesize_pinch_gesture__mutmut_20': x_synthesize_pinch_gesture__mutmut_20, 
    'x_synthesize_pinch_gesture__mutmut_21': x_synthesize_pinch_gesture__mutmut_21, 
    'x_synthesize_pinch_gesture__mutmut_22': x_synthesize_pinch_gesture__mutmut_22, 
    'x_synthesize_pinch_gesture__mutmut_23': x_synthesize_pinch_gesture__mutmut_23, 
    'x_synthesize_pinch_gesture__mutmut_24': x_synthesize_pinch_gesture__mutmut_24, 
    'x_synthesize_pinch_gesture__mutmut_25': x_synthesize_pinch_gesture__mutmut_25, 
    'x_synthesize_pinch_gesture__mutmut_26': x_synthesize_pinch_gesture__mutmut_26, 
    'x_synthesize_pinch_gesture__mutmut_27': x_synthesize_pinch_gesture__mutmut_27, 
    'x_synthesize_pinch_gesture__mutmut_28': x_synthesize_pinch_gesture__mutmut_28, 
    'x_synthesize_pinch_gesture__mutmut_29': x_synthesize_pinch_gesture__mutmut_29, 
    'x_synthesize_pinch_gesture__mutmut_30': x_synthesize_pinch_gesture__mutmut_30, 
    'x_synthesize_pinch_gesture__mutmut_31': x_synthesize_pinch_gesture__mutmut_31, 
    'x_synthesize_pinch_gesture__mutmut_32': x_synthesize_pinch_gesture__mutmut_32, 
    'x_synthesize_pinch_gesture__mutmut_33': x_synthesize_pinch_gesture__mutmut_33, 
    'x_synthesize_pinch_gesture__mutmut_34': x_synthesize_pinch_gesture__mutmut_34, 
    'x_synthesize_pinch_gesture__mutmut_35': x_synthesize_pinch_gesture__mutmut_35, 
    'x_synthesize_pinch_gesture__mutmut_36': x_synthesize_pinch_gesture__mutmut_36, 
    'x_synthesize_pinch_gesture__mutmut_37': x_synthesize_pinch_gesture__mutmut_37
}

def synthesize_pinch_gesture(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_synthesize_pinch_gesture__mutmut_orig, x_synthesize_pinch_gesture__mutmut_mutants, args, kwargs)
    return result 

synthesize_pinch_gesture.__signature__ = _mutmut_signature(x_synthesize_pinch_gesture__mutmut_orig)
x_synthesize_pinch_gesture__mutmut_orig.__name__ = 'x_synthesize_pinch_gesture'


def x_synthesize_scroll_gesture__mutmut_orig(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_1(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = None
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_2(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = None
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_3(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["XXxXX"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_4(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["X"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_5(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["X"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_6(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = None
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_7(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["XXyXX"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_8(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["Y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_9(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["Y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_10(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_11(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = None
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_12(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["XXxDistanceXX"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_13(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xdistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_14(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["XDISTANCE"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_15(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["Xdistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_16(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_17(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = None
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_18(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["XXyDistanceXX"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_19(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["ydistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_20(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["YDISTANCE"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_21(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["Ydistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_22(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_23(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = None
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_24(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["XXxOverscrollXX"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_25(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xoverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_26(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["XOVERSCROLL"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_27(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["Xoverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_28(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_29(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = None
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_30(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["XXyOverscrollXX"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_31(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yoverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_32(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["YOVERSCROLL"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_33(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["Yoverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_34(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_35(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = None
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_36(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["XXpreventFlingXX"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_37(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventfling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_38(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["PREVENTFLING"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_39(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["Preventfling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_40(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_41(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = None
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_42(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["XXspeedXX"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_43(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["SPEED"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_44(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["Speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_45(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_46(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = None
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_47(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["XXgestureSourceTypeXX"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_48(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gesturesourcetype"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_49(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["GESTURESOURCETYPE"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_50(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["Gesturesourcetype"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_51(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_52(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = None
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_53(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["XXrepeatCountXX"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_54(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatcount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_55(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["REPEATCOUNT"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_56(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["Repeatcount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_57(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_58(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = None
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_59(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["XXrepeatDelayMsXX"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_60(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatdelayms"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_61(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["REPEATDELAYMS"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_62(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["Repeatdelayms"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_63(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_64(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_65(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["XXinteractionMarkerNameXX"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_66(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionmarkername"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_67(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["INTERACTIONMARKERNAME"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_68(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["Interactionmarkername"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_69(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_70(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_71(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_72(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.synthesizeScrollGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_73(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.synthesizeScrollGestureXX",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_74(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "input.synthesizescrollgesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_75(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.SYNTHESIZESCROLLGESTURE",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_76(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizescrollgesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_77(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_78(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "PARAMS": params,
    }
    yield cmd_dict


def x_synthesize_scroll_gesture__mutmut_79(
    x: float,
    y: float,
    x_distance: float | None = None,
    y_distance: float | None = None,
    x_overscroll: float | None = None,
    y_overscroll: float | None = None,
    prevent_fling: bool | None = None,
    speed: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
    repeat_count: int | None = None,
    repeat_delay_ms: int | None = None,
    interaction_marker_name: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param x_distance: *(Optional)* The distance to scroll along the X axis (positive to scroll left).
    :param y_distance: *(Optional)* The distance to scroll along the Y axis (positive to scroll up).
    :param x_overscroll: *(Optional)* The number of additional pixels to scroll back along the X axis, in addition to the given distance.
    :param y_overscroll: *(Optional)* The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
    :param prevent_fling: *(Optional)* Prevent fling (default: true).
    :param speed: *(Optional)* Swipe speed in pixels per second (default: 800).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    :param repeat_count: *(Optional)* The number of times to repeat the gesture (default: 0).
    :param repeat_delay_ms: *(Optional)* The number of milliseconds delay between each repeat. (default: 250).
    :param interaction_marker_name: *(Optional)* The name of the interaction markers to generate, if not empty (default: "").
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if x_distance is not None:
        params["xDistance"] = x_distance
    if y_distance is not None:
        params["yDistance"] = y_distance
    if x_overscroll is not None:
        params["xOverscroll"] = x_overscroll
    if y_overscroll is not None:
        params["yOverscroll"] = y_overscroll
    if prevent_fling is not None:
        params["preventFling"] = prevent_fling
    if speed is not None:
        params["speed"] = speed
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    if repeat_count is not None:
        params["repeatCount"] = repeat_count
    if repeat_delay_ms is not None:
        params["repeatDelayMs"] = repeat_delay_ms
    if interaction_marker_name is not None:
        params["interactionMarkerName"] = interaction_marker_name
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeScrollGesture",
        "Params": params,
    }
    yield cmd_dict

x_synthesize_scroll_gesture__mutmut_mutants : ClassVar[MutantDict] = {
'x_synthesize_scroll_gesture__mutmut_1': x_synthesize_scroll_gesture__mutmut_1, 
    'x_synthesize_scroll_gesture__mutmut_2': x_synthesize_scroll_gesture__mutmut_2, 
    'x_synthesize_scroll_gesture__mutmut_3': x_synthesize_scroll_gesture__mutmut_3, 
    'x_synthesize_scroll_gesture__mutmut_4': x_synthesize_scroll_gesture__mutmut_4, 
    'x_synthesize_scroll_gesture__mutmut_5': x_synthesize_scroll_gesture__mutmut_5, 
    'x_synthesize_scroll_gesture__mutmut_6': x_synthesize_scroll_gesture__mutmut_6, 
    'x_synthesize_scroll_gesture__mutmut_7': x_synthesize_scroll_gesture__mutmut_7, 
    'x_synthesize_scroll_gesture__mutmut_8': x_synthesize_scroll_gesture__mutmut_8, 
    'x_synthesize_scroll_gesture__mutmut_9': x_synthesize_scroll_gesture__mutmut_9, 
    'x_synthesize_scroll_gesture__mutmut_10': x_synthesize_scroll_gesture__mutmut_10, 
    'x_synthesize_scroll_gesture__mutmut_11': x_synthesize_scroll_gesture__mutmut_11, 
    'x_synthesize_scroll_gesture__mutmut_12': x_synthesize_scroll_gesture__mutmut_12, 
    'x_synthesize_scroll_gesture__mutmut_13': x_synthesize_scroll_gesture__mutmut_13, 
    'x_synthesize_scroll_gesture__mutmut_14': x_synthesize_scroll_gesture__mutmut_14, 
    'x_synthesize_scroll_gesture__mutmut_15': x_synthesize_scroll_gesture__mutmut_15, 
    'x_synthesize_scroll_gesture__mutmut_16': x_synthesize_scroll_gesture__mutmut_16, 
    'x_synthesize_scroll_gesture__mutmut_17': x_synthesize_scroll_gesture__mutmut_17, 
    'x_synthesize_scroll_gesture__mutmut_18': x_synthesize_scroll_gesture__mutmut_18, 
    'x_synthesize_scroll_gesture__mutmut_19': x_synthesize_scroll_gesture__mutmut_19, 
    'x_synthesize_scroll_gesture__mutmut_20': x_synthesize_scroll_gesture__mutmut_20, 
    'x_synthesize_scroll_gesture__mutmut_21': x_synthesize_scroll_gesture__mutmut_21, 
    'x_synthesize_scroll_gesture__mutmut_22': x_synthesize_scroll_gesture__mutmut_22, 
    'x_synthesize_scroll_gesture__mutmut_23': x_synthesize_scroll_gesture__mutmut_23, 
    'x_synthesize_scroll_gesture__mutmut_24': x_synthesize_scroll_gesture__mutmut_24, 
    'x_synthesize_scroll_gesture__mutmut_25': x_synthesize_scroll_gesture__mutmut_25, 
    'x_synthesize_scroll_gesture__mutmut_26': x_synthesize_scroll_gesture__mutmut_26, 
    'x_synthesize_scroll_gesture__mutmut_27': x_synthesize_scroll_gesture__mutmut_27, 
    'x_synthesize_scroll_gesture__mutmut_28': x_synthesize_scroll_gesture__mutmut_28, 
    'x_synthesize_scroll_gesture__mutmut_29': x_synthesize_scroll_gesture__mutmut_29, 
    'x_synthesize_scroll_gesture__mutmut_30': x_synthesize_scroll_gesture__mutmut_30, 
    'x_synthesize_scroll_gesture__mutmut_31': x_synthesize_scroll_gesture__mutmut_31, 
    'x_synthesize_scroll_gesture__mutmut_32': x_synthesize_scroll_gesture__mutmut_32, 
    'x_synthesize_scroll_gesture__mutmut_33': x_synthesize_scroll_gesture__mutmut_33, 
    'x_synthesize_scroll_gesture__mutmut_34': x_synthesize_scroll_gesture__mutmut_34, 
    'x_synthesize_scroll_gesture__mutmut_35': x_synthesize_scroll_gesture__mutmut_35, 
    'x_synthesize_scroll_gesture__mutmut_36': x_synthesize_scroll_gesture__mutmut_36, 
    'x_synthesize_scroll_gesture__mutmut_37': x_synthesize_scroll_gesture__mutmut_37, 
    'x_synthesize_scroll_gesture__mutmut_38': x_synthesize_scroll_gesture__mutmut_38, 
    'x_synthesize_scroll_gesture__mutmut_39': x_synthesize_scroll_gesture__mutmut_39, 
    'x_synthesize_scroll_gesture__mutmut_40': x_synthesize_scroll_gesture__mutmut_40, 
    'x_synthesize_scroll_gesture__mutmut_41': x_synthesize_scroll_gesture__mutmut_41, 
    'x_synthesize_scroll_gesture__mutmut_42': x_synthesize_scroll_gesture__mutmut_42, 
    'x_synthesize_scroll_gesture__mutmut_43': x_synthesize_scroll_gesture__mutmut_43, 
    'x_synthesize_scroll_gesture__mutmut_44': x_synthesize_scroll_gesture__mutmut_44, 
    'x_synthesize_scroll_gesture__mutmut_45': x_synthesize_scroll_gesture__mutmut_45, 
    'x_synthesize_scroll_gesture__mutmut_46': x_synthesize_scroll_gesture__mutmut_46, 
    'x_synthesize_scroll_gesture__mutmut_47': x_synthesize_scroll_gesture__mutmut_47, 
    'x_synthesize_scroll_gesture__mutmut_48': x_synthesize_scroll_gesture__mutmut_48, 
    'x_synthesize_scroll_gesture__mutmut_49': x_synthesize_scroll_gesture__mutmut_49, 
    'x_synthesize_scroll_gesture__mutmut_50': x_synthesize_scroll_gesture__mutmut_50, 
    'x_synthesize_scroll_gesture__mutmut_51': x_synthesize_scroll_gesture__mutmut_51, 
    'x_synthesize_scroll_gesture__mutmut_52': x_synthesize_scroll_gesture__mutmut_52, 
    'x_synthesize_scroll_gesture__mutmut_53': x_synthesize_scroll_gesture__mutmut_53, 
    'x_synthesize_scroll_gesture__mutmut_54': x_synthesize_scroll_gesture__mutmut_54, 
    'x_synthesize_scroll_gesture__mutmut_55': x_synthesize_scroll_gesture__mutmut_55, 
    'x_synthesize_scroll_gesture__mutmut_56': x_synthesize_scroll_gesture__mutmut_56, 
    'x_synthesize_scroll_gesture__mutmut_57': x_synthesize_scroll_gesture__mutmut_57, 
    'x_synthesize_scroll_gesture__mutmut_58': x_synthesize_scroll_gesture__mutmut_58, 
    'x_synthesize_scroll_gesture__mutmut_59': x_synthesize_scroll_gesture__mutmut_59, 
    'x_synthesize_scroll_gesture__mutmut_60': x_synthesize_scroll_gesture__mutmut_60, 
    'x_synthesize_scroll_gesture__mutmut_61': x_synthesize_scroll_gesture__mutmut_61, 
    'x_synthesize_scroll_gesture__mutmut_62': x_synthesize_scroll_gesture__mutmut_62, 
    'x_synthesize_scroll_gesture__mutmut_63': x_synthesize_scroll_gesture__mutmut_63, 
    'x_synthesize_scroll_gesture__mutmut_64': x_synthesize_scroll_gesture__mutmut_64, 
    'x_synthesize_scroll_gesture__mutmut_65': x_synthesize_scroll_gesture__mutmut_65, 
    'x_synthesize_scroll_gesture__mutmut_66': x_synthesize_scroll_gesture__mutmut_66, 
    'x_synthesize_scroll_gesture__mutmut_67': x_synthesize_scroll_gesture__mutmut_67, 
    'x_synthesize_scroll_gesture__mutmut_68': x_synthesize_scroll_gesture__mutmut_68, 
    'x_synthesize_scroll_gesture__mutmut_69': x_synthesize_scroll_gesture__mutmut_69, 
    'x_synthesize_scroll_gesture__mutmut_70': x_synthesize_scroll_gesture__mutmut_70, 
    'x_synthesize_scroll_gesture__mutmut_71': x_synthesize_scroll_gesture__mutmut_71, 
    'x_synthesize_scroll_gesture__mutmut_72': x_synthesize_scroll_gesture__mutmut_72, 
    'x_synthesize_scroll_gesture__mutmut_73': x_synthesize_scroll_gesture__mutmut_73, 
    'x_synthesize_scroll_gesture__mutmut_74': x_synthesize_scroll_gesture__mutmut_74, 
    'x_synthesize_scroll_gesture__mutmut_75': x_synthesize_scroll_gesture__mutmut_75, 
    'x_synthesize_scroll_gesture__mutmut_76': x_synthesize_scroll_gesture__mutmut_76, 
    'x_synthesize_scroll_gesture__mutmut_77': x_synthesize_scroll_gesture__mutmut_77, 
    'x_synthesize_scroll_gesture__mutmut_78': x_synthesize_scroll_gesture__mutmut_78, 
    'x_synthesize_scroll_gesture__mutmut_79': x_synthesize_scroll_gesture__mutmut_79
}

def synthesize_scroll_gesture(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_synthesize_scroll_gesture__mutmut_orig, x_synthesize_scroll_gesture__mutmut_mutants, args, kwargs)
    return result 

synthesize_scroll_gesture.__signature__ = _mutmut_signature(x_synthesize_scroll_gesture__mutmut_orig)
x_synthesize_scroll_gesture__mutmut_orig.__name__ = 'x_synthesize_scroll_gesture'


def x_synthesize_tap_gesture__mutmut_orig(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_1(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = None
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_2(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = None
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_3(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["XXxXX"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_4(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["X"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_5(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["X"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_6(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = None
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_7(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["XXyXX"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_8(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["Y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_9(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["Y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_10(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_11(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = None
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_12(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["XXdurationXX"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_13(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["DURATION"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_14(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["Duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_15(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_16(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = None
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_17(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["XXtapCountXX"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_18(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapcount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_19(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["TAPCOUNT"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_20(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["Tapcount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_21(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_22(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_23(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["XXgestureSourceTypeXX"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_24(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gesturesourcetype"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_25(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["GESTURESOURCETYPE"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_26(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["Gesturesourcetype"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_27(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_28(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_29(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_30(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Input.synthesizeTapGesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_31(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXInput.synthesizeTapGestureXX",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_32(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "input.synthesizetapgesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_33(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "INPUT.SYNTHESIZETAPGESTURE",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_34(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizetapgesture",
        "params": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_35(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_36(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "PARAMS": params,
    }
    yield cmd_dict


def x_synthesize_tap_gesture__mutmut_37(
    x: float,
    y: float,
    duration: int | None = None,
    tap_count: int | None = None,
    gesture_source_type: GestureSourceType | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Synthesizes a tap gesture over a time period by issuing appropriate touch events.

    **EXPERIMENTAL**

    :param x: X coordinate of the start of the gesture in CSS pixels.
    :param y: Y coordinate of the start of the gesture in CSS pixels.
    :param duration: *(Optional)* Duration between touchdown and touchup events in ms (default: 50).
    :param tap_count: *(Optional)* Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    :param gesture_source_type: *(Optional)* Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
    """
    params: T_JSON_DICT = {}
    params["x"] = x
    params["y"] = y
    if duration is not None:
        params["duration"] = duration
    if tap_count is not None:
        params["tapCount"] = tap_count
    if gesture_source_type is not None:
        params["gestureSourceType"] = gesture_source_type.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Input.synthesizeTapGesture",
        "Params": params,
    }
    yield cmd_dict

x_synthesize_tap_gesture__mutmut_mutants : ClassVar[MutantDict] = {
'x_synthesize_tap_gesture__mutmut_1': x_synthesize_tap_gesture__mutmut_1, 
    'x_synthesize_tap_gesture__mutmut_2': x_synthesize_tap_gesture__mutmut_2, 
    'x_synthesize_tap_gesture__mutmut_3': x_synthesize_tap_gesture__mutmut_3, 
    'x_synthesize_tap_gesture__mutmut_4': x_synthesize_tap_gesture__mutmut_4, 
    'x_synthesize_tap_gesture__mutmut_5': x_synthesize_tap_gesture__mutmut_5, 
    'x_synthesize_tap_gesture__mutmut_6': x_synthesize_tap_gesture__mutmut_6, 
    'x_synthesize_tap_gesture__mutmut_7': x_synthesize_tap_gesture__mutmut_7, 
    'x_synthesize_tap_gesture__mutmut_8': x_synthesize_tap_gesture__mutmut_8, 
    'x_synthesize_tap_gesture__mutmut_9': x_synthesize_tap_gesture__mutmut_9, 
    'x_synthesize_tap_gesture__mutmut_10': x_synthesize_tap_gesture__mutmut_10, 
    'x_synthesize_tap_gesture__mutmut_11': x_synthesize_tap_gesture__mutmut_11, 
    'x_synthesize_tap_gesture__mutmut_12': x_synthesize_tap_gesture__mutmut_12, 
    'x_synthesize_tap_gesture__mutmut_13': x_synthesize_tap_gesture__mutmut_13, 
    'x_synthesize_tap_gesture__mutmut_14': x_synthesize_tap_gesture__mutmut_14, 
    'x_synthesize_tap_gesture__mutmut_15': x_synthesize_tap_gesture__mutmut_15, 
    'x_synthesize_tap_gesture__mutmut_16': x_synthesize_tap_gesture__mutmut_16, 
    'x_synthesize_tap_gesture__mutmut_17': x_synthesize_tap_gesture__mutmut_17, 
    'x_synthesize_tap_gesture__mutmut_18': x_synthesize_tap_gesture__mutmut_18, 
    'x_synthesize_tap_gesture__mutmut_19': x_synthesize_tap_gesture__mutmut_19, 
    'x_synthesize_tap_gesture__mutmut_20': x_synthesize_tap_gesture__mutmut_20, 
    'x_synthesize_tap_gesture__mutmut_21': x_synthesize_tap_gesture__mutmut_21, 
    'x_synthesize_tap_gesture__mutmut_22': x_synthesize_tap_gesture__mutmut_22, 
    'x_synthesize_tap_gesture__mutmut_23': x_synthesize_tap_gesture__mutmut_23, 
    'x_synthesize_tap_gesture__mutmut_24': x_synthesize_tap_gesture__mutmut_24, 
    'x_synthesize_tap_gesture__mutmut_25': x_synthesize_tap_gesture__mutmut_25, 
    'x_synthesize_tap_gesture__mutmut_26': x_synthesize_tap_gesture__mutmut_26, 
    'x_synthesize_tap_gesture__mutmut_27': x_synthesize_tap_gesture__mutmut_27, 
    'x_synthesize_tap_gesture__mutmut_28': x_synthesize_tap_gesture__mutmut_28, 
    'x_synthesize_tap_gesture__mutmut_29': x_synthesize_tap_gesture__mutmut_29, 
    'x_synthesize_tap_gesture__mutmut_30': x_synthesize_tap_gesture__mutmut_30, 
    'x_synthesize_tap_gesture__mutmut_31': x_synthesize_tap_gesture__mutmut_31, 
    'x_synthesize_tap_gesture__mutmut_32': x_synthesize_tap_gesture__mutmut_32, 
    'x_synthesize_tap_gesture__mutmut_33': x_synthesize_tap_gesture__mutmut_33, 
    'x_synthesize_tap_gesture__mutmut_34': x_synthesize_tap_gesture__mutmut_34, 
    'x_synthesize_tap_gesture__mutmut_35': x_synthesize_tap_gesture__mutmut_35, 
    'x_synthesize_tap_gesture__mutmut_36': x_synthesize_tap_gesture__mutmut_36, 
    'x_synthesize_tap_gesture__mutmut_37': x_synthesize_tap_gesture__mutmut_37
}

def synthesize_tap_gesture(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_synthesize_tap_gesture__mutmut_orig, x_synthesize_tap_gesture__mutmut_mutants, args, kwargs)
    return result 

synthesize_tap_gesture.__signature__ = _mutmut_signature(x_synthesize_tap_gesture__mutmut_orig)
x_synthesize_tap_gesture__mutmut_orig.__name__ = 'x_synthesize_tap_gesture'


@event_class("Input.dragIntercepted")
@dataclass
class DragIntercepted:
    """
    **EXPERIMENTAL**

    Emitted only when ``Input.setInterceptDrags`` is enabled. Use this data with ``Input.dispatchDragEvent`` to
    restore normal drag and drop behavior.
    """
    data: DragData

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DragIntercepted:
        return cls(
            data=DragData.from_json(json["data"]),
        )
