# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all modules.
#
# CDP version: v0.0.1438564
# CDP domain: Debugger

from __future__ import annotations

import enum
from collections.abc import Generator
from dataclasses import dataclass
from typing import Any

import streamlink.webbrowser.cdp.devtools.runtime as runtime
from streamlink.webbrowser.cdp.devtools.util import T_JSON_DICT, event_class
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


class BreakpointId(str):
    """
    Breakpoint identifier.
    """
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> BreakpointId:
        return cls(json)

    def __repr__(self):
        return f"BreakpointId({super().__repr__()})"


class CallFrameId(str):
    """
    Call frame identifier.
    """
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> CallFrameId:
        return cls(json)

    def __repr__(self):
        return f"CallFrameId({super().__repr__()})"


@dataclass
class Location:
    """
    Location in the source code.
    """
    #: Script identifier as reported in the ``Debugger.scriptParsed``.
    script_id: runtime.ScriptId

    #: Line number in the script (0-based).
    line_number: int

    #: Column number in the script (0-based).
    column_number: int | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["scriptId"] = self.script_id.to_json()
        json["lineNumber"] = self.line_number
        if self.column_number is not None:
            json["columnNumber"] = self.column_number
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Location:
        return cls(
            script_id=runtime.ScriptId.from_json(json["scriptId"]),
            line_number=int(json["lineNumber"]),
            column_number=int(json["columnNumber"]) if "columnNumber" in json else None,
        )


@dataclass
class ScriptPosition:
    """
    Location in the source code.
    """
    line_number: int

    column_number: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["lineNumber"] = self.line_number
        json["columnNumber"] = self.column_number
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScriptPosition:
        return cls(
            line_number=int(json["lineNumber"]),
            column_number=int(json["columnNumber"]),
        )


@dataclass
class LocationRange:
    """
    Location range within one script.
    """
    script_id: runtime.ScriptId

    start: ScriptPosition

    end: ScriptPosition

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["scriptId"] = self.script_id.to_json()
        json["start"] = self.start.to_json()
        json["end"] = self.end.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> LocationRange:
        return cls(
            script_id=runtime.ScriptId.from_json(json["scriptId"]),
            start=ScriptPosition.from_json(json["start"]),
            end=ScriptPosition.from_json(json["end"]),
        )


@dataclass
class CallFrame:
    """
    JavaScript call frame. Array of call frames form the call stack.
    """
    #: Call frame identifier. This identifier is only valid while the virtual machine is paused.
    call_frame_id: CallFrameId

    #: Name of the JavaScript function called on this call frame.
    function_name: str

    #: Location in the source code.
    location: Location

    #: JavaScript script name or url.
    #: Deprecated in favor of using the ``location.scriptId`` to resolve the URL via a previously
    #: sent ``Debugger.scriptParsed`` event.
    url: str

    #: Scope chain for this call frame.
    scope_chain: list[Scope]

    #: ``this`` object for this call frame.
    this: runtime.RemoteObject

    #: Location in the source code.
    function_location: Location | None = None

    #: The value being returned, if the function is at return point.
    return_value: runtime.RemoteObject | None = None

    #: Valid only while the VM is paused and indicates whether this frame
    #: can be restarted or not. Note that a ``true`` value here does not
    #: guarantee that Debugger#restartFrame with this CallFrameId will be
    #: successful, but it is very likely.
    can_be_restarted: bool | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["callFrameId"] = self.call_frame_id.to_json()
        json["functionName"] = self.function_name
        json["location"] = self.location.to_json()
        json["url"] = self.url
        json["scopeChain"] = [i.to_json() for i in self.scope_chain]
        json["this"] = self.this.to_json()
        if self.function_location is not None:
            json["functionLocation"] = self.function_location.to_json()
        if self.return_value is not None:
            json["returnValue"] = self.return_value.to_json()
        if self.can_be_restarted is not None:
            json["canBeRestarted"] = self.can_be_restarted
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CallFrame:
        return cls(
            call_frame_id=CallFrameId.from_json(json["callFrameId"]),
            function_name=str(json["functionName"]),
            location=Location.from_json(json["location"]),
            url=str(json["url"]),
            scope_chain=[Scope.from_json(i) for i in json["scopeChain"]],
            this=runtime.RemoteObject.from_json(json["this"]),
            function_location=Location.from_json(json["functionLocation"]) if "functionLocation" in json else None,
            return_value=runtime.RemoteObject.from_json(json["returnValue"]) if "returnValue" in json else None,
            can_be_restarted=bool(json["canBeRestarted"]) if "canBeRestarted" in json else None,
        )


@dataclass
class Scope:
    """
    Scope description.
    """
    #: Scope type.
    type_: str

    #: Object representing the scope. For ``global`` and ``with`` scopes it represents the actual
    #: object; for the rest of the scopes, it is artificial transient object enumerating scope
    #: variables as its properties.
    object_: runtime.RemoteObject

    name: str | None = None

    #: Location in the source code where scope starts
    start_location: Location | None = None

    #: Location in the source code where scope ends
    end_location: Location | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["type"] = self.type_
        json["object"] = self.object_.to_json()
        if self.name is not None:
            json["name"] = self.name
        if self.start_location is not None:
            json["startLocation"] = self.start_location.to_json()
        if self.end_location is not None:
            json["endLocation"] = self.end_location.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Scope:
        return cls(
            type_=str(json["type"]),
            object_=runtime.RemoteObject.from_json(json["object"]),
            name=str(json["name"]) if "name" in json else None,
            start_location=Location.from_json(json["startLocation"]) if "startLocation" in json else None,
            end_location=Location.from_json(json["endLocation"]) if "endLocation" in json else None,
        )


@dataclass
class SearchMatch:
    """
    Search match for resource.
    """
    #: Line number in resource content.
    line_number: float

    #: Line with match content.
    line_content: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["lineNumber"] = self.line_number
        json["lineContent"] = self.line_content
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> SearchMatch:
        return cls(
            line_number=float(json["lineNumber"]),
            line_content=str(json["lineContent"]),
        )


@dataclass
class BreakLocation:
    #: Script identifier as reported in the ``Debugger.scriptParsed``.
    script_id: runtime.ScriptId

    #: Line number in the script (0-based).
    line_number: int

    #: Column number in the script (0-based).
    column_number: int | None = None

    type_: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["scriptId"] = self.script_id.to_json()
        json["lineNumber"] = self.line_number
        if self.column_number is not None:
            json["columnNumber"] = self.column_number
        if self.type_ is not None:
            json["type"] = self.type_
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BreakLocation:
        return cls(
            script_id=runtime.ScriptId.from_json(json["scriptId"]),
            line_number=int(json["lineNumber"]),
            column_number=int(json["columnNumber"]) if "columnNumber" in json else None,
            type_=str(json["type"]) if "type" in json else None,
        )


@dataclass
class WasmDisassemblyChunk:
    #: The next chunk of disassembled lines.
    lines: list[str]

    #: The bytecode offsets describing the start of each line.
    bytecode_offsets: list[int]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["lines"] = list(self.lines)
        json["bytecodeOffsets"] = list(self.bytecode_offsets)
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> WasmDisassemblyChunk:
        return cls(
            lines=[str(i) for i in json["lines"]],
            bytecode_offsets=[int(i) for i in json["bytecodeOffsets"]],
        )


class ScriptLanguage(enum.Enum):
    """
    Enum of possible script languages.
    """
    JAVA_SCRIPT = "JavaScript"
    WEB_ASSEMBLY = "WebAssembly"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> ScriptLanguage:
        return cls(json)


@dataclass
class DebugSymbols:
    """
    Debug symbols available for a wasm script.
    """
    #: Type of the debug symbols.
    type_: str

    #: URL of the external symbol source.
    external_url: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["type"] = self.type_
        if self.external_url is not None:
            json["externalURL"] = self.external_url
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DebugSymbols:
        return cls(
            type_=str(json["type"]),
            external_url=str(json["externalURL"]) if "externalURL" in json else None,
        )


@dataclass
class ResolvedBreakpoint:
    #: Breakpoint unique identifier.
    breakpoint_id: BreakpointId

    #: Actual breakpoint location.
    location: Location

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json["breakpointId"] = self.breakpoint_id.to_json()
        json["location"] = self.location.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ResolvedBreakpoint:
        return cls(
            breakpoint_id=BreakpointId.from_json(json["breakpointId"]),
            location=Location.from_json(json["location"]),
        )


def x_continue_to_location__mutmut_orig(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_1(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = None
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_2(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = None
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_3(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["XXlocationXX"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_4(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["LOCATION"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_5(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["Location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_6(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_7(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_8(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["XXtargetCallFramesXX"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_9(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetcallframes"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_10(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["TARGETCALLFRAMES"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_11(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["Targetcallframes"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_12(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_continue_to_location__mutmut_13(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_14(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_15(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.continueToLocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_16(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.continueToLocationXX",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_17(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.continuetolocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_18(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.CONTINUETOLOCATION",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_19(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continuetolocation",
        "params": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_20(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_21(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "PARAMS": params,
    }
    yield cmd_dict


def x_continue_to_location__mutmut_22(
    location: Location,
    target_call_frames: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Continues execution until specific location is reached.

    :param location: Location to continue to.
    :param target_call_frames: *(Optional)*
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if target_call_frames is not None:
        params["targetCallFrames"] = target_call_frames
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.continueToLocation",
        "Params": params,
    }
    yield cmd_dict

x_continue_to_location__mutmut_mutants : ClassVar[MutantDict] = {
'x_continue_to_location__mutmut_1': x_continue_to_location__mutmut_1, 
    'x_continue_to_location__mutmut_2': x_continue_to_location__mutmut_2, 
    'x_continue_to_location__mutmut_3': x_continue_to_location__mutmut_3, 
    'x_continue_to_location__mutmut_4': x_continue_to_location__mutmut_4, 
    'x_continue_to_location__mutmut_5': x_continue_to_location__mutmut_5, 
    'x_continue_to_location__mutmut_6': x_continue_to_location__mutmut_6, 
    'x_continue_to_location__mutmut_7': x_continue_to_location__mutmut_7, 
    'x_continue_to_location__mutmut_8': x_continue_to_location__mutmut_8, 
    'x_continue_to_location__mutmut_9': x_continue_to_location__mutmut_9, 
    'x_continue_to_location__mutmut_10': x_continue_to_location__mutmut_10, 
    'x_continue_to_location__mutmut_11': x_continue_to_location__mutmut_11, 
    'x_continue_to_location__mutmut_12': x_continue_to_location__mutmut_12, 
    'x_continue_to_location__mutmut_13': x_continue_to_location__mutmut_13, 
    'x_continue_to_location__mutmut_14': x_continue_to_location__mutmut_14, 
    'x_continue_to_location__mutmut_15': x_continue_to_location__mutmut_15, 
    'x_continue_to_location__mutmut_16': x_continue_to_location__mutmut_16, 
    'x_continue_to_location__mutmut_17': x_continue_to_location__mutmut_17, 
    'x_continue_to_location__mutmut_18': x_continue_to_location__mutmut_18, 
    'x_continue_to_location__mutmut_19': x_continue_to_location__mutmut_19, 
    'x_continue_to_location__mutmut_20': x_continue_to_location__mutmut_20, 
    'x_continue_to_location__mutmut_21': x_continue_to_location__mutmut_21, 
    'x_continue_to_location__mutmut_22': x_continue_to_location__mutmut_22
}

def continue_to_location(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_continue_to_location__mutmut_orig, x_continue_to_location__mutmut_mutants, args, kwargs)
    return result 

continue_to_location.__signature__ = _mutmut_signature(x_continue_to_location__mutmut_orig)
x_continue_to_location__mutmut_orig.__name__ = 'x_continue_to_location'


def x_disable__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables debugger for given page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disable",
    }
    yield cmd_dict


def x_disable__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables debugger for given page.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_disable__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables debugger for given page.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.disable",
    }
    yield cmd_dict


def x_disable__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables debugger for given page.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.disable",
    }
    yield cmd_dict


def x_disable__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables debugger for given page.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.disable",
    }
    yield cmd_dict


def x_disable__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables debugger for given page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.disableXX",
    }
    yield cmd_dict


def x_disable__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables debugger for given page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.disable",
    }
    yield cmd_dict


def x_disable__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Disables debugger for given page.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.DISABLE",
    }
    yield cmd_dict

x_disable__mutmut_mutants : ClassVar[MutantDict] = {
'x_disable__mutmut_1': x_disable__mutmut_1, 
    'x_disable__mutmut_2': x_disable__mutmut_2, 
    'x_disable__mutmut_3': x_disable__mutmut_3, 
    'x_disable__mutmut_4': x_disable__mutmut_4, 
    'x_disable__mutmut_5': x_disable__mutmut_5, 
    'x_disable__mutmut_6': x_disable__mutmut_6, 
    'x_disable__mutmut_7': x_disable__mutmut_7
}

def disable(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_disable__mutmut_orig, x_disable__mutmut_mutants, args, kwargs)
    return result 

disable.__signature__ = _mutmut_signature(x_disable__mutmut_orig)
x_disable__mutmut_orig.__name__ = 'x_disable'


def x_enable__mutmut_orig(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_1(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = None
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_2(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_3(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_4(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["XXmaxScriptsCacheSizeXX"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_5(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxscriptscachesize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_6(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["MAXSCRIPTSCACHESIZE"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_7(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["Maxscriptscachesize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_8(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_9(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_10(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_11(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_12(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.enableXX",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_13(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_14(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.ENABLE",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_15(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_16(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_17(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "Params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_18(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = None
    return runtime.UniqueDebuggerId.from_json(json["debuggerId"])


def x_enable__mutmut_19(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(None)


def x_enable__mutmut_20(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["XXdebuggerIdXX"])


def x_enable__mutmut_21(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["debuggerid"])


def x_enable__mutmut_22(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["DEBUGGERID"])


def x_enable__mutmut_23(
    max_scripts_cache_size: float | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]:
    """
    Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received.

    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
    :returns: Unique identifier of the debugger.
    """
    params: T_JSON_DICT = {}
    if max_scripts_cache_size is not None:
        params["maxScriptsCacheSize"] = max_scripts_cache_size
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.enable",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.UniqueDebuggerId.from_json(json["Debuggerid"])

x_enable__mutmut_mutants : ClassVar[MutantDict] = {
'x_enable__mutmut_1': x_enable__mutmut_1, 
    'x_enable__mutmut_2': x_enable__mutmut_2, 
    'x_enable__mutmut_3': x_enable__mutmut_3, 
    'x_enable__mutmut_4': x_enable__mutmut_4, 
    'x_enable__mutmut_5': x_enable__mutmut_5, 
    'x_enable__mutmut_6': x_enable__mutmut_6, 
    'x_enable__mutmut_7': x_enable__mutmut_7, 
    'x_enable__mutmut_8': x_enable__mutmut_8, 
    'x_enable__mutmut_9': x_enable__mutmut_9, 
    'x_enable__mutmut_10': x_enable__mutmut_10, 
    'x_enable__mutmut_11': x_enable__mutmut_11, 
    'x_enable__mutmut_12': x_enable__mutmut_12, 
    'x_enable__mutmut_13': x_enable__mutmut_13, 
    'x_enable__mutmut_14': x_enable__mutmut_14, 
    'x_enable__mutmut_15': x_enable__mutmut_15, 
    'x_enable__mutmut_16': x_enable__mutmut_16, 
    'x_enable__mutmut_17': x_enable__mutmut_17, 
    'x_enable__mutmut_18': x_enable__mutmut_18, 
    'x_enable__mutmut_19': x_enable__mutmut_19, 
    'x_enable__mutmut_20': x_enable__mutmut_20, 
    'x_enable__mutmut_21': x_enable__mutmut_21, 
    'x_enable__mutmut_22': x_enable__mutmut_22, 
    'x_enable__mutmut_23': x_enable__mutmut_23
}

def enable(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_enable__mutmut_orig, x_enable__mutmut_mutants, args, kwargs)
    return result 

enable.__signature__ = _mutmut_signature(x_enable__mutmut_orig)
x_enable__mutmut_orig.__name__ = 'x_enable'


def x_evaluate_on_call_frame__mutmut_orig(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_1(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = None
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_2(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = None
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_3(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["XXcallFrameIdXX"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_4(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callframeid"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_5(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["CALLFRAMEID"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_6(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["Callframeid"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_7(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = None
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_8(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["XXexpressionXX"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_9(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["EXPRESSION"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_10(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["Expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_11(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_12(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = None
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_13(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["XXobjectGroupXX"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_14(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectgroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_15(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["OBJECTGROUP"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_16(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["Objectgroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_17(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_18(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = None
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_19(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["XXincludeCommandLineAPIXX"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_20(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includecommandlineapi"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_21(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["INCLUDECOMMANDLINEAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_22(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["Includecommandlineapi"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_23(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_24(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = None
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_25(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["XXsilentXX"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_26(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["SILENT"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_27(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["Silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_28(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_29(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = None
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_30(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["XXreturnByValueXX"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_31(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnbyvalue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_32(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["RETURNBYVALUE"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_33(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["Returnbyvalue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_34(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_35(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = None
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_36(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["XXgeneratePreviewXX"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_37(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatepreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_38(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["GENERATEPREVIEW"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_39(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["Generatepreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_40(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_41(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = None
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_42(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["XXthrowOnSideEffectXX"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_43(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwonsideeffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_44(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["THROWONSIDEEFFECT"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_45(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["Throwonsideeffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_46(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_47(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_48(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["XXtimeoutXX"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_49(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["TIMEOUT"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_50(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["Timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_51(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_52(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_53(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_54(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_55(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.evaluateOnCallFrameXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_56(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.evaluateoncallframe",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_57(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.EVALUATEONCALLFRAME",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_58(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateoncallframe",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_59(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_60(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_61(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_62(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = None
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_63(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(None),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_64(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["XXresultXX"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_65(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["RESULT"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_66(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["Result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_67(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(None) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_68(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["XXexceptionDetailsXX"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_69(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_70(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["EXCEPTIONDETAILS"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_71(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["Exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_72(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "XXexceptionDetailsXX" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_73(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptiondetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_74(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "EXCEPTIONDETAILS" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_75(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "Exceptiondetails" in json else None,
    )


def x_evaluate_on_call_frame__mutmut_76(
    call_frame_id: CallFrameId,
    expression: str,
    object_group: str | None = None,
    include_command_line_api: bool | None = None,
    silent: bool | None = None,
    return_by_value: bool | None = None,
    generate_preview: bool | None = None,
    throw_on_side_effect: bool | None = None,
    timeout: runtime.TimeDelta | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]:
    """
    Evaluates expression on a given call frame.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param expression: Expression to evaluate.
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````).
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false.
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state.
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result.
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds).
    :returns: A tuple with the following items:

        0. **result** - Object wrapper for the evaluation result.
        1. **exceptionDetails** - *(Optional)* Exception details.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    params["expression"] = expression
    if object_group is not None:
        params["objectGroup"] = object_group
    if include_command_line_api is not None:
        params["includeCommandLineAPI"] = include_command_line_api
    if silent is not None:
        params["silent"] = silent
    if return_by_value is not None:
        params["returnByValue"] = return_by_value
    if generate_preview is not None:
        params["generatePreview"] = generate_preview
    if throw_on_side_effect is not None:
        params["throwOnSideEffect"] = throw_on_side_effect
    if timeout is not None:
        params["timeout"] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.evaluateOnCallFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        runtime.RemoteObject.from_json(json["result"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" not in json else None,
    )

x_evaluate_on_call_frame__mutmut_mutants : ClassVar[MutantDict] = {
'x_evaluate_on_call_frame__mutmut_1': x_evaluate_on_call_frame__mutmut_1, 
    'x_evaluate_on_call_frame__mutmut_2': x_evaluate_on_call_frame__mutmut_2, 
    'x_evaluate_on_call_frame__mutmut_3': x_evaluate_on_call_frame__mutmut_3, 
    'x_evaluate_on_call_frame__mutmut_4': x_evaluate_on_call_frame__mutmut_4, 
    'x_evaluate_on_call_frame__mutmut_5': x_evaluate_on_call_frame__mutmut_5, 
    'x_evaluate_on_call_frame__mutmut_6': x_evaluate_on_call_frame__mutmut_6, 
    'x_evaluate_on_call_frame__mutmut_7': x_evaluate_on_call_frame__mutmut_7, 
    'x_evaluate_on_call_frame__mutmut_8': x_evaluate_on_call_frame__mutmut_8, 
    'x_evaluate_on_call_frame__mutmut_9': x_evaluate_on_call_frame__mutmut_9, 
    'x_evaluate_on_call_frame__mutmut_10': x_evaluate_on_call_frame__mutmut_10, 
    'x_evaluate_on_call_frame__mutmut_11': x_evaluate_on_call_frame__mutmut_11, 
    'x_evaluate_on_call_frame__mutmut_12': x_evaluate_on_call_frame__mutmut_12, 
    'x_evaluate_on_call_frame__mutmut_13': x_evaluate_on_call_frame__mutmut_13, 
    'x_evaluate_on_call_frame__mutmut_14': x_evaluate_on_call_frame__mutmut_14, 
    'x_evaluate_on_call_frame__mutmut_15': x_evaluate_on_call_frame__mutmut_15, 
    'x_evaluate_on_call_frame__mutmut_16': x_evaluate_on_call_frame__mutmut_16, 
    'x_evaluate_on_call_frame__mutmut_17': x_evaluate_on_call_frame__mutmut_17, 
    'x_evaluate_on_call_frame__mutmut_18': x_evaluate_on_call_frame__mutmut_18, 
    'x_evaluate_on_call_frame__mutmut_19': x_evaluate_on_call_frame__mutmut_19, 
    'x_evaluate_on_call_frame__mutmut_20': x_evaluate_on_call_frame__mutmut_20, 
    'x_evaluate_on_call_frame__mutmut_21': x_evaluate_on_call_frame__mutmut_21, 
    'x_evaluate_on_call_frame__mutmut_22': x_evaluate_on_call_frame__mutmut_22, 
    'x_evaluate_on_call_frame__mutmut_23': x_evaluate_on_call_frame__mutmut_23, 
    'x_evaluate_on_call_frame__mutmut_24': x_evaluate_on_call_frame__mutmut_24, 
    'x_evaluate_on_call_frame__mutmut_25': x_evaluate_on_call_frame__mutmut_25, 
    'x_evaluate_on_call_frame__mutmut_26': x_evaluate_on_call_frame__mutmut_26, 
    'x_evaluate_on_call_frame__mutmut_27': x_evaluate_on_call_frame__mutmut_27, 
    'x_evaluate_on_call_frame__mutmut_28': x_evaluate_on_call_frame__mutmut_28, 
    'x_evaluate_on_call_frame__mutmut_29': x_evaluate_on_call_frame__mutmut_29, 
    'x_evaluate_on_call_frame__mutmut_30': x_evaluate_on_call_frame__mutmut_30, 
    'x_evaluate_on_call_frame__mutmut_31': x_evaluate_on_call_frame__mutmut_31, 
    'x_evaluate_on_call_frame__mutmut_32': x_evaluate_on_call_frame__mutmut_32, 
    'x_evaluate_on_call_frame__mutmut_33': x_evaluate_on_call_frame__mutmut_33, 
    'x_evaluate_on_call_frame__mutmut_34': x_evaluate_on_call_frame__mutmut_34, 
    'x_evaluate_on_call_frame__mutmut_35': x_evaluate_on_call_frame__mutmut_35, 
    'x_evaluate_on_call_frame__mutmut_36': x_evaluate_on_call_frame__mutmut_36, 
    'x_evaluate_on_call_frame__mutmut_37': x_evaluate_on_call_frame__mutmut_37, 
    'x_evaluate_on_call_frame__mutmut_38': x_evaluate_on_call_frame__mutmut_38, 
    'x_evaluate_on_call_frame__mutmut_39': x_evaluate_on_call_frame__mutmut_39, 
    'x_evaluate_on_call_frame__mutmut_40': x_evaluate_on_call_frame__mutmut_40, 
    'x_evaluate_on_call_frame__mutmut_41': x_evaluate_on_call_frame__mutmut_41, 
    'x_evaluate_on_call_frame__mutmut_42': x_evaluate_on_call_frame__mutmut_42, 
    'x_evaluate_on_call_frame__mutmut_43': x_evaluate_on_call_frame__mutmut_43, 
    'x_evaluate_on_call_frame__mutmut_44': x_evaluate_on_call_frame__mutmut_44, 
    'x_evaluate_on_call_frame__mutmut_45': x_evaluate_on_call_frame__mutmut_45, 
    'x_evaluate_on_call_frame__mutmut_46': x_evaluate_on_call_frame__mutmut_46, 
    'x_evaluate_on_call_frame__mutmut_47': x_evaluate_on_call_frame__mutmut_47, 
    'x_evaluate_on_call_frame__mutmut_48': x_evaluate_on_call_frame__mutmut_48, 
    'x_evaluate_on_call_frame__mutmut_49': x_evaluate_on_call_frame__mutmut_49, 
    'x_evaluate_on_call_frame__mutmut_50': x_evaluate_on_call_frame__mutmut_50, 
    'x_evaluate_on_call_frame__mutmut_51': x_evaluate_on_call_frame__mutmut_51, 
    'x_evaluate_on_call_frame__mutmut_52': x_evaluate_on_call_frame__mutmut_52, 
    'x_evaluate_on_call_frame__mutmut_53': x_evaluate_on_call_frame__mutmut_53, 
    'x_evaluate_on_call_frame__mutmut_54': x_evaluate_on_call_frame__mutmut_54, 
    'x_evaluate_on_call_frame__mutmut_55': x_evaluate_on_call_frame__mutmut_55, 
    'x_evaluate_on_call_frame__mutmut_56': x_evaluate_on_call_frame__mutmut_56, 
    'x_evaluate_on_call_frame__mutmut_57': x_evaluate_on_call_frame__mutmut_57, 
    'x_evaluate_on_call_frame__mutmut_58': x_evaluate_on_call_frame__mutmut_58, 
    'x_evaluate_on_call_frame__mutmut_59': x_evaluate_on_call_frame__mutmut_59, 
    'x_evaluate_on_call_frame__mutmut_60': x_evaluate_on_call_frame__mutmut_60, 
    'x_evaluate_on_call_frame__mutmut_61': x_evaluate_on_call_frame__mutmut_61, 
    'x_evaluate_on_call_frame__mutmut_62': x_evaluate_on_call_frame__mutmut_62, 
    'x_evaluate_on_call_frame__mutmut_63': x_evaluate_on_call_frame__mutmut_63, 
    'x_evaluate_on_call_frame__mutmut_64': x_evaluate_on_call_frame__mutmut_64, 
    'x_evaluate_on_call_frame__mutmut_65': x_evaluate_on_call_frame__mutmut_65, 
    'x_evaluate_on_call_frame__mutmut_66': x_evaluate_on_call_frame__mutmut_66, 
    'x_evaluate_on_call_frame__mutmut_67': x_evaluate_on_call_frame__mutmut_67, 
    'x_evaluate_on_call_frame__mutmut_68': x_evaluate_on_call_frame__mutmut_68, 
    'x_evaluate_on_call_frame__mutmut_69': x_evaluate_on_call_frame__mutmut_69, 
    'x_evaluate_on_call_frame__mutmut_70': x_evaluate_on_call_frame__mutmut_70, 
    'x_evaluate_on_call_frame__mutmut_71': x_evaluate_on_call_frame__mutmut_71, 
    'x_evaluate_on_call_frame__mutmut_72': x_evaluate_on_call_frame__mutmut_72, 
    'x_evaluate_on_call_frame__mutmut_73': x_evaluate_on_call_frame__mutmut_73, 
    'x_evaluate_on_call_frame__mutmut_74': x_evaluate_on_call_frame__mutmut_74, 
    'x_evaluate_on_call_frame__mutmut_75': x_evaluate_on_call_frame__mutmut_75, 
    'x_evaluate_on_call_frame__mutmut_76': x_evaluate_on_call_frame__mutmut_76
}

def evaluate_on_call_frame(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_evaluate_on_call_frame__mutmut_orig, x_evaluate_on_call_frame__mutmut_mutants, args, kwargs)
    return result 

evaluate_on_call_frame.__signature__ = _mutmut_signature(x_evaluate_on_call_frame__mutmut_orig)
x_evaluate_on_call_frame__mutmut_orig.__name__ = 'x_evaluate_on_call_frame'


def x_get_possible_breakpoints__mutmut_orig(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_1(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = None
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_2(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = None
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_3(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["XXstartXX"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_4(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["START"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_5(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["Start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_6(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_7(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = None
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_8(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["XXendXX"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_9(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["END"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_10(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["End"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_11(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_12(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_13(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["XXrestrictToFunctionXX"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_14(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restricttofunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_15(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["RESTRICTTOFUNCTION"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_16(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["Restricttofunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_17(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_18(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_19(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_20(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_21(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.getPossibleBreakpointsXX",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_22(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.getpossiblebreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_23(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.GETPOSSIBLEBREAKPOINTS",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_24(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getpossiblebreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_25(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_26(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_27(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "Params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_28(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = None
    return [BreakLocation.from_json(i) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_29(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(None) for i in json["locations"]]


def x_get_possible_breakpoints__mutmut_30(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["XXlocationsXX"]]


def x_get_possible_breakpoints__mutmut_31(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["LOCATIONS"]]


def x_get_possible_breakpoints__mutmut_32(
    start: Location,
    end: Location | None = None,
    restrict_to_function: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]:
    """
    Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same.

    :param start: Start of range to search possible breakpoint locations in.
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start.
    :returns: List of the possible breakpoint locations.
    """
    params: T_JSON_DICT = {}
    params["start"] = start.to_json()
    if end is not None:
        params["end"] = end.to_json()
    if restrict_to_function is not None:
        params["restrictToFunction"] = restrict_to_function
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getPossibleBreakpoints",
        "params": params,
    }
    json = yield cmd_dict
    return [BreakLocation.from_json(i) for i in json["Locations"]]

x_get_possible_breakpoints__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_possible_breakpoints__mutmut_1': x_get_possible_breakpoints__mutmut_1, 
    'x_get_possible_breakpoints__mutmut_2': x_get_possible_breakpoints__mutmut_2, 
    'x_get_possible_breakpoints__mutmut_3': x_get_possible_breakpoints__mutmut_3, 
    'x_get_possible_breakpoints__mutmut_4': x_get_possible_breakpoints__mutmut_4, 
    'x_get_possible_breakpoints__mutmut_5': x_get_possible_breakpoints__mutmut_5, 
    'x_get_possible_breakpoints__mutmut_6': x_get_possible_breakpoints__mutmut_6, 
    'x_get_possible_breakpoints__mutmut_7': x_get_possible_breakpoints__mutmut_7, 
    'x_get_possible_breakpoints__mutmut_8': x_get_possible_breakpoints__mutmut_8, 
    'x_get_possible_breakpoints__mutmut_9': x_get_possible_breakpoints__mutmut_9, 
    'x_get_possible_breakpoints__mutmut_10': x_get_possible_breakpoints__mutmut_10, 
    'x_get_possible_breakpoints__mutmut_11': x_get_possible_breakpoints__mutmut_11, 
    'x_get_possible_breakpoints__mutmut_12': x_get_possible_breakpoints__mutmut_12, 
    'x_get_possible_breakpoints__mutmut_13': x_get_possible_breakpoints__mutmut_13, 
    'x_get_possible_breakpoints__mutmut_14': x_get_possible_breakpoints__mutmut_14, 
    'x_get_possible_breakpoints__mutmut_15': x_get_possible_breakpoints__mutmut_15, 
    'x_get_possible_breakpoints__mutmut_16': x_get_possible_breakpoints__mutmut_16, 
    'x_get_possible_breakpoints__mutmut_17': x_get_possible_breakpoints__mutmut_17, 
    'x_get_possible_breakpoints__mutmut_18': x_get_possible_breakpoints__mutmut_18, 
    'x_get_possible_breakpoints__mutmut_19': x_get_possible_breakpoints__mutmut_19, 
    'x_get_possible_breakpoints__mutmut_20': x_get_possible_breakpoints__mutmut_20, 
    'x_get_possible_breakpoints__mutmut_21': x_get_possible_breakpoints__mutmut_21, 
    'x_get_possible_breakpoints__mutmut_22': x_get_possible_breakpoints__mutmut_22, 
    'x_get_possible_breakpoints__mutmut_23': x_get_possible_breakpoints__mutmut_23, 
    'x_get_possible_breakpoints__mutmut_24': x_get_possible_breakpoints__mutmut_24, 
    'x_get_possible_breakpoints__mutmut_25': x_get_possible_breakpoints__mutmut_25, 
    'x_get_possible_breakpoints__mutmut_26': x_get_possible_breakpoints__mutmut_26, 
    'x_get_possible_breakpoints__mutmut_27': x_get_possible_breakpoints__mutmut_27, 
    'x_get_possible_breakpoints__mutmut_28': x_get_possible_breakpoints__mutmut_28, 
    'x_get_possible_breakpoints__mutmut_29': x_get_possible_breakpoints__mutmut_29, 
    'x_get_possible_breakpoints__mutmut_30': x_get_possible_breakpoints__mutmut_30, 
    'x_get_possible_breakpoints__mutmut_31': x_get_possible_breakpoints__mutmut_31, 
    'x_get_possible_breakpoints__mutmut_32': x_get_possible_breakpoints__mutmut_32
}

def get_possible_breakpoints(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_possible_breakpoints__mutmut_orig, x_get_possible_breakpoints__mutmut_mutants, args, kwargs)
    return result 

get_possible_breakpoints.__signature__ = _mutmut_signature(x_get_possible_breakpoints__mutmut_orig)
x_get_possible_breakpoints__mutmut_orig.__name__ = 'x_get_possible_breakpoints'


def x_get_script_source__mutmut_orig(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_1(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = None
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_2(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_3(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["XXscriptIdXX"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_4(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptid"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_5(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["SCRIPTID"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_6(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["Scriptid"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_7(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_8(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_9(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_10(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_11(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.getScriptSourceXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_12(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.getscriptsource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_13(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.GETSCRIPTSOURCE",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_14(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getscriptsource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_15(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_16(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_17(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_18(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = None
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_19(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(None),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_20(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["XXscriptSourceXX"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_21(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptsource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_22(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["SCRIPTSOURCE"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_23(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["Scriptsource"]),
        str(json["bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_24(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(None) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_25(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["XXbytecodeXX"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_26(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["BYTECODE"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_27(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["Bytecode"]) if "bytecode" in json else None,
    )


def x_get_script_source__mutmut_28(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "XXbytecodeXX" in json else None,
    )


def x_get_script_source__mutmut_29(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "BYTECODE" in json else None,
    )


def x_get_script_source__mutmut_30(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "Bytecode" in json else None,
    )


def x_get_script_source__mutmut_31(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]:
    """
    Returns source for the script with given id.

    :param script_id: Id of the script to get source for.
    :returns: A tuple with the following items:

        0. **scriptSource** - Script source (empty in case of Wasm bytecode).
        1. **bytecode** - *(Optional)* Wasm bytecode. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["scriptSource"]),
        str(json["bytecode"]) if "bytecode" not in json else None,
    )

x_get_script_source__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_script_source__mutmut_1': x_get_script_source__mutmut_1, 
    'x_get_script_source__mutmut_2': x_get_script_source__mutmut_2, 
    'x_get_script_source__mutmut_3': x_get_script_source__mutmut_3, 
    'x_get_script_source__mutmut_4': x_get_script_source__mutmut_4, 
    'x_get_script_source__mutmut_5': x_get_script_source__mutmut_5, 
    'x_get_script_source__mutmut_6': x_get_script_source__mutmut_6, 
    'x_get_script_source__mutmut_7': x_get_script_source__mutmut_7, 
    'x_get_script_source__mutmut_8': x_get_script_source__mutmut_8, 
    'x_get_script_source__mutmut_9': x_get_script_source__mutmut_9, 
    'x_get_script_source__mutmut_10': x_get_script_source__mutmut_10, 
    'x_get_script_source__mutmut_11': x_get_script_source__mutmut_11, 
    'x_get_script_source__mutmut_12': x_get_script_source__mutmut_12, 
    'x_get_script_source__mutmut_13': x_get_script_source__mutmut_13, 
    'x_get_script_source__mutmut_14': x_get_script_source__mutmut_14, 
    'x_get_script_source__mutmut_15': x_get_script_source__mutmut_15, 
    'x_get_script_source__mutmut_16': x_get_script_source__mutmut_16, 
    'x_get_script_source__mutmut_17': x_get_script_source__mutmut_17, 
    'x_get_script_source__mutmut_18': x_get_script_source__mutmut_18, 
    'x_get_script_source__mutmut_19': x_get_script_source__mutmut_19, 
    'x_get_script_source__mutmut_20': x_get_script_source__mutmut_20, 
    'x_get_script_source__mutmut_21': x_get_script_source__mutmut_21, 
    'x_get_script_source__mutmut_22': x_get_script_source__mutmut_22, 
    'x_get_script_source__mutmut_23': x_get_script_source__mutmut_23, 
    'x_get_script_source__mutmut_24': x_get_script_source__mutmut_24, 
    'x_get_script_source__mutmut_25': x_get_script_source__mutmut_25, 
    'x_get_script_source__mutmut_26': x_get_script_source__mutmut_26, 
    'x_get_script_source__mutmut_27': x_get_script_source__mutmut_27, 
    'x_get_script_source__mutmut_28': x_get_script_source__mutmut_28, 
    'x_get_script_source__mutmut_29': x_get_script_source__mutmut_29, 
    'x_get_script_source__mutmut_30': x_get_script_source__mutmut_30, 
    'x_get_script_source__mutmut_31': x_get_script_source__mutmut_31
}

def get_script_source(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_script_source__mutmut_orig, x_get_script_source__mutmut_mutants, args, kwargs)
    return result 

get_script_source.__signature__ = _mutmut_signature(x_get_script_source__mutmut_orig)
x_get_script_source__mutmut_orig.__name__ = 'x_get_script_source'


def x_disassemble_wasm_module__mutmut_orig(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_1(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = None
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_2(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_3(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["XXscriptIdXX"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_4(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptid"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_5(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["SCRIPTID"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_6(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["Scriptid"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_7(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_8(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_9(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_10(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_11(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.disassembleWasmModuleXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_12(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.disassemblewasmmodule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_13(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.DISASSEMBLEWASMMODULE",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_14(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassemblewasmmodule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_15(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_16(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_17(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_18(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = None
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_19(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(None) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_20(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["XXstreamIdXX"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_21(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamid"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_22(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["STREAMID"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_23(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["Streamid"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_24(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "XXstreamIdXX" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_25(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamid" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_26(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "STREAMID" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_27(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "Streamid" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_28(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" not in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_29(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(None),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_30(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["XXtotalNumberOfLinesXX"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_31(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalnumberoflines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_32(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["TOTALNUMBEROFLINES"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_33(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["Totalnumberoflines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_34(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(None) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_35(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["XXfunctionBodyOffsetsXX"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_36(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionbodyoffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_37(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["FUNCTIONBODYOFFSETS"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_38(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["Functionbodyoffsets"]],
        WasmDisassemblyChunk.from_json(json["chunk"]),
    )


def x_disassemble_wasm_module__mutmut_39(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(None),
    )


def x_disassemble_wasm_module__mutmut_40(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["XXchunkXX"]),
    )


def x_disassemble_wasm_module__mutmut_41(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["CHUNK"]),
    )


def x_disassemble_wasm_module__mutmut_42(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]:
    """


    **EXPERIMENTAL**

    :param script_id: Id of the script to disassemble
    :returns: A tuple with the following items:

        0. **streamId** - *(Optional)* For large modules, return a stream from which additional chunks of disassembly can be read successively.
        1. **totalNumberOfLines** - The total number of lines in the disassembly text.
        2. **functionBodyOffsets** - The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        3. **chunk** - The first chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.disassembleWasmModule",
        "params": params,
    }
    json = yield cmd_dict
    return (
        str(json["streamId"]) if "streamId" in json else None,
        int(json["totalNumberOfLines"]),
        [int(i) for i in json["functionBodyOffsets"]],
        WasmDisassemblyChunk.from_json(json["Chunk"]),
    )

x_disassemble_wasm_module__mutmut_mutants : ClassVar[MutantDict] = {
'x_disassemble_wasm_module__mutmut_1': x_disassemble_wasm_module__mutmut_1, 
    'x_disassemble_wasm_module__mutmut_2': x_disassemble_wasm_module__mutmut_2, 
    'x_disassemble_wasm_module__mutmut_3': x_disassemble_wasm_module__mutmut_3, 
    'x_disassemble_wasm_module__mutmut_4': x_disassemble_wasm_module__mutmut_4, 
    'x_disassemble_wasm_module__mutmut_5': x_disassemble_wasm_module__mutmut_5, 
    'x_disassemble_wasm_module__mutmut_6': x_disassemble_wasm_module__mutmut_6, 
    'x_disassemble_wasm_module__mutmut_7': x_disassemble_wasm_module__mutmut_7, 
    'x_disassemble_wasm_module__mutmut_8': x_disassemble_wasm_module__mutmut_8, 
    'x_disassemble_wasm_module__mutmut_9': x_disassemble_wasm_module__mutmut_9, 
    'x_disassemble_wasm_module__mutmut_10': x_disassemble_wasm_module__mutmut_10, 
    'x_disassemble_wasm_module__mutmut_11': x_disassemble_wasm_module__mutmut_11, 
    'x_disassemble_wasm_module__mutmut_12': x_disassemble_wasm_module__mutmut_12, 
    'x_disassemble_wasm_module__mutmut_13': x_disassemble_wasm_module__mutmut_13, 
    'x_disassemble_wasm_module__mutmut_14': x_disassemble_wasm_module__mutmut_14, 
    'x_disassemble_wasm_module__mutmut_15': x_disassemble_wasm_module__mutmut_15, 
    'x_disassemble_wasm_module__mutmut_16': x_disassemble_wasm_module__mutmut_16, 
    'x_disassemble_wasm_module__mutmut_17': x_disassemble_wasm_module__mutmut_17, 
    'x_disassemble_wasm_module__mutmut_18': x_disassemble_wasm_module__mutmut_18, 
    'x_disassemble_wasm_module__mutmut_19': x_disassemble_wasm_module__mutmut_19, 
    'x_disassemble_wasm_module__mutmut_20': x_disassemble_wasm_module__mutmut_20, 
    'x_disassemble_wasm_module__mutmut_21': x_disassemble_wasm_module__mutmut_21, 
    'x_disassemble_wasm_module__mutmut_22': x_disassemble_wasm_module__mutmut_22, 
    'x_disassemble_wasm_module__mutmut_23': x_disassemble_wasm_module__mutmut_23, 
    'x_disassemble_wasm_module__mutmut_24': x_disassemble_wasm_module__mutmut_24, 
    'x_disassemble_wasm_module__mutmut_25': x_disassemble_wasm_module__mutmut_25, 
    'x_disassemble_wasm_module__mutmut_26': x_disassemble_wasm_module__mutmut_26, 
    'x_disassemble_wasm_module__mutmut_27': x_disassemble_wasm_module__mutmut_27, 
    'x_disassemble_wasm_module__mutmut_28': x_disassemble_wasm_module__mutmut_28, 
    'x_disassemble_wasm_module__mutmut_29': x_disassemble_wasm_module__mutmut_29, 
    'x_disassemble_wasm_module__mutmut_30': x_disassemble_wasm_module__mutmut_30, 
    'x_disassemble_wasm_module__mutmut_31': x_disassemble_wasm_module__mutmut_31, 
    'x_disassemble_wasm_module__mutmut_32': x_disassemble_wasm_module__mutmut_32, 
    'x_disassemble_wasm_module__mutmut_33': x_disassemble_wasm_module__mutmut_33, 
    'x_disassemble_wasm_module__mutmut_34': x_disassemble_wasm_module__mutmut_34, 
    'x_disassemble_wasm_module__mutmut_35': x_disassemble_wasm_module__mutmut_35, 
    'x_disassemble_wasm_module__mutmut_36': x_disassemble_wasm_module__mutmut_36, 
    'x_disassemble_wasm_module__mutmut_37': x_disassemble_wasm_module__mutmut_37, 
    'x_disassemble_wasm_module__mutmut_38': x_disassemble_wasm_module__mutmut_38, 
    'x_disassemble_wasm_module__mutmut_39': x_disassemble_wasm_module__mutmut_39, 
    'x_disassemble_wasm_module__mutmut_40': x_disassemble_wasm_module__mutmut_40, 
    'x_disassemble_wasm_module__mutmut_41': x_disassemble_wasm_module__mutmut_41, 
    'x_disassemble_wasm_module__mutmut_42': x_disassemble_wasm_module__mutmut_42
}

def disassemble_wasm_module(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_disassemble_wasm_module__mutmut_orig, x_disassemble_wasm_module__mutmut_mutants, args, kwargs)
    return result 

disassemble_wasm_module.__signature__ = _mutmut_signature(x_disassemble_wasm_module__mutmut_orig)
x_disassemble_wasm_module__mutmut_orig.__name__ = 'x_disassemble_wasm_module'


def x_next_wasm_disassembly_chunk__mutmut_orig(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_1(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = None
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_2(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_3(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["XXstreamIdXX"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_4(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamid"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_5(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["STREAMID"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_6(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["Streamid"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_7(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_8(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_9(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_10(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_11(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.nextWasmDisassemblyChunkXX",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_12(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.nextwasmdisassemblychunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_13(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.NEXTWASMDISASSEMBLYCHUNK",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_14(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextwasmdisassemblychunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_15(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_16(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_17(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "Params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_18(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = None
    return WasmDisassemblyChunk.from_json(json["chunk"])


def x_next_wasm_disassembly_chunk__mutmut_19(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(None)


def x_next_wasm_disassembly_chunk__mutmut_20(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["XXchunkXX"])


def x_next_wasm_disassembly_chunk__mutmut_21(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["CHUNK"])


def x_next_wasm_disassembly_chunk__mutmut_22(
    stream_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]:
    """
    Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors.

    **EXPERIMENTAL**

    :param stream_id:
    :returns: The next chunk of disassembly.
    """
    params: T_JSON_DICT = {}
    params["streamId"] = stream_id
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.nextWasmDisassemblyChunk",
        "params": params,
    }
    json = yield cmd_dict
    return WasmDisassemblyChunk.from_json(json["Chunk"])

x_next_wasm_disassembly_chunk__mutmut_mutants : ClassVar[MutantDict] = {
'x_next_wasm_disassembly_chunk__mutmut_1': x_next_wasm_disassembly_chunk__mutmut_1, 
    'x_next_wasm_disassembly_chunk__mutmut_2': x_next_wasm_disassembly_chunk__mutmut_2, 
    'x_next_wasm_disassembly_chunk__mutmut_3': x_next_wasm_disassembly_chunk__mutmut_3, 
    'x_next_wasm_disassembly_chunk__mutmut_4': x_next_wasm_disassembly_chunk__mutmut_4, 
    'x_next_wasm_disassembly_chunk__mutmut_5': x_next_wasm_disassembly_chunk__mutmut_5, 
    'x_next_wasm_disassembly_chunk__mutmut_6': x_next_wasm_disassembly_chunk__mutmut_6, 
    'x_next_wasm_disassembly_chunk__mutmut_7': x_next_wasm_disassembly_chunk__mutmut_7, 
    'x_next_wasm_disassembly_chunk__mutmut_8': x_next_wasm_disassembly_chunk__mutmut_8, 
    'x_next_wasm_disassembly_chunk__mutmut_9': x_next_wasm_disassembly_chunk__mutmut_9, 
    'x_next_wasm_disassembly_chunk__mutmut_10': x_next_wasm_disassembly_chunk__mutmut_10, 
    'x_next_wasm_disassembly_chunk__mutmut_11': x_next_wasm_disassembly_chunk__mutmut_11, 
    'x_next_wasm_disassembly_chunk__mutmut_12': x_next_wasm_disassembly_chunk__mutmut_12, 
    'x_next_wasm_disassembly_chunk__mutmut_13': x_next_wasm_disassembly_chunk__mutmut_13, 
    'x_next_wasm_disassembly_chunk__mutmut_14': x_next_wasm_disassembly_chunk__mutmut_14, 
    'x_next_wasm_disassembly_chunk__mutmut_15': x_next_wasm_disassembly_chunk__mutmut_15, 
    'x_next_wasm_disassembly_chunk__mutmut_16': x_next_wasm_disassembly_chunk__mutmut_16, 
    'x_next_wasm_disassembly_chunk__mutmut_17': x_next_wasm_disassembly_chunk__mutmut_17, 
    'x_next_wasm_disassembly_chunk__mutmut_18': x_next_wasm_disassembly_chunk__mutmut_18, 
    'x_next_wasm_disassembly_chunk__mutmut_19': x_next_wasm_disassembly_chunk__mutmut_19, 
    'x_next_wasm_disassembly_chunk__mutmut_20': x_next_wasm_disassembly_chunk__mutmut_20, 
    'x_next_wasm_disassembly_chunk__mutmut_21': x_next_wasm_disassembly_chunk__mutmut_21, 
    'x_next_wasm_disassembly_chunk__mutmut_22': x_next_wasm_disassembly_chunk__mutmut_22
}

def next_wasm_disassembly_chunk(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_next_wasm_disassembly_chunk__mutmut_orig, x_next_wasm_disassembly_chunk__mutmut_mutants, args, kwargs)
    return result 

next_wasm_disassembly_chunk.__signature__ = _mutmut_signature(x_next_wasm_disassembly_chunk__mutmut_orig)
x_next_wasm_disassembly_chunk__mutmut_orig.__name__ = 'x_next_wasm_disassembly_chunk'


def x_get_wasm_bytecode__mutmut_orig(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_1(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = None
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_2(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_3(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["XXscriptIdXX"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_4(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptid"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_5(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["SCRIPTID"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_6(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["Scriptid"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_7(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_8(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_9(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_10(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_11(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.getWasmBytecodeXX",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_12(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.getwasmbytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_13(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.GETWASMBYTECODE",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_14(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getwasmbytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_15(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_16(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_17(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "Params": params,
    }
    json = yield cmd_dict
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_18(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = None
    return str(json["bytecode"])


def x_get_wasm_bytecode__mutmut_19(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(None)


def x_get_wasm_bytecode__mutmut_20(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["XXbytecodeXX"])


def x_get_wasm_bytecode__mutmut_21(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["BYTECODE"])


def x_get_wasm_bytecode__mutmut_22(
    script_id: runtime.ScriptId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    This command is deprecated. Use getScriptSource instead.

    :param script_id: Id of the Wasm script to get source for.
    :returns: Script source. (Encoded as a base64 string when passed over JSON)
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getWasmBytecode",
        "params": params,
    }
    json = yield cmd_dict
    return str(json["Bytecode"])

x_get_wasm_bytecode__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_wasm_bytecode__mutmut_1': x_get_wasm_bytecode__mutmut_1, 
    'x_get_wasm_bytecode__mutmut_2': x_get_wasm_bytecode__mutmut_2, 
    'x_get_wasm_bytecode__mutmut_3': x_get_wasm_bytecode__mutmut_3, 
    'x_get_wasm_bytecode__mutmut_4': x_get_wasm_bytecode__mutmut_4, 
    'x_get_wasm_bytecode__mutmut_5': x_get_wasm_bytecode__mutmut_5, 
    'x_get_wasm_bytecode__mutmut_6': x_get_wasm_bytecode__mutmut_6, 
    'x_get_wasm_bytecode__mutmut_7': x_get_wasm_bytecode__mutmut_7, 
    'x_get_wasm_bytecode__mutmut_8': x_get_wasm_bytecode__mutmut_8, 
    'x_get_wasm_bytecode__mutmut_9': x_get_wasm_bytecode__mutmut_9, 
    'x_get_wasm_bytecode__mutmut_10': x_get_wasm_bytecode__mutmut_10, 
    'x_get_wasm_bytecode__mutmut_11': x_get_wasm_bytecode__mutmut_11, 
    'x_get_wasm_bytecode__mutmut_12': x_get_wasm_bytecode__mutmut_12, 
    'x_get_wasm_bytecode__mutmut_13': x_get_wasm_bytecode__mutmut_13, 
    'x_get_wasm_bytecode__mutmut_14': x_get_wasm_bytecode__mutmut_14, 
    'x_get_wasm_bytecode__mutmut_15': x_get_wasm_bytecode__mutmut_15, 
    'x_get_wasm_bytecode__mutmut_16': x_get_wasm_bytecode__mutmut_16, 
    'x_get_wasm_bytecode__mutmut_17': x_get_wasm_bytecode__mutmut_17, 
    'x_get_wasm_bytecode__mutmut_18': x_get_wasm_bytecode__mutmut_18, 
    'x_get_wasm_bytecode__mutmut_19': x_get_wasm_bytecode__mutmut_19, 
    'x_get_wasm_bytecode__mutmut_20': x_get_wasm_bytecode__mutmut_20, 
    'x_get_wasm_bytecode__mutmut_21': x_get_wasm_bytecode__mutmut_21, 
    'x_get_wasm_bytecode__mutmut_22': x_get_wasm_bytecode__mutmut_22
}

def get_wasm_bytecode(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_wasm_bytecode__mutmut_orig, x_get_wasm_bytecode__mutmut_mutants, args, kwargs)
    return result 

get_wasm_bytecode.__signature__ = _mutmut_signature(x_get_wasm_bytecode__mutmut_orig)
x_get_wasm_bytecode__mutmut_orig.__name__ = 'x_get_wasm_bytecode'


def x_get_stack_trace__mutmut_orig(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_1(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = None
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_2(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_3(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["XXstackTraceIdXX"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_4(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stacktraceid"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_5(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["STACKTRACEID"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_6(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["Stacktraceid"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_7(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_8(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_9(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_10(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_11(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.getStackTraceXX",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_12(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.getstacktrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_13(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.GETSTACKTRACE",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_14(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getstacktrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_15(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_16(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_17(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "Params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_18(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = None
    return runtime.StackTrace.from_json(json["stackTrace"])


def x_get_stack_trace__mutmut_19(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(None)


def x_get_stack_trace__mutmut_20(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["XXstackTraceXX"])


def x_get_stack_trace__mutmut_21(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["stacktrace"])


def x_get_stack_trace__mutmut_22(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["STACKTRACE"])


def x_get_stack_trace__mutmut_23(
    stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]:
    """
    Returns stack trace with given ``stackTraceId``.

    **EXPERIMENTAL**

    :param stack_trace_id:
    :returns:
    """
    params: T_JSON_DICT = {}
    params["stackTraceId"] = stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.getStackTrace",
        "params": params,
    }
    json = yield cmd_dict
    return runtime.StackTrace.from_json(json["Stacktrace"])

x_get_stack_trace__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_stack_trace__mutmut_1': x_get_stack_trace__mutmut_1, 
    'x_get_stack_trace__mutmut_2': x_get_stack_trace__mutmut_2, 
    'x_get_stack_trace__mutmut_3': x_get_stack_trace__mutmut_3, 
    'x_get_stack_trace__mutmut_4': x_get_stack_trace__mutmut_4, 
    'x_get_stack_trace__mutmut_5': x_get_stack_trace__mutmut_5, 
    'x_get_stack_trace__mutmut_6': x_get_stack_trace__mutmut_6, 
    'x_get_stack_trace__mutmut_7': x_get_stack_trace__mutmut_7, 
    'x_get_stack_trace__mutmut_8': x_get_stack_trace__mutmut_8, 
    'x_get_stack_trace__mutmut_9': x_get_stack_trace__mutmut_9, 
    'x_get_stack_trace__mutmut_10': x_get_stack_trace__mutmut_10, 
    'x_get_stack_trace__mutmut_11': x_get_stack_trace__mutmut_11, 
    'x_get_stack_trace__mutmut_12': x_get_stack_trace__mutmut_12, 
    'x_get_stack_trace__mutmut_13': x_get_stack_trace__mutmut_13, 
    'x_get_stack_trace__mutmut_14': x_get_stack_trace__mutmut_14, 
    'x_get_stack_trace__mutmut_15': x_get_stack_trace__mutmut_15, 
    'x_get_stack_trace__mutmut_16': x_get_stack_trace__mutmut_16, 
    'x_get_stack_trace__mutmut_17': x_get_stack_trace__mutmut_17, 
    'x_get_stack_trace__mutmut_18': x_get_stack_trace__mutmut_18, 
    'x_get_stack_trace__mutmut_19': x_get_stack_trace__mutmut_19, 
    'x_get_stack_trace__mutmut_20': x_get_stack_trace__mutmut_20, 
    'x_get_stack_trace__mutmut_21': x_get_stack_trace__mutmut_21, 
    'x_get_stack_trace__mutmut_22': x_get_stack_trace__mutmut_22, 
    'x_get_stack_trace__mutmut_23': x_get_stack_trace__mutmut_23
}

def get_stack_trace(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_get_stack_trace__mutmut_orig, x_get_stack_trace__mutmut_mutants, args, kwargs)
    return result 

get_stack_trace.__signature__ = _mutmut_signature(x_get_stack_trace__mutmut_orig)
x_get_stack_trace__mutmut_orig.__name__ = 'x_get_stack_trace'


def x_pause__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops on the next JavaScript statement.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pause",
    }
    yield cmd_dict


def x_pause__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops on the next JavaScript statement.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_pause__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops on the next JavaScript statement.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.pause",
    }
    yield cmd_dict


def x_pause__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops on the next JavaScript statement.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.pause",
    }
    yield cmd_dict


def x_pause__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops on the next JavaScript statement.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.pause",
    }
    yield cmd_dict


def x_pause__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops on the next JavaScript statement.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.pauseXX",
    }
    yield cmd_dict


def x_pause__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops on the next JavaScript statement.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.pause",
    }
    yield cmd_dict


def x_pause__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Stops on the next JavaScript statement.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.PAUSE",
    }
    yield cmd_dict

x_pause__mutmut_mutants : ClassVar[MutantDict] = {
'x_pause__mutmut_1': x_pause__mutmut_1, 
    'x_pause__mutmut_2': x_pause__mutmut_2, 
    'x_pause__mutmut_3': x_pause__mutmut_3, 
    'x_pause__mutmut_4': x_pause__mutmut_4, 
    'x_pause__mutmut_5': x_pause__mutmut_5, 
    'x_pause__mutmut_6': x_pause__mutmut_6, 
    'x_pause__mutmut_7': x_pause__mutmut_7
}

def pause(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_pause__mutmut_orig, x_pause__mutmut_mutants, args, kwargs)
    return result 

pause.__signature__ = _mutmut_signature(x_pause__mutmut_orig)
x_pause__mutmut_orig.__name__ = 'x_pause'


def x_pause_on_async_call__mutmut_orig(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pauseOnAsyncCall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_1(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = None
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pauseOnAsyncCall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_2(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pauseOnAsyncCall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_3(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["XXparentStackTraceIdXX"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pauseOnAsyncCall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_4(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentstacktraceid"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pauseOnAsyncCall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_5(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["PARENTSTACKTRACEID"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pauseOnAsyncCall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_6(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["Parentstacktraceid"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pauseOnAsyncCall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_7(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_pause_on_async_call__mutmut_8(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.pauseOnAsyncCall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_9(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.pauseOnAsyncCall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_10(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.pauseOnAsyncCall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_11(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.pauseOnAsyncCallXX",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_12(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.pauseonasynccall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_13(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.PAUSEONASYNCCALL",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_14(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pauseonasynccall",
        "params": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_15(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pauseOnAsyncCall",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_16(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pauseOnAsyncCall",
        "PARAMS": params,
    }
    yield cmd_dict


def x_pause_on_async_call__mutmut_17(
    parent_stack_trace_id: runtime.StackTraceId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """


    **EXPERIMENTAL**

    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started.
    """
    params: T_JSON_DICT = {}
    params["parentStackTraceId"] = parent_stack_trace_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.pauseOnAsyncCall",
        "Params": params,
    }
    yield cmd_dict

x_pause_on_async_call__mutmut_mutants : ClassVar[MutantDict] = {
'x_pause_on_async_call__mutmut_1': x_pause_on_async_call__mutmut_1, 
    'x_pause_on_async_call__mutmut_2': x_pause_on_async_call__mutmut_2, 
    'x_pause_on_async_call__mutmut_3': x_pause_on_async_call__mutmut_3, 
    'x_pause_on_async_call__mutmut_4': x_pause_on_async_call__mutmut_4, 
    'x_pause_on_async_call__mutmut_5': x_pause_on_async_call__mutmut_5, 
    'x_pause_on_async_call__mutmut_6': x_pause_on_async_call__mutmut_6, 
    'x_pause_on_async_call__mutmut_7': x_pause_on_async_call__mutmut_7, 
    'x_pause_on_async_call__mutmut_8': x_pause_on_async_call__mutmut_8, 
    'x_pause_on_async_call__mutmut_9': x_pause_on_async_call__mutmut_9, 
    'x_pause_on_async_call__mutmut_10': x_pause_on_async_call__mutmut_10, 
    'x_pause_on_async_call__mutmut_11': x_pause_on_async_call__mutmut_11, 
    'x_pause_on_async_call__mutmut_12': x_pause_on_async_call__mutmut_12, 
    'x_pause_on_async_call__mutmut_13': x_pause_on_async_call__mutmut_13, 
    'x_pause_on_async_call__mutmut_14': x_pause_on_async_call__mutmut_14, 
    'x_pause_on_async_call__mutmut_15': x_pause_on_async_call__mutmut_15, 
    'x_pause_on_async_call__mutmut_16': x_pause_on_async_call__mutmut_16, 
    'x_pause_on_async_call__mutmut_17': x_pause_on_async_call__mutmut_17
}

def pause_on_async_call(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_pause_on_async_call__mutmut_orig, x_pause_on_async_call__mutmut_mutants, args, kwargs)
    return result 

pause_on_async_call.__signature__ = _mutmut_signature(x_pause_on_async_call__mutmut_orig)
x_pause_on_async_call__mutmut_orig.__name__ = 'x_pause_on_async_call'


def x_remove_breakpoint__mutmut_orig(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.removeBreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_1(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = None
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.removeBreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_2(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.removeBreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_3(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["XXbreakpointIdXX"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.removeBreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_4(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointid"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.removeBreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_5(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["BREAKPOINTID"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.removeBreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_6(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["Breakpointid"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.removeBreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_7(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_remove_breakpoint__mutmut_8(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.removeBreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_9(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.removeBreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_10(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.removeBreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_11(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.removeBreakpointXX",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_12(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.removebreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_13(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.REMOVEBREAKPOINT",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_14(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.removebreakpoint",
        "params": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_15(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.removeBreakpoint",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_16(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.removeBreakpoint",
        "PARAMS": params,
    }
    yield cmd_dict


def x_remove_breakpoint__mutmut_17(
    breakpoint_id: BreakpointId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Removes JavaScript breakpoint.

    :param breakpoint_id:
    """
    params: T_JSON_DICT = {}
    params["breakpointId"] = breakpoint_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.removeBreakpoint",
        "Params": params,
    }
    yield cmd_dict

x_remove_breakpoint__mutmut_mutants : ClassVar[MutantDict] = {
'x_remove_breakpoint__mutmut_1': x_remove_breakpoint__mutmut_1, 
    'x_remove_breakpoint__mutmut_2': x_remove_breakpoint__mutmut_2, 
    'x_remove_breakpoint__mutmut_3': x_remove_breakpoint__mutmut_3, 
    'x_remove_breakpoint__mutmut_4': x_remove_breakpoint__mutmut_4, 
    'x_remove_breakpoint__mutmut_5': x_remove_breakpoint__mutmut_5, 
    'x_remove_breakpoint__mutmut_6': x_remove_breakpoint__mutmut_6, 
    'x_remove_breakpoint__mutmut_7': x_remove_breakpoint__mutmut_7, 
    'x_remove_breakpoint__mutmut_8': x_remove_breakpoint__mutmut_8, 
    'x_remove_breakpoint__mutmut_9': x_remove_breakpoint__mutmut_9, 
    'x_remove_breakpoint__mutmut_10': x_remove_breakpoint__mutmut_10, 
    'x_remove_breakpoint__mutmut_11': x_remove_breakpoint__mutmut_11, 
    'x_remove_breakpoint__mutmut_12': x_remove_breakpoint__mutmut_12, 
    'x_remove_breakpoint__mutmut_13': x_remove_breakpoint__mutmut_13, 
    'x_remove_breakpoint__mutmut_14': x_remove_breakpoint__mutmut_14, 
    'x_remove_breakpoint__mutmut_15': x_remove_breakpoint__mutmut_15, 
    'x_remove_breakpoint__mutmut_16': x_remove_breakpoint__mutmut_16, 
    'x_remove_breakpoint__mutmut_17': x_remove_breakpoint__mutmut_17
}

def remove_breakpoint(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_remove_breakpoint__mutmut_orig, x_remove_breakpoint__mutmut_mutants, args, kwargs)
    return result 

remove_breakpoint.__signature__ = _mutmut_signature(x_remove_breakpoint__mutmut_orig)
x_remove_breakpoint__mutmut_orig.__name__ = 'x_remove_breakpoint'


def x_restart_frame__mutmut_orig(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_1(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = None
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_2(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = None
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_3(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["XXcallFrameIdXX"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_4(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callframeid"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_5(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["CALLFRAMEID"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_6(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["Callframeid"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_7(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_8(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_9(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["XXmodeXX"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_10(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["MODE"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_11(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["Mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_12(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_13(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_14(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_15(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_16(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.restartFrameXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_17(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.restartframe",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_18(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.RESTARTFRAME",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_19(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartframe",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_20(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_21(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_22(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_23(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = None
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_24(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(None) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_25(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["XXcallFramesXX"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_26(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callframes"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_27(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["CALLFRAMES"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_28(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["Callframes"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_29(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(None) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_30(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["XXasyncStackTraceXX"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_31(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncstacktrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_32(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["ASYNCSTACKTRACE"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_33(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["Asyncstacktrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_34(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "XXasyncStackTraceXX" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_35(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncstacktrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_36(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "ASYNCSTACKTRACE" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_37(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "Asyncstacktrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_38(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" not in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_39(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(None) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_40(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["XXasyncStackTraceIdXX"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_41(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncstacktraceid"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_42(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["ASYNCSTACKTRACEID"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_43(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["Asyncstacktraceid"]) if "asyncStackTraceId" in json else None,
    )


def x_restart_frame__mutmut_44(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "XXasyncStackTraceIdXX" in json else None,
    )


def x_restart_frame__mutmut_45(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncstacktraceid" in json else None,
    )


def x_restart_frame__mutmut_46(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "ASYNCSTACKTRACEID" in json else None,
    )


def x_restart_frame__mutmut_47(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "Asyncstacktraceid" in json else None,
    )


def x_restart_frame__mutmut_48(
    call_frame_id: CallFrameId,
    mode: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]:
    """
    Restarts particular call frame from the beginning. The old, deprecated
    behavior of ``restartFrame`` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, ``restartFrame`` now expects a ``mode``
    parameter to be present. If the ``mode`` parameter is missing, ``restartFrame``
    errors out.

    The various return values are deprecated and ``callFrames`` is always empty.
    Use the call frames from the ``Debugger#paused`` events instead, that fires
    once V8 pauses at the beginning of the restarted function.

    :param call_frame_id: Call frame identifier to evaluate on.
    :param mode: **(EXPERIMENTAL)** *(Optional)* The ```mode```` parameter must be present and set to 'StepInto', otherwise ````restartFrame``` will error out.
    :returns: A tuple with the following items:

        0. **callFrames** - New stack trace.
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
    """
    params: T_JSON_DICT = {}
    params["callFrameId"] = call_frame_id.to_json()
    if mode is not None:
        params["mode"] = mode
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.restartFrame",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]],
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" not in json else None,
    )

x_restart_frame__mutmut_mutants : ClassVar[MutantDict] = {
'x_restart_frame__mutmut_1': x_restart_frame__mutmut_1, 
    'x_restart_frame__mutmut_2': x_restart_frame__mutmut_2, 
    'x_restart_frame__mutmut_3': x_restart_frame__mutmut_3, 
    'x_restart_frame__mutmut_4': x_restart_frame__mutmut_4, 
    'x_restart_frame__mutmut_5': x_restart_frame__mutmut_5, 
    'x_restart_frame__mutmut_6': x_restart_frame__mutmut_6, 
    'x_restart_frame__mutmut_7': x_restart_frame__mutmut_7, 
    'x_restart_frame__mutmut_8': x_restart_frame__mutmut_8, 
    'x_restart_frame__mutmut_9': x_restart_frame__mutmut_9, 
    'x_restart_frame__mutmut_10': x_restart_frame__mutmut_10, 
    'x_restart_frame__mutmut_11': x_restart_frame__mutmut_11, 
    'x_restart_frame__mutmut_12': x_restart_frame__mutmut_12, 
    'x_restart_frame__mutmut_13': x_restart_frame__mutmut_13, 
    'x_restart_frame__mutmut_14': x_restart_frame__mutmut_14, 
    'x_restart_frame__mutmut_15': x_restart_frame__mutmut_15, 
    'x_restart_frame__mutmut_16': x_restart_frame__mutmut_16, 
    'x_restart_frame__mutmut_17': x_restart_frame__mutmut_17, 
    'x_restart_frame__mutmut_18': x_restart_frame__mutmut_18, 
    'x_restart_frame__mutmut_19': x_restart_frame__mutmut_19, 
    'x_restart_frame__mutmut_20': x_restart_frame__mutmut_20, 
    'x_restart_frame__mutmut_21': x_restart_frame__mutmut_21, 
    'x_restart_frame__mutmut_22': x_restart_frame__mutmut_22, 
    'x_restart_frame__mutmut_23': x_restart_frame__mutmut_23, 
    'x_restart_frame__mutmut_24': x_restart_frame__mutmut_24, 
    'x_restart_frame__mutmut_25': x_restart_frame__mutmut_25, 
    'x_restart_frame__mutmut_26': x_restart_frame__mutmut_26, 
    'x_restart_frame__mutmut_27': x_restart_frame__mutmut_27, 
    'x_restart_frame__mutmut_28': x_restart_frame__mutmut_28, 
    'x_restart_frame__mutmut_29': x_restart_frame__mutmut_29, 
    'x_restart_frame__mutmut_30': x_restart_frame__mutmut_30, 
    'x_restart_frame__mutmut_31': x_restart_frame__mutmut_31, 
    'x_restart_frame__mutmut_32': x_restart_frame__mutmut_32, 
    'x_restart_frame__mutmut_33': x_restart_frame__mutmut_33, 
    'x_restart_frame__mutmut_34': x_restart_frame__mutmut_34, 
    'x_restart_frame__mutmut_35': x_restart_frame__mutmut_35, 
    'x_restart_frame__mutmut_36': x_restart_frame__mutmut_36, 
    'x_restart_frame__mutmut_37': x_restart_frame__mutmut_37, 
    'x_restart_frame__mutmut_38': x_restart_frame__mutmut_38, 
    'x_restart_frame__mutmut_39': x_restart_frame__mutmut_39, 
    'x_restart_frame__mutmut_40': x_restart_frame__mutmut_40, 
    'x_restart_frame__mutmut_41': x_restart_frame__mutmut_41, 
    'x_restart_frame__mutmut_42': x_restart_frame__mutmut_42, 
    'x_restart_frame__mutmut_43': x_restart_frame__mutmut_43, 
    'x_restart_frame__mutmut_44': x_restart_frame__mutmut_44, 
    'x_restart_frame__mutmut_45': x_restart_frame__mutmut_45, 
    'x_restart_frame__mutmut_46': x_restart_frame__mutmut_46, 
    'x_restart_frame__mutmut_47': x_restart_frame__mutmut_47, 
    'x_restart_frame__mutmut_48': x_restart_frame__mutmut_48
}

def restart_frame(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_restart_frame__mutmut_orig, x_restart_frame__mutmut_mutants, args, kwargs)
    return result 

restart_frame.__signature__ = _mutmut_signature(x_restart_frame__mutmut_orig)
x_restart_frame__mutmut_orig.__name__ = 'x_restart_frame'


def x_resume__mutmut_orig(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_1(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = None
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_2(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_3(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_4(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["XXterminateOnResumeXX"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_5(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateonresume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_6(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["TERMINATEONRESUME"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_7(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["Terminateonresume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_8(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_resume__mutmut_9(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_10(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_11(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_12(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.resumeXX",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_13(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.resume",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_14(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.RESUME",
        "params": params,
    }
    yield cmd_dict


def x_resume__mutmut_15(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.resume",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_resume__mutmut_16(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.resume",
        "PARAMS": params,
    }
    yield cmd_dict


def x_resume__mutmut_17(
    terminate_on_resume: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Resumes JavaScript execution.

    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
    """
    params: T_JSON_DICT = {}
    if terminate_on_resume is not None:
        params["terminateOnResume"] = terminate_on_resume
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.resume",
        "Params": params,
    }
    yield cmd_dict

x_resume__mutmut_mutants : ClassVar[MutantDict] = {
'x_resume__mutmut_1': x_resume__mutmut_1, 
    'x_resume__mutmut_2': x_resume__mutmut_2, 
    'x_resume__mutmut_3': x_resume__mutmut_3, 
    'x_resume__mutmut_4': x_resume__mutmut_4, 
    'x_resume__mutmut_5': x_resume__mutmut_5, 
    'x_resume__mutmut_6': x_resume__mutmut_6, 
    'x_resume__mutmut_7': x_resume__mutmut_7, 
    'x_resume__mutmut_8': x_resume__mutmut_8, 
    'x_resume__mutmut_9': x_resume__mutmut_9, 
    'x_resume__mutmut_10': x_resume__mutmut_10, 
    'x_resume__mutmut_11': x_resume__mutmut_11, 
    'x_resume__mutmut_12': x_resume__mutmut_12, 
    'x_resume__mutmut_13': x_resume__mutmut_13, 
    'x_resume__mutmut_14': x_resume__mutmut_14, 
    'x_resume__mutmut_15': x_resume__mutmut_15, 
    'x_resume__mutmut_16': x_resume__mutmut_16, 
    'x_resume__mutmut_17': x_resume__mutmut_17
}

def resume(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_resume__mutmut_orig, x_resume__mutmut_mutants, args, kwargs)
    return result 

resume.__signature__ = _mutmut_signature(x_resume__mutmut_orig)
x_resume__mutmut_orig.__name__ = 'x_resume'


def x_search_in_content__mutmut_orig(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_1(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = None
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_2(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = None
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_3(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["XXscriptIdXX"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_4(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptid"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_5(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["SCRIPTID"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_6(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["Scriptid"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_7(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = None
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_8(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["XXqueryXX"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_9(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["QUERY"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_10(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["Query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_11(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_12(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = None
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_13(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["XXcaseSensitiveXX"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_14(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["casesensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_15(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["CASESENSITIVE"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_16(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["Casesensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_17(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_18(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_19(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["XXisRegexXX"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_20(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isregex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_21(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["ISREGEX"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_22(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["Isregex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_23(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_24(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_25(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_26(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_27(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.searchInContentXX",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_28(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.searchincontent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_29(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SEARCHINCONTENT",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_30(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchincontent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_31(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_32(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_33(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "Params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_34(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = None
    return [SearchMatch.from_json(i) for i in json["result"]]


def x_search_in_content__mutmut_35(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(None) for i in json["result"]]


def x_search_in_content__mutmut_36(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["XXresultXX"]]


def x_search_in_content__mutmut_37(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["RESULT"]]


def x_search_in_content__mutmut_38(
    script_id: runtime.ScriptId,
    query: str,
    case_sensitive: bool | None = None,
    is_regex: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]:
    """
    Searches for given string in script content.

    :param script_id: Id of the script to search in.
    :param query: String to search for.
    :param case_sensitive: *(Optional)* If true, search is case sensitive.
    :param is_regex: *(Optional)* If true, treats string parameter as regex.
    :returns: List of search matches.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["query"] = query
    if case_sensitive is not None:
        params["caseSensitive"] = case_sensitive
    if is_regex is not None:
        params["isRegex"] = is_regex
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.searchInContent",
        "params": params,
    }
    json = yield cmd_dict
    return [SearchMatch.from_json(i) for i in json["Result"]]

x_search_in_content__mutmut_mutants : ClassVar[MutantDict] = {
'x_search_in_content__mutmut_1': x_search_in_content__mutmut_1, 
    'x_search_in_content__mutmut_2': x_search_in_content__mutmut_2, 
    'x_search_in_content__mutmut_3': x_search_in_content__mutmut_3, 
    'x_search_in_content__mutmut_4': x_search_in_content__mutmut_4, 
    'x_search_in_content__mutmut_5': x_search_in_content__mutmut_5, 
    'x_search_in_content__mutmut_6': x_search_in_content__mutmut_6, 
    'x_search_in_content__mutmut_7': x_search_in_content__mutmut_7, 
    'x_search_in_content__mutmut_8': x_search_in_content__mutmut_8, 
    'x_search_in_content__mutmut_9': x_search_in_content__mutmut_9, 
    'x_search_in_content__mutmut_10': x_search_in_content__mutmut_10, 
    'x_search_in_content__mutmut_11': x_search_in_content__mutmut_11, 
    'x_search_in_content__mutmut_12': x_search_in_content__mutmut_12, 
    'x_search_in_content__mutmut_13': x_search_in_content__mutmut_13, 
    'x_search_in_content__mutmut_14': x_search_in_content__mutmut_14, 
    'x_search_in_content__mutmut_15': x_search_in_content__mutmut_15, 
    'x_search_in_content__mutmut_16': x_search_in_content__mutmut_16, 
    'x_search_in_content__mutmut_17': x_search_in_content__mutmut_17, 
    'x_search_in_content__mutmut_18': x_search_in_content__mutmut_18, 
    'x_search_in_content__mutmut_19': x_search_in_content__mutmut_19, 
    'x_search_in_content__mutmut_20': x_search_in_content__mutmut_20, 
    'x_search_in_content__mutmut_21': x_search_in_content__mutmut_21, 
    'x_search_in_content__mutmut_22': x_search_in_content__mutmut_22, 
    'x_search_in_content__mutmut_23': x_search_in_content__mutmut_23, 
    'x_search_in_content__mutmut_24': x_search_in_content__mutmut_24, 
    'x_search_in_content__mutmut_25': x_search_in_content__mutmut_25, 
    'x_search_in_content__mutmut_26': x_search_in_content__mutmut_26, 
    'x_search_in_content__mutmut_27': x_search_in_content__mutmut_27, 
    'x_search_in_content__mutmut_28': x_search_in_content__mutmut_28, 
    'x_search_in_content__mutmut_29': x_search_in_content__mutmut_29, 
    'x_search_in_content__mutmut_30': x_search_in_content__mutmut_30, 
    'x_search_in_content__mutmut_31': x_search_in_content__mutmut_31, 
    'x_search_in_content__mutmut_32': x_search_in_content__mutmut_32, 
    'x_search_in_content__mutmut_33': x_search_in_content__mutmut_33, 
    'x_search_in_content__mutmut_34': x_search_in_content__mutmut_34, 
    'x_search_in_content__mutmut_35': x_search_in_content__mutmut_35, 
    'x_search_in_content__mutmut_36': x_search_in_content__mutmut_36, 
    'x_search_in_content__mutmut_37': x_search_in_content__mutmut_37, 
    'x_search_in_content__mutmut_38': x_search_in_content__mutmut_38
}

def search_in_content(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_search_in_content__mutmut_orig, x_search_in_content__mutmut_mutants, args, kwargs)
    return result 

search_in_content.__signature__ = _mutmut_signature(x_search_in_content__mutmut_orig)
x_search_in_content__mutmut_orig.__name__ = 'x_search_in_content'


def x_set_async_call_stack_depth__mutmut_orig(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_1(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = None
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_2(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_3(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["XXmaxDepthXX"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_4(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxdepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_5(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["MAXDEPTH"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_6(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["Maxdepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_7(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_8(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_9(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_10(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setAsyncCallStackDepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_11(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setAsyncCallStackDepthXX",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_12(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setasynccallstackdepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_13(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETASYNCCALLSTACKDEPTH",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_14(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setasynccallstackdepth",
        "params": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_15(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setAsyncCallStackDepth",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_16(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setAsyncCallStackDepth",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_async_call_stack_depth__mutmut_17(
    max_depth: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Enables or disables async call stacks tracking.

    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default).
    """
    params: T_JSON_DICT = {}
    params["maxDepth"] = max_depth
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setAsyncCallStackDepth",
        "Params": params,
    }
    yield cmd_dict

x_set_async_call_stack_depth__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_async_call_stack_depth__mutmut_1': x_set_async_call_stack_depth__mutmut_1, 
    'x_set_async_call_stack_depth__mutmut_2': x_set_async_call_stack_depth__mutmut_2, 
    'x_set_async_call_stack_depth__mutmut_3': x_set_async_call_stack_depth__mutmut_3, 
    'x_set_async_call_stack_depth__mutmut_4': x_set_async_call_stack_depth__mutmut_4, 
    'x_set_async_call_stack_depth__mutmut_5': x_set_async_call_stack_depth__mutmut_5, 
    'x_set_async_call_stack_depth__mutmut_6': x_set_async_call_stack_depth__mutmut_6, 
    'x_set_async_call_stack_depth__mutmut_7': x_set_async_call_stack_depth__mutmut_7, 
    'x_set_async_call_stack_depth__mutmut_8': x_set_async_call_stack_depth__mutmut_8, 
    'x_set_async_call_stack_depth__mutmut_9': x_set_async_call_stack_depth__mutmut_9, 
    'x_set_async_call_stack_depth__mutmut_10': x_set_async_call_stack_depth__mutmut_10, 
    'x_set_async_call_stack_depth__mutmut_11': x_set_async_call_stack_depth__mutmut_11, 
    'x_set_async_call_stack_depth__mutmut_12': x_set_async_call_stack_depth__mutmut_12, 
    'x_set_async_call_stack_depth__mutmut_13': x_set_async_call_stack_depth__mutmut_13, 
    'x_set_async_call_stack_depth__mutmut_14': x_set_async_call_stack_depth__mutmut_14, 
    'x_set_async_call_stack_depth__mutmut_15': x_set_async_call_stack_depth__mutmut_15, 
    'x_set_async_call_stack_depth__mutmut_16': x_set_async_call_stack_depth__mutmut_16, 
    'x_set_async_call_stack_depth__mutmut_17': x_set_async_call_stack_depth__mutmut_17
}

def set_async_call_stack_depth(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_async_call_stack_depth__mutmut_orig, x_set_async_call_stack_depth__mutmut_mutants, args, kwargs)
    return result 

set_async_call_stack_depth.__signature__ = _mutmut_signature(x_set_async_call_stack_depth__mutmut_orig)
x_set_async_call_stack_depth__mutmut_orig.__name__ = 'x_set_async_call_stack_depth'


def x_set_blackbox_execution_contexts__mutmut_orig(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxExecutionContexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_1(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = None
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxExecutionContexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_2(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxExecutionContexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_3(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["XXuniqueIdsXX"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxExecutionContexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_4(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueids"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxExecutionContexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_5(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["UNIQUEIDS"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxExecutionContexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_6(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["Uniqueids"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxExecutionContexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_7(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(None)
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxExecutionContexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_8(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_9(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setBlackboxExecutionContexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_10(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setBlackboxExecutionContexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_11(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setBlackboxExecutionContexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_12(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setBlackboxExecutionContextsXX",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_13(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setblackboxexecutioncontexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_14(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETBLACKBOXEXECUTIONCONTEXTS",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_15(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setblackboxexecutioncontexts",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_16(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxExecutionContexts",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_17(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxExecutionContexts",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_blackbox_execution_contexts__mutmut_18(
    unique_ids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param unique_ids: Array of execution context unique ids for the debugger to ignore.
    """
    params: T_JSON_DICT = {}
    params["uniqueIds"] = list(unique_ids)
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxExecutionContexts",
        "Params": params,
    }
    yield cmd_dict

x_set_blackbox_execution_contexts__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_blackbox_execution_contexts__mutmut_1': x_set_blackbox_execution_contexts__mutmut_1, 
    'x_set_blackbox_execution_contexts__mutmut_2': x_set_blackbox_execution_contexts__mutmut_2, 
    'x_set_blackbox_execution_contexts__mutmut_3': x_set_blackbox_execution_contexts__mutmut_3, 
    'x_set_blackbox_execution_contexts__mutmut_4': x_set_blackbox_execution_contexts__mutmut_4, 
    'x_set_blackbox_execution_contexts__mutmut_5': x_set_blackbox_execution_contexts__mutmut_5, 
    'x_set_blackbox_execution_contexts__mutmut_6': x_set_blackbox_execution_contexts__mutmut_6, 
    'x_set_blackbox_execution_contexts__mutmut_7': x_set_blackbox_execution_contexts__mutmut_7, 
    'x_set_blackbox_execution_contexts__mutmut_8': x_set_blackbox_execution_contexts__mutmut_8, 
    'x_set_blackbox_execution_contexts__mutmut_9': x_set_blackbox_execution_contexts__mutmut_9, 
    'x_set_blackbox_execution_contexts__mutmut_10': x_set_blackbox_execution_contexts__mutmut_10, 
    'x_set_blackbox_execution_contexts__mutmut_11': x_set_blackbox_execution_contexts__mutmut_11, 
    'x_set_blackbox_execution_contexts__mutmut_12': x_set_blackbox_execution_contexts__mutmut_12, 
    'x_set_blackbox_execution_contexts__mutmut_13': x_set_blackbox_execution_contexts__mutmut_13, 
    'x_set_blackbox_execution_contexts__mutmut_14': x_set_blackbox_execution_contexts__mutmut_14, 
    'x_set_blackbox_execution_contexts__mutmut_15': x_set_blackbox_execution_contexts__mutmut_15, 
    'x_set_blackbox_execution_contexts__mutmut_16': x_set_blackbox_execution_contexts__mutmut_16, 
    'x_set_blackbox_execution_contexts__mutmut_17': x_set_blackbox_execution_contexts__mutmut_17, 
    'x_set_blackbox_execution_contexts__mutmut_18': x_set_blackbox_execution_contexts__mutmut_18
}

def set_blackbox_execution_contexts(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_blackbox_execution_contexts__mutmut_orig, x_set_blackbox_execution_contexts__mutmut_mutants, args, kwargs)
    return result 

set_blackbox_execution_contexts.__signature__ = _mutmut_signature(x_set_blackbox_execution_contexts__mutmut_orig)
x_set_blackbox_execution_contexts__mutmut_orig.__name__ = 'x_set_blackbox_execution_contexts'


def x_set_blackbox_patterns__mutmut_orig(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_1(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = None
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_2(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = None
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_3(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["XXpatternsXX"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_4(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["PATTERNS"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_5(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["Patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_6(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(None)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_7(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_8(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_9(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["XXskipAnonymousXX"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_10(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipanonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_11(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["SKIPANONYMOUS"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_12(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["Skipanonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_13(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_14(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_15(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_16(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setBlackboxPatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_17(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setBlackboxPatternsXX",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_18(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setblackboxpatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_19(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETBLACKBOXPATTERNS",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_20(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setblackboxpatterns",
        "params": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_21(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_22(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_blackbox_patterns__mutmut_23(
    patterns: list[str],
    skip_anonymous: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful.

    **EXPERIMENTAL**

    :param patterns: Array of regexps that will be used to check script url for blackbox state.
    :param skip_anonymous: *(Optional)* If true, also ignore scripts with no source url.
    """
    params: T_JSON_DICT = {}
    params["patterns"] = list(patterns)
    if skip_anonymous is not None:
        params["skipAnonymous"] = skip_anonymous
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxPatterns",
        "Params": params,
    }
    yield cmd_dict

x_set_blackbox_patterns__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_blackbox_patterns__mutmut_1': x_set_blackbox_patterns__mutmut_1, 
    'x_set_blackbox_patterns__mutmut_2': x_set_blackbox_patterns__mutmut_2, 
    'x_set_blackbox_patterns__mutmut_3': x_set_blackbox_patterns__mutmut_3, 
    'x_set_blackbox_patterns__mutmut_4': x_set_blackbox_patterns__mutmut_4, 
    'x_set_blackbox_patterns__mutmut_5': x_set_blackbox_patterns__mutmut_5, 
    'x_set_blackbox_patterns__mutmut_6': x_set_blackbox_patterns__mutmut_6, 
    'x_set_blackbox_patterns__mutmut_7': x_set_blackbox_patterns__mutmut_7, 
    'x_set_blackbox_patterns__mutmut_8': x_set_blackbox_patterns__mutmut_8, 
    'x_set_blackbox_patterns__mutmut_9': x_set_blackbox_patterns__mutmut_9, 
    'x_set_blackbox_patterns__mutmut_10': x_set_blackbox_patterns__mutmut_10, 
    'x_set_blackbox_patterns__mutmut_11': x_set_blackbox_patterns__mutmut_11, 
    'x_set_blackbox_patterns__mutmut_12': x_set_blackbox_patterns__mutmut_12, 
    'x_set_blackbox_patterns__mutmut_13': x_set_blackbox_patterns__mutmut_13, 
    'x_set_blackbox_patterns__mutmut_14': x_set_blackbox_patterns__mutmut_14, 
    'x_set_blackbox_patterns__mutmut_15': x_set_blackbox_patterns__mutmut_15, 
    'x_set_blackbox_patterns__mutmut_16': x_set_blackbox_patterns__mutmut_16, 
    'x_set_blackbox_patterns__mutmut_17': x_set_blackbox_patterns__mutmut_17, 
    'x_set_blackbox_patterns__mutmut_18': x_set_blackbox_patterns__mutmut_18, 
    'x_set_blackbox_patterns__mutmut_19': x_set_blackbox_patterns__mutmut_19, 
    'x_set_blackbox_patterns__mutmut_20': x_set_blackbox_patterns__mutmut_20, 
    'x_set_blackbox_patterns__mutmut_21': x_set_blackbox_patterns__mutmut_21, 
    'x_set_blackbox_patterns__mutmut_22': x_set_blackbox_patterns__mutmut_22, 
    'x_set_blackbox_patterns__mutmut_23': x_set_blackbox_patterns__mutmut_23
}

def set_blackbox_patterns(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_blackbox_patterns__mutmut_orig, x_set_blackbox_patterns__mutmut_mutants, args, kwargs)
    return result 

set_blackbox_patterns.__signature__ = _mutmut_signature(x_set_blackbox_patterns__mutmut_orig)
x_set_blackbox_patterns__mutmut_orig.__name__ = 'x_set_blackbox_patterns'


def x_set_blackboxed_ranges__mutmut_orig(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_1(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = None
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_2(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = None
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_3(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["XXscriptIdXX"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_4(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptid"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_5(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["SCRIPTID"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_6(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["Scriptid"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_7(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_8(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["XXpositionsXX"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_9(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["POSITIONS"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_10(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["Positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_11(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_12(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_13(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_14(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setBlackboxedRanges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_15(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setBlackboxedRangesXX",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_16(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setblackboxedranges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_17(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETBLACKBOXEDRANGES",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_18(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setblackboxedranges",
        "params": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_19(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_20(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_blackboxed_ranges__mutmut_21(
    script_id: runtime.ScriptId,
    positions: list[ScriptPosition],
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted.

    **EXPERIMENTAL**

    :param script_id: Id of the script.
    :param positions:
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["positions"] = [i.to_json() for i in positions]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBlackboxedRanges",
        "Params": params,
    }
    yield cmd_dict

x_set_blackboxed_ranges__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_blackboxed_ranges__mutmut_1': x_set_blackboxed_ranges__mutmut_1, 
    'x_set_blackboxed_ranges__mutmut_2': x_set_blackboxed_ranges__mutmut_2, 
    'x_set_blackboxed_ranges__mutmut_3': x_set_blackboxed_ranges__mutmut_3, 
    'x_set_blackboxed_ranges__mutmut_4': x_set_blackboxed_ranges__mutmut_4, 
    'x_set_blackboxed_ranges__mutmut_5': x_set_blackboxed_ranges__mutmut_5, 
    'x_set_blackboxed_ranges__mutmut_6': x_set_blackboxed_ranges__mutmut_6, 
    'x_set_blackboxed_ranges__mutmut_7': x_set_blackboxed_ranges__mutmut_7, 
    'x_set_blackboxed_ranges__mutmut_8': x_set_blackboxed_ranges__mutmut_8, 
    'x_set_blackboxed_ranges__mutmut_9': x_set_blackboxed_ranges__mutmut_9, 
    'x_set_blackboxed_ranges__mutmut_10': x_set_blackboxed_ranges__mutmut_10, 
    'x_set_blackboxed_ranges__mutmut_11': x_set_blackboxed_ranges__mutmut_11, 
    'x_set_blackboxed_ranges__mutmut_12': x_set_blackboxed_ranges__mutmut_12, 
    'x_set_blackboxed_ranges__mutmut_13': x_set_blackboxed_ranges__mutmut_13, 
    'x_set_blackboxed_ranges__mutmut_14': x_set_blackboxed_ranges__mutmut_14, 
    'x_set_blackboxed_ranges__mutmut_15': x_set_blackboxed_ranges__mutmut_15, 
    'x_set_blackboxed_ranges__mutmut_16': x_set_blackboxed_ranges__mutmut_16, 
    'x_set_blackboxed_ranges__mutmut_17': x_set_blackboxed_ranges__mutmut_17, 
    'x_set_blackboxed_ranges__mutmut_18': x_set_blackboxed_ranges__mutmut_18, 
    'x_set_blackboxed_ranges__mutmut_19': x_set_blackboxed_ranges__mutmut_19, 
    'x_set_blackboxed_ranges__mutmut_20': x_set_blackboxed_ranges__mutmut_20, 
    'x_set_blackboxed_ranges__mutmut_21': x_set_blackboxed_ranges__mutmut_21
}

def set_blackboxed_ranges(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_blackboxed_ranges__mutmut_orig, x_set_blackboxed_ranges__mutmut_mutants, args, kwargs)
    return result 

set_blackboxed_ranges.__signature__ = _mutmut_signature(x_set_blackboxed_ranges__mutmut_orig)
x_set_blackboxed_ranges__mutmut_orig.__name__ = 'x_set_blackboxed_ranges'


def x_set_breakpoint__mutmut_orig(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_1(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = None
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_2(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = None
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_3(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["XXlocationXX"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_4(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["LOCATION"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_5(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["Location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_6(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_7(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_8(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["XXconditionXX"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_9(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["CONDITION"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_10(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["Condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_11(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_12(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_13(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_14(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_15(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setBreakpointXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_16(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setbreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_17(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETBREAKPOINT",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_18(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setbreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_19(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_20(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_21(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_22(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = None
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_23(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(None),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_24(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["XXbreakpointIdXX"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_25(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointid"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_26(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["BREAKPOINTID"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_27(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["Breakpointid"]),
        Location.from_json(json["actualLocation"]),
    )


def x_set_breakpoint__mutmut_28(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(None),
    )


def x_set_breakpoint__mutmut_29(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["XXactualLocationXX"]),
    )


def x_set_breakpoint__mutmut_30(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["actuallocation"]),
    )


def x_set_breakpoint__mutmut_31(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["ACTUALLOCATION"]),
    )


def x_set_breakpoint__mutmut_32(
    location: Location,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]:
    """
    Sets JavaScript breakpoint at a given location.

    :param location: Location to set breakpoint in.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **actualLocation** - Location this breakpoint resolved into.
    """
    params: T_JSON_DICT = {}
    params["location"] = location.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        Location.from_json(json["Actuallocation"]),
    )

x_set_breakpoint__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_breakpoint__mutmut_1': x_set_breakpoint__mutmut_1, 
    'x_set_breakpoint__mutmut_2': x_set_breakpoint__mutmut_2, 
    'x_set_breakpoint__mutmut_3': x_set_breakpoint__mutmut_3, 
    'x_set_breakpoint__mutmut_4': x_set_breakpoint__mutmut_4, 
    'x_set_breakpoint__mutmut_5': x_set_breakpoint__mutmut_5, 
    'x_set_breakpoint__mutmut_6': x_set_breakpoint__mutmut_6, 
    'x_set_breakpoint__mutmut_7': x_set_breakpoint__mutmut_7, 
    'x_set_breakpoint__mutmut_8': x_set_breakpoint__mutmut_8, 
    'x_set_breakpoint__mutmut_9': x_set_breakpoint__mutmut_9, 
    'x_set_breakpoint__mutmut_10': x_set_breakpoint__mutmut_10, 
    'x_set_breakpoint__mutmut_11': x_set_breakpoint__mutmut_11, 
    'x_set_breakpoint__mutmut_12': x_set_breakpoint__mutmut_12, 
    'x_set_breakpoint__mutmut_13': x_set_breakpoint__mutmut_13, 
    'x_set_breakpoint__mutmut_14': x_set_breakpoint__mutmut_14, 
    'x_set_breakpoint__mutmut_15': x_set_breakpoint__mutmut_15, 
    'x_set_breakpoint__mutmut_16': x_set_breakpoint__mutmut_16, 
    'x_set_breakpoint__mutmut_17': x_set_breakpoint__mutmut_17, 
    'x_set_breakpoint__mutmut_18': x_set_breakpoint__mutmut_18, 
    'x_set_breakpoint__mutmut_19': x_set_breakpoint__mutmut_19, 
    'x_set_breakpoint__mutmut_20': x_set_breakpoint__mutmut_20, 
    'x_set_breakpoint__mutmut_21': x_set_breakpoint__mutmut_21, 
    'x_set_breakpoint__mutmut_22': x_set_breakpoint__mutmut_22, 
    'x_set_breakpoint__mutmut_23': x_set_breakpoint__mutmut_23, 
    'x_set_breakpoint__mutmut_24': x_set_breakpoint__mutmut_24, 
    'x_set_breakpoint__mutmut_25': x_set_breakpoint__mutmut_25, 
    'x_set_breakpoint__mutmut_26': x_set_breakpoint__mutmut_26, 
    'x_set_breakpoint__mutmut_27': x_set_breakpoint__mutmut_27, 
    'x_set_breakpoint__mutmut_28': x_set_breakpoint__mutmut_28, 
    'x_set_breakpoint__mutmut_29': x_set_breakpoint__mutmut_29, 
    'x_set_breakpoint__mutmut_30': x_set_breakpoint__mutmut_30, 
    'x_set_breakpoint__mutmut_31': x_set_breakpoint__mutmut_31, 
    'x_set_breakpoint__mutmut_32': x_set_breakpoint__mutmut_32
}

def set_breakpoint(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_breakpoint__mutmut_orig, x_set_breakpoint__mutmut_mutants, args, kwargs)
    return result 

set_breakpoint.__signature__ = _mutmut_signature(x_set_breakpoint__mutmut_orig)
x_set_breakpoint__mutmut_orig.__name__ = 'x_set_breakpoint'


def x_set_instrumentation_breakpoint__mutmut_orig(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_1(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = None
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_2(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_3(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["XXinstrumentationXX"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_4(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["INSTRUMENTATION"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_5(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["Instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_6(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_7(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_8(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_9(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_10(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setInstrumentationBreakpointXX",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_11(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setinstrumentationbreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_12(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETINSTRUMENTATIONBREAKPOINT",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_13(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setinstrumentationbreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_14(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_15(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_16(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "Params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_17(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = None
    return BreakpointId.from_json(json["breakpointId"])


def x_set_instrumentation_breakpoint__mutmut_18(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(None)


def x_set_instrumentation_breakpoint__mutmut_19(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["XXbreakpointIdXX"])


def x_set_instrumentation_breakpoint__mutmut_20(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointid"])


def x_set_instrumentation_breakpoint__mutmut_21(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["BREAKPOINTID"])


def x_set_instrumentation_breakpoint__mutmut_22(
    instrumentation: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets instrumentation breakpoint.

    :param instrumentation: Instrumentation name.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["instrumentation"] = instrumentation
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setInstrumentationBreakpoint",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["Breakpointid"])

x_set_instrumentation_breakpoint__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_instrumentation_breakpoint__mutmut_1': x_set_instrumentation_breakpoint__mutmut_1, 
    'x_set_instrumentation_breakpoint__mutmut_2': x_set_instrumentation_breakpoint__mutmut_2, 
    'x_set_instrumentation_breakpoint__mutmut_3': x_set_instrumentation_breakpoint__mutmut_3, 
    'x_set_instrumentation_breakpoint__mutmut_4': x_set_instrumentation_breakpoint__mutmut_4, 
    'x_set_instrumentation_breakpoint__mutmut_5': x_set_instrumentation_breakpoint__mutmut_5, 
    'x_set_instrumentation_breakpoint__mutmut_6': x_set_instrumentation_breakpoint__mutmut_6, 
    'x_set_instrumentation_breakpoint__mutmut_7': x_set_instrumentation_breakpoint__mutmut_7, 
    'x_set_instrumentation_breakpoint__mutmut_8': x_set_instrumentation_breakpoint__mutmut_8, 
    'x_set_instrumentation_breakpoint__mutmut_9': x_set_instrumentation_breakpoint__mutmut_9, 
    'x_set_instrumentation_breakpoint__mutmut_10': x_set_instrumentation_breakpoint__mutmut_10, 
    'x_set_instrumentation_breakpoint__mutmut_11': x_set_instrumentation_breakpoint__mutmut_11, 
    'x_set_instrumentation_breakpoint__mutmut_12': x_set_instrumentation_breakpoint__mutmut_12, 
    'x_set_instrumentation_breakpoint__mutmut_13': x_set_instrumentation_breakpoint__mutmut_13, 
    'x_set_instrumentation_breakpoint__mutmut_14': x_set_instrumentation_breakpoint__mutmut_14, 
    'x_set_instrumentation_breakpoint__mutmut_15': x_set_instrumentation_breakpoint__mutmut_15, 
    'x_set_instrumentation_breakpoint__mutmut_16': x_set_instrumentation_breakpoint__mutmut_16, 
    'x_set_instrumentation_breakpoint__mutmut_17': x_set_instrumentation_breakpoint__mutmut_17, 
    'x_set_instrumentation_breakpoint__mutmut_18': x_set_instrumentation_breakpoint__mutmut_18, 
    'x_set_instrumentation_breakpoint__mutmut_19': x_set_instrumentation_breakpoint__mutmut_19, 
    'x_set_instrumentation_breakpoint__mutmut_20': x_set_instrumentation_breakpoint__mutmut_20, 
    'x_set_instrumentation_breakpoint__mutmut_21': x_set_instrumentation_breakpoint__mutmut_21, 
    'x_set_instrumentation_breakpoint__mutmut_22': x_set_instrumentation_breakpoint__mutmut_22
}

def set_instrumentation_breakpoint(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_instrumentation_breakpoint__mutmut_orig, x_set_instrumentation_breakpoint__mutmut_mutants, args, kwargs)
    return result 

set_instrumentation_breakpoint.__signature__ = _mutmut_signature(x_set_instrumentation_breakpoint__mutmut_orig)
x_set_instrumentation_breakpoint__mutmut_orig.__name__ = 'x_set_instrumentation_breakpoint'


def x_set_breakpoint_by_url__mutmut_orig(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_1(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = None
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_2(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = None
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_3(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["XXlineNumberXX"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_4(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["linenumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_5(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["LINENUMBER"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_6(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["Linenumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_7(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_8(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = None
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_9(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["XXurlXX"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_10(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["URL"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_11(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["Url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_12(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_13(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = None
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_14(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["XXurlRegexXX"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_15(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlregex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_16(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["URLREGEX"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_17(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["Urlregex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_18(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_19(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = None
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_20(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["XXscriptHashXX"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_21(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scripthash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_22(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["SCRIPTHASH"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_23(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["Scripthash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_24(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_25(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = None
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_26(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["XXcolumnNumberXX"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_27(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnnumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_28(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["COLUMNNUMBER"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_29(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["Columnnumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_30(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_31(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_32(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["XXconditionXX"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_33(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["CONDITION"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_34(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["Condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_35(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_36(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_37(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_38(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_39(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setBreakpointByUrlXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_40(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setbreakpointbyurl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_41(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETBREAKPOINTBYURL",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_42(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setbreakpointbyurl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_43(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_44(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_45(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_46(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = None
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_47(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(None),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_48(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["XXbreakpointIdXX"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_49(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointid"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_50(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["BREAKPOINTID"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_51(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["Breakpointid"]),
        [Location.from_json(i) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_52(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(None) for i in json["locations"]],
    )


def x_set_breakpoint_by_url__mutmut_53(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["XXlocationsXX"]],
    )


def x_set_breakpoint_by_url__mutmut_54(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["LOCATIONS"]],
    )


def x_set_breakpoint_by_url__mutmut_55(
    line_number: int,
    url: str | None = None,
    url_regex: str | None = None,
    script_hash: str | None = None,
    column_number: int | None = None,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]:
    """
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    ``locations`` property. Further matching script parsing will result in subsequent
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads.

    :param line_number: Line number to set breakpoint at.
    :param url: *(Optional)* URL of the resources to set breakpoint on.
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified.
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on.
    :param column_number: *(Optional)* Offset in the line to set breakpoint at.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
    :returns: A tuple with the following items:

        0. **breakpointId** - Id of the created breakpoint for further reference.
        1. **locations** - List of the locations this breakpoint resolved into upon addition.
    """
    params: T_JSON_DICT = {}
    params["lineNumber"] = line_number
    if url is not None:
        params["url"] = url
    if url_regex is not None:
        params["urlRegex"] = url_regex
    if script_hash is not None:
        params["scriptHash"] = script_hash
    if column_number is not None:
        params["columnNumber"] = column_number
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointByUrl",
        "params": params,
    }
    json = yield cmd_dict
    return (
        BreakpointId.from_json(json["breakpointId"]),
        [Location.from_json(i) for i in json["Locations"]],
    )

x_set_breakpoint_by_url__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_breakpoint_by_url__mutmut_1': x_set_breakpoint_by_url__mutmut_1, 
    'x_set_breakpoint_by_url__mutmut_2': x_set_breakpoint_by_url__mutmut_2, 
    'x_set_breakpoint_by_url__mutmut_3': x_set_breakpoint_by_url__mutmut_3, 
    'x_set_breakpoint_by_url__mutmut_4': x_set_breakpoint_by_url__mutmut_4, 
    'x_set_breakpoint_by_url__mutmut_5': x_set_breakpoint_by_url__mutmut_5, 
    'x_set_breakpoint_by_url__mutmut_6': x_set_breakpoint_by_url__mutmut_6, 
    'x_set_breakpoint_by_url__mutmut_7': x_set_breakpoint_by_url__mutmut_7, 
    'x_set_breakpoint_by_url__mutmut_8': x_set_breakpoint_by_url__mutmut_8, 
    'x_set_breakpoint_by_url__mutmut_9': x_set_breakpoint_by_url__mutmut_9, 
    'x_set_breakpoint_by_url__mutmut_10': x_set_breakpoint_by_url__mutmut_10, 
    'x_set_breakpoint_by_url__mutmut_11': x_set_breakpoint_by_url__mutmut_11, 
    'x_set_breakpoint_by_url__mutmut_12': x_set_breakpoint_by_url__mutmut_12, 
    'x_set_breakpoint_by_url__mutmut_13': x_set_breakpoint_by_url__mutmut_13, 
    'x_set_breakpoint_by_url__mutmut_14': x_set_breakpoint_by_url__mutmut_14, 
    'x_set_breakpoint_by_url__mutmut_15': x_set_breakpoint_by_url__mutmut_15, 
    'x_set_breakpoint_by_url__mutmut_16': x_set_breakpoint_by_url__mutmut_16, 
    'x_set_breakpoint_by_url__mutmut_17': x_set_breakpoint_by_url__mutmut_17, 
    'x_set_breakpoint_by_url__mutmut_18': x_set_breakpoint_by_url__mutmut_18, 
    'x_set_breakpoint_by_url__mutmut_19': x_set_breakpoint_by_url__mutmut_19, 
    'x_set_breakpoint_by_url__mutmut_20': x_set_breakpoint_by_url__mutmut_20, 
    'x_set_breakpoint_by_url__mutmut_21': x_set_breakpoint_by_url__mutmut_21, 
    'x_set_breakpoint_by_url__mutmut_22': x_set_breakpoint_by_url__mutmut_22, 
    'x_set_breakpoint_by_url__mutmut_23': x_set_breakpoint_by_url__mutmut_23, 
    'x_set_breakpoint_by_url__mutmut_24': x_set_breakpoint_by_url__mutmut_24, 
    'x_set_breakpoint_by_url__mutmut_25': x_set_breakpoint_by_url__mutmut_25, 
    'x_set_breakpoint_by_url__mutmut_26': x_set_breakpoint_by_url__mutmut_26, 
    'x_set_breakpoint_by_url__mutmut_27': x_set_breakpoint_by_url__mutmut_27, 
    'x_set_breakpoint_by_url__mutmut_28': x_set_breakpoint_by_url__mutmut_28, 
    'x_set_breakpoint_by_url__mutmut_29': x_set_breakpoint_by_url__mutmut_29, 
    'x_set_breakpoint_by_url__mutmut_30': x_set_breakpoint_by_url__mutmut_30, 
    'x_set_breakpoint_by_url__mutmut_31': x_set_breakpoint_by_url__mutmut_31, 
    'x_set_breakpoint_by_url__mutmut_32': x_set_breakpoint_by_url__mutmut_32, 
    'x_set_breakpoint_by_url__mutmut_33': x_set_breakpoint_by_url__mutmut_33, 
    'x_set_breakpoint_by_url__mutmut_34': x_set_breakpoint_by_url__mutmut_34, 
    'x_set_breakpoint_by_url__mutmut_35': x_set_breakpoint_by_url__mutmut_35, 
    'x_set_breakpoint_by_url__mutmut_36': x_set_breakpoint_by_url__mutmut_36, 
    'x_set_breakpoint_by_url__mutmut_37': x_set_breakpoint_by_url__mutmut_37, 
    'x_set_breakpoint_by_url__mutmut_38': x_set_breakpoint_by_url__mutmut_38, 
    'x_set_breakpoint_by_url__mutmut_39': x_set_breakpoint_by_url__mutmut_39, 
    'x_set_breakpoint_by_url__mutmut_40': x_set_breakpoint_by_url__mutmut_40, 
    'x_set_breakpoint_by_url__mutmut_41': x_set_breakpoint_by_url__mutmut_41, 
    'x_set_breakpoint_by_url__mutmut_42': x_set_breakpoint_by_url__mutmut_42, 
    'x_set_breakpoint_by_url__mutmut_43': x_set_breakpoint_by_url__mutmut_43, 
    'x_set_breakpoint_by_url__mutmut_44': x_set_breakpoint_by_url__mutmut_44, 
    'x_set_breakpoint_by_url__mutmut_45': x_set_breakpoint_by_url__mutmut_45, 
    'x_set_breakpoint_by_url__mutmut_46': x_set_breakpoint_by_url__mutmut_46, 
    'x_set_breakpoint_by_url__mutmut_47': x_set_breakpoint_by_url__mutmut_47, 
    'x_set_breakpoint_by_url__mutmut_48': x_set_breakpoint_by_url__mutmut_48, 
    'x_set_breakpoint_by_url__mutmut_49': x_set_breakpoint_by_url__mutmut_49, 
    'x_set_breakpoint_by_url__mutmut_50': x_set_breakpoint_by_url__mutmut_50, 
    'x_set_breakpoint_by_url__mutmut_51': x_set_breakpoint_by_url__mutmut_51, 
    'x_set_breakpoint_by_url__mutmut_52': x_set_breakpoint_by_url__mutmut_52, 
    'x_set_breakpoint_by_url__mutmut_53': x_set_breakpoint_by_url__mutmut_53, 
    'x_set_breakpoint_by_url__mutmut_54': x_set_breakpoint_by_url__mutmut_54, 
    'x_set_breakpoint_by_url__mutmut_55': x_set_breakpoint_by_url__mutmut_55
}

def set_breakpoint_by_url(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_breakpoint_by_url__mutmut_orig, x_set_breakpoint_by_url__mutmut_mutants, args, kwargs)
    return result 

set_breakpoint_by_url.__signature__ = _mutmut_signature(x_set_breakpoint_by_url__mutmut_orig)
x_set_breakpoint_by_url__mutmut_orig.__name__ = 'x_set_breakpoint_by_url'


def x_set_breakpoint_on_function_call__mutmut_orig(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_1(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = None
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_2(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = None
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_3(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["XXobjectIdXX"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_4(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectid"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_5(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["OBJECTID"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_6(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["Objectid"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_7(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_8(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_9(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["XXconditionXX"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_10(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["CONDITION"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_11(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["Condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_12(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_13(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_14(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_15(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_16(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setBreakpointOnFunctionCallXX",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_17(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setbreakpointonfunctioncall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_18(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETBREAKPOINTONFUNCTIONCALL",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_19(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setbreakpointonfunctioncall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_20(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_21(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_22(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "Params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_23(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = None
    return BreakpointId.from_json(json["breakpointId"])


def x_set_breakpoint_on_function_call__mutmut_24(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(None)


def x_set_breakpoint_on_function_call__mutmut_25(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["XXbreakpointIdXX"])


def x_set_breakpoint_on_function_call__mutmut_26(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["breakpointid"])


def x_set_breakpoint_on_function_call__mutmut_27(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["BREAKPOINTID"])


def x_set_breakpoint_on_function_call__mutmut_28(
    object_id: runtime.RemoteObjectId,
    condition: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]:
    """
    Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint.

    **EXPERIMENTAL**

    :param object_id: Function object id.
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
    :returns: Id of the created breakpoint for further reference.
    """
    params: T_JSON_DICT = {}
    params["objectId"] = object_id.to_json()
    if condition is not None:
        params["condition"] = condition
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointOnFunctionCall",
        "params": params,
    }
    json = yield cmd_dict
    return BreakpointId.from_json(json["Breakpointid"])

x_set_breakpoint_on_function_call__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_breakpoint_on_function_call__mutmut_1': x_set_breakpoint_on_function_call__mutmut_1, 
    'x_set_breakpoint_on_function_call__mutmut_2': x_set_breakpoint_on_function_call__mutmut_2, 
    'x_set_breakpoint_on_function_call__mutmut_3': x_set_breakpoint_on_function_call__mutmut_3, 
    'x_set_breakpoint_on_function_call__mutmut_4': x_set_breakpoint_on_function_call__mutmut_4, 
    'x_set_breakpoint_on_function_call__mutmut_5': x_set_breakpoint_on_function_call__mutmut_5, 
    'x_set_breakpoint_on_function_call__mutmut_6': x_set_breakpoint_on_function_call__mutmut_6, 
    'x_set_breakpoint_on_function_call__mutmut_7': x_set_breakpoint_on_function_call__mutmut_7, 
    'x_set_breakpoint_on_function_call__mutmut_8': x_set_breakpoint_on_function_call__mutmut_8, 
    'x_set_breakpoint_on_function_call__mutmut_9': x_set_breakpoint_on_function_call__mutmut_9, 
    'x_set_breakpoint_on_function_call__mutmut_10': x_set_breakpoint_on_function_call__mutmut_10, 
    'x_set_breakpoint_on_function_call__mutmut_11': x_set_breakpoint_on_function_call__mutmut_11, 
    'x_set_breakpoint_on_function_call__mutmut_12': x_set_breakpoint_on_function_call__mutmut_12, 
    'x_set_breakpoint_on_function_call__mutmut_13': x_set_breakpoint_on_function_call__mutmut_13, 
    'x_set_breakpoint_on_function_call__mutmut_14': x_set_breakpoint_on_function_call__mutmut_14, 
    'x_set_breakpoint_on_function_call__mutmut_15': x_set_breakpoint_on_function_call__mutmut_15, 
    'x_set_breakpoint_on_function_call__mutmut_16': x_set_breakpoint_on_function_call__mutmut_16, 
    'x_set_breakpoint_on_function_call__mutmut_17': x_set_breakpoint_on_function_call__mutmut_17, 
    'x_set_breakpoint_on_function_call__mutmut_18': x_set_breakpoint_on_function_call__mutmut_18, 
    'x_set_breakpoint_on_function_call__mutmut_19': x_set_breakpoint_on_function_call__mutmut_19, 
    'x_set_breakpoint_on_function_call__mutmut_20': x_set_breakpoint_on_function_call__mutmut_20, 
    'x_set_breakpoint_on_function_call__mutmut_21': x_set_breakpoint_on_function_call__mutmut_21, 
    'x_set_breakpoint_on_function_call__mutmut_22': x_set_breakpoint_on_function_call__mutmut_22, 
    'x_set_breakpoint_on_function_call__mutmut_23': x_set_breakpoint_on_function_call__mutmut_23, 
    'x_set_breakpoint_on_function_call__mutmut_24': x_set_breakpoint_on_function_call__mutmut_24, 
    'x_set_breakpoint_on_function_call__mutmut_25': x_set_breakpoint_on_function_call__mutmut_25, 
    'x_set_breakpoint_on_function_call__mutmut_26': x_set_breakpoint_on_function_call__mutmut_26, 
    'x_set_breakpoint_on_function_call__mutmut_27': x_set_breakpoint_on_function_call__mutmut_27, 
    'x_set_breakpoint_on_function_call__mutmut_28': x_set_breakpoint_on_function_call__mutmut_28
}

def set_breakpoint_on_function_call(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_breakpoint_on_function_call__mutmut_orig, x_set_breakpoint_on_function_call__mutmut_mutants, args, kwargs)
    return result 

set_breakpoint_on_function_call.__signature__ = _mutmut_signature(x_set_breakpoint_on_function_call__mutmut_orig)
x_set_breakpoint_on_function_call__mutmut_orig.__name__ = 'x_set_breakpoint_on_function_call'


def x_set_breakpoints_active__mutmut_orig(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointsActive",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_1(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = None
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointsActive",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_2(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointsActive",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_3(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["XXactiveXX"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointsActive",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_4(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["ACTIVE"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointsActive",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_5(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["Active"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointsActive",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_6(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_breakpoints_active__mutmut_7(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setBreakpointsActive",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_8(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setBreakpointsActive",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_9(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setBreakpointsActive",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_10(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setBreakpointsActiveXX",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_11(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setbreakpointsactive",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_12(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETBREAKPOINTSACTIVE",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_13(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setbreakpointsactive",
        "params": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_14(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointsActive",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_15(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointsActive",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_breakpoints_active__mutmut_16(
    active: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Activates / deactivates all breakpoints on the page.

    :param active: New value for breakpoints active state.
    """
    params: T_JSON_DICT = {}
    params["active"] = active
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setBreakpointsActive",
        "Params": params,
    }
    yield cmd_dict

x_set_breakpoints_active__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_breakpoints_active__mutmut_1': x_set_breakpoints_active__mutmut_1, 
    'x_set_breakpoints_active__mutmut_2': x_set_breakpoints_active__mutmut_2, 
    'x_set_breakpoints_active__mutmut_3': x_set_breakpoints_active__mutmut_3, 
    'x_set_breakpoints_active__mutmut_4': x_set_breakpoints_active__mutmut_4, 
    'x_set_breakpoints_active__mutmut_5': x_set_breakpoints_active__mutmut_5, 
    'x_set_breakpoints_active__mutmut_6': x_set_breakpoints_active__mutmut_6, 
    'x_set_breakpoints_active__mutmut_7': x_set_breakpoints_active__mutmut_7, 
    'x_set_breakpoints_active__mutmut_8': x_set_breakpoints_active__mutmut_8, 
    'x_set_breakpoints_active__mutmut_9': x_set_breakpoints_active__mutmut_9, 
    'x_set_breakpoints_active__mutmut_10': x_set_breakpoints_active__mutmut_10, 
    'x_set_breakpoints_active__mutmut_11': x_set_breakpoints_active__mutmut_11, 
    'x_set_breakpoints_active__mutmut_12': x_set_breakpoints_active__mutmut_12, 
    'x_set_breakpoints_active__mutmut_13': x_set_breakpoints_active__mutmut_13, 
    'x_set_breakpoints_active__mutmut_14': x_set_breakpoints_active__mutmut_14, 
    'x_set_breakpoints_active__mutmut_15': x_set_breakpoints_active__mutmut_15, 
    'x_set_breakpoints_active__mutmut_16': x_set_breakpoints_active__mutmut_16
}

def set_breakpoints_active(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_breakpoints_active__mutmut_orig, x_set_breakpoints_active__mutmut_mutants, args, kwargs)
    return result 

set_breakpoints_active.__signature__ = _mutmut_signature(x_set_breakpoints_active__mutmut_orig)
x_set_breakpoints_active__mutmut_orig.__name__ = 'x_set_breakpoints_active'


def x_set_pause_on_exceptions__mutmut_orig(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setPauseOnExceptions",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_1(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = None
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setPauseOnExceptions",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_2(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setPauseOnExceptions",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_3(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["XXstateXX"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setPauseOnExceptions",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_4(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["STATE"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setPauseOnExceptions",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_5(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["State"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setPauseOnExceptions",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_6(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_7(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setPauseOnExceptions",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_8(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setPauseOnExceptions",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_9(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setPauseOnExceptions",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_10(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setPauseOnExceptionsXX",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_11(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setpauseonexceptions",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_12(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETPAUSEONEXCEPTIONS",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_13(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setpauseonexceptions",
        "params": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_14(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setPauseOnExceptions",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_15(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setPauseOnExceptions",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_pause_on_exceptions__mutmut_16(
    state: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is ``none``.

    :param state: Pause on exceptions mode.
    """
    params: T_JSON_DICT = {}
    params["state"] = state
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setPauseOnExceptions",
        "Params": params,
    }
    yield cmd_dict

x_set_pause_on_exceptions__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_pause_on_exceptions__mutmut_1': x_set_pause_on_exceptions__mutmut_1, 
    'x_set_pause_on_exceptions__mutmut_2': x_set_pause_on_exceptions__mutmut_2, 
    'x_set_pause_on_exceptions__mutmut_3': x_set_pause_on_exceptions__mutmut_3, 
    'x_set_pause_on_exceptions__mutmut_4': x_set_pause_on_exceptions__mutmut_4, 
    'x_set_pause_on_exceptions__mutmut_5': x_set_pause_on_exceptions__mutmut_5, 
    'x_set_pause_on_exceptions__mutmut_6': x_set_pause_on_exceptions__mutmut_6, 
    'x_set_pause_on_exceptions__mutmut_7': x_set_pause_on_exceptions__mutmut_7, 
    'x_set_pause_on_exceptions__mutmut_8': x_set_pause_on_exceptions__mutmut_8, 
    'x_set_pause_on_exceptions__mutmut_9': x_set_pause_on_exceptions__mutmut_9, 
    'x_set_pause_on_exceptions__mutmut_10': x_set_pause_on_exceptions__mutmut_10, 
    'x_set_pause_on_exceptions__mutmut_11': x_set_pause_on_exceptions__mutmut_11, 
    'x_set_pause_on_exceptions__mutmut_12': x_set_pause_on_exceptions__mutmut_12, 
    'x_set_pause_on_exceptions__mutmut_13': x_set_pause_on_exceptions__mutmut_13, 
    'x_set_pause_on_exceptions__mutmut_14': x_set_pause_on_exceptions__mutmut_14, 
    'x_set_pause_on_exceptions__mutmut_15': x_set_pause_on_exceptions__mutmut_15, 
    'x_set_pause_on_exceptions__mutmut_16': x_set_pause_on_exceptions__mutmut_16
}

def set_pause_on_exceptions(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_pause_on_exceptions__mutmut_orig, x_set_pause_on_exceptions__mutmut_mutants, args, kwargs)
    return result 

set_pause_on_exceptions.__signature__ = _mutmut_signature(x_set_pause_on_exceptions__mutmut_orig)
x_set_pause_on_exceptions__mutmut_orig.__name__ = 'x_set_pause_on_exceptions'


def x_set_return_value__mutmut_orig(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setReturnValue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_1(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = None
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setReturnValue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_2(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setReturnValue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_3(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["XXnewValueXX"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setReturnValue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_4(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newvalue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setReturnValue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_5(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["NEWVALUE"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setReturnValue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_6(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["Newvalue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setReturnValue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_7(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_return_value__mutmut_8(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setReturnValue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_9(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setReturnValue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_10(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setReturnValue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_11(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setReturnValueXX",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_12(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setreturnvalue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_13(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETRETURNVALUE",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_14(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setreturnvalue",
        "params": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_15(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setReturnValue",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_16(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setReturnValue",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_return_value__mutmut_17(
    new_value: runtime.CallArgument,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes return value in top frame. Available only at return break position.

    **EXPERIMENTAL**

    :param new_value: New return value.
    """
    params: T_JSON_DICT = {}
    params["newValue"] = new_value.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setReturnValue",
        "Params": params,
    }
    yield cmd_dict

x_set_return_value__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_return_value__mutmut_1': x_set_return_value__mutmut_1, 
    'x_set_return_value__mutmut_2': x_set_return_value__mutmut_2, 
    'x_set_return_value__mutmut_3': x_set_return_value__mutmut_3, 
    'x_set_return_value__mutmut_4': x_set_return_value__mutmut_4, 
    'x_set_return_value__mutmut_5': x_set_return_value__mutmut_5, 
    'x_set_return_value__mutmut_6': x_set_return_value__mutmut_6, 
    'x_set_return_value__mutmut_7': x_set_return_value__mutmut_7, 
    'x_set_return_value__mutmut_8': x_set_return_value__mutmut_8, 
    'x_set_return_value__mutmut_9': x_set_return_value__mutmut_9, 
    'x_set_return_value__mutmut_10': x_set_return_value__mutmut_10, 
    'x_set_return_value__mutmut_11': x_set_return_value__mutmut_11, 
    'x_set_return_value__mutmut_12': x_set_return_value__mutmut_12, 
    'x_set_return_value__mutmut_13': x_set_return_value__mutmut_13, 
    'x_set_return_value__mutmut_14': x_set_return_value__mutmut_14, 
    'x_set_return_value__mutmut_15': x_set_return_value__mutmut_15, 
    'x_set_return_value__mutmut_16': x_set_return_value__mutmut_16, 
    'x_set_return_value__mutmut_17': x_set_return_value__mutmut_17
}

def set_return_value(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_return_value__mutmut_orig, x_set_return_value__mutmut_mutants, args, kwargs)
    return result 

set_return_value.__signature__ = _mutmut_signature(x_set_return_value__mutmut_orig)
x_set_return_value__mutmut_orig.__name__ = 'x_set_return_value'


def x_set_script_source__mutmut_orig(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_1(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = None
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_2(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = None
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_3(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["XXscriptIdXX"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_4(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptid"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_5(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["SCRIPTID"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_6(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["Scriptid"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_7(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = None
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_8(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["XXscriptSourceXX"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_9(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptsource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_10(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["SCRIPTSOURCE"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_11(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["Scriptsource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_12(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_13(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = None
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_14(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["XXdryRunXX"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_15(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryrun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_16(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["DRYRUN"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_17(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["Dryrun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_18(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_19(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_20(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["XXallowTopFrameEditingXX"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_21(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowtopframeediting"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_22(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["ALLOWTOPFRAMEEDITING"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_23(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["Allowtopframeediting"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_24(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = None
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_25(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_26(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_27(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_28(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setScriptSourceXX",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_29(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setscriptsource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_30(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETSCRIPTSOURCE",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_31(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setscriptsource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_32(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "XXparamsXX": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_33(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "PARAMS": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_34(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "Params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_35(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = None
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_36(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(None) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_37(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["XXcallFramesXX"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_38(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callframes"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_39(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["CALLFRAMES"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_40(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["Callframes"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_41(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "XXcallFramesXX" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_42(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callframes" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_43(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "CALLFRAMES" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_44(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "Callframes" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_45(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" not in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_46(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(None) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_47(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["XXstackChangedXX"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_48(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackchanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_49(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["STACKCHANGED"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_50(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["Stackchanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_51(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "XXstackChangedXX" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_52(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackchanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_53(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "STACKCHANGED" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_54(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "Stackchanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_55(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" not in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_56(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(None) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_57(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["XXasyncStackTraceXX"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_58(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncstacktrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_59(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["ASYNCSTACKTRACE"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_60(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["Asyncstacktrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_61(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "XXasyncStackTraceXX" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_62(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncstacktrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_63(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "ASYNCSTACKTRACE" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_64(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "Asyncstacktrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_65(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" not in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_66(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(None) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_67(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["XXasyncStackTraceIdXX"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_68(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncstacktraceid"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_69(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["ASYNCSTACKTRACEID"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_70(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["Asyncstacktraceid"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_71(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "XXasyncStackTraceIdXX" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_72(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncstacktraceid" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_73(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "ASYNCSTACKTRACEID" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_74(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "Asyncstacktraceid" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_75(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" not in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_76(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(None),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_77(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["XXstatusXX"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_78(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["STATUS"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_79(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["Status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_80(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(None) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_81(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["XXexceptionDetailsXX"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_82(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_83(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["EXCEPTIONDETAILS"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_84(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["Exceptiondetails"]) if "exceptionDetails" in json else None,
    )


def x_set_script_source__mutmut_85(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "XXexceptionDetailsXX" in json else None,
    )


def x_set_script_source__mutmut_86(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptiondetails" in json else None,
    )


def x_set_script_source__mutmut_87(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "EXCEPTIONDETAILS" in json else None,
    )


def x_set_script_source__mutmut_88(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "Exceptiondetails" in json else None,
    )


def x_set_script_source__mutmut_89(
    script_id: runtime.ScriptId,
    script_source: str,
    dry_run: bool | None = None,
    allow_top_frame_editing: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]:
    """
    Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a ``Debugger.restartFrame`` for the
    top-most function is automatically triggered.

    :param script_id: Id of the script to edit.
    :param script_source: New content of the script.
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
    :param allow_top_frame_editing: **(EXPERIMENTAL)** *(Optional)* If true, then ```scriptSource```` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
    :returns: A tuple with the following items:

        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped.
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes.
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any.
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any.
        4. **status** - Whether the operation was successful or not. Only `` Ok`` denotes a successful live edit while the other enum variants denote why the live edit failed.
        5. **exceptionDetails** - *(Optional)* Exception details if any. Only present when `` status`` is `` CompileError`.
    """
    params: T_JSON_DICT = {}
    params["scriptId"] = script_id.to_json()
    params["scriptSource"] = script_source
    if dry_run is not None:
        params["dryRun"] = dry_run
    if allow_top_frame_editing is not None:
        params["allowTopFrameEditing"] = allow_top_frame_editing
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setScriptSource",
        "params": params,
    }
    json = yield cmd_dict
    return (
        [CallFrame.from_json(i) for i in json["callFrames"]] if "callFrames" in json else None,
        bool(json["stackChanged"]) if "stackChanged" in json else None,
        runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
        runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
        str(json["status"]),
        runtime.ExceptionDetails.from_json(json["exceptionDetails"]) if "exceptionDetails" not in json else None,
    )

x_set_script_source__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_script_source__mutmut_1': x_set_script_source__mutmut_1, 
    'x_set_script_source__mutmut_2': x_set_script_source__mutmut_2, 
    'x_set_script_source__mutmut_3': x_set_script_source__mutmut_3, 
    'x_set_script_source__mutmut_4': x_set_script_source__mutmut_4, 
    'x_set_script_source__mutmut_5': x_set_script_source__mutmut_5, 
    'x_set_script_source__mutmut_6': x_set_script_source__mutmut_6, 
    'x_set_script_source__mutmut_7': x_set_script_source__mutmut_7, 
    'x_set_script_source__mutmut_8': x_set_script_source__mutmut_8, 
    'x_set_script_source__mutmut_9': x_set_script_source__mutmut_9, 
    'x_set_script_source__mutmut_10': x_set_script_source__mutmut_10, 
    'x_set_script_source__mutmut_11': x_set_script_source__mutmut_11, 
    'x_set_script_source__mutmut_12': x_set_script_source__mutmut_12, 
    'x_set_script_source__mutmut_13': x_set_script_source__mutmut_13, 
    'x_set_script_source__mutmut_14': x_set_script_source__mutmut_14, 
    'x_set_script_source__mutmut_15': x_set_script_source__mutmut_15, 
    'x_set_script_source__mutmut_16': x_set_script_source__mutmut_16, 
    'x_set_script_source__mutmut_17': x_set_script_source__mutmut_17, 
    'x_set_script_source__mutmut_18': x_set_script_source__mutmut_18, 
    'x_set_script_source__mutmut_19': x_set_script_source__mutmut_19, 
    'x_set_script_source__mutmut_20': x_set_script_source__mutmut_20, 
    'x_set_script_source__mutmut_21': x_set_script_source__mutmut_21, 
    'x_set_script_source__mutmut_22': x_set_script_source__mutmut_22, 
    'x_set_script_source__mutmut_23': x_set_script_source__mutmut_23, 
    'x_set_script_source__mutmut_24': x_set_script_source__mutmut_24, 
    'x_set_script_source__mutmut_25': x_set_script_source__mutmut_25, 
    'x_set_script_source__mutmut_26': x_set_script_source__mutmut_26, 
    'x_set_script_source__mutmut_27': x_set_script_source__mutmut_27, 
    'x_set_script_source__mutmut_28': x_set_script_source__mutmut_28, 
    'x_set_script_source__mutmut_29': x_set_script_source__mutmut_29, 
    'x_set_script_source__mutmut_30': x_set_script_source__mutmut_30, 
    'x_set_script_source__mutmut_31': x_set_script_source__mutmut_31, 
    'x_set_script_source__mutmut_32': x_set_script_source__mutmut_32, 
    'x_set_script_source__mutmut_33': x_set_script_source__mutmut_33, 
    'x_set_script_source__mutmut_34': x_set_script_source__mutmut_34, 
    'x_set_script_source__mutmut_35': x_set_script_source__mutmut_35, 
    'x_set_script_source__mutmut_36': x_set_script_source__mutmut_36, 
    'x_set_script_source__mutmut_37': x_set_script_source__mutmut_37, 
    'x_set_script_source__mutmut_38': x_set_script_source__mutmut_38, 
    'x_set_script_source__mutmut_39': x_set_script_source__mutmut_39, 
    'x_set_script_source__mutmut_40': x_set_script_source__mutmut_40, 
    'x_set_script_source__mutmut_41': x_set_script_source__mutmut_41, 
    'x_set_script_source__mutmut_42': x_set_script_source__mutmut_42, 
    'x_set_script_source__mutmut_43': x_set_script_source__mutmut_43, 
    'x_set_script_source__mutmut_44': x_set_script_source__mutmut_44, 
    'x_set_script_source__mutmut_45': x_set_script_source__mutmut_45, 
    'x_set_script_source__mutmut_46': x_set_script_source__mutmut_46, 
    'x_set_script_source__mutmut_47': x_set_script_source__mutmut_47, 
    'x_set_script_source__mutmut_48': x_set_script_source__mutmut_48, 
    'x_set_script_source__mutmut_49': x_set_script_source__mutmut_49, 
    'x_set_script_source__mutmut_50': x_set_script_source__mutmut_50, 
    'x_set_script_source__mutmut_51': x_set_script_source__mutmut_51, 
    'x_set_script_source__mutmut_52': x_set_script_source__mutmut_52, 
    'x_set_script_source__mutmut_53': x_set_script_source__mutmut_53, 
    'x_set_script_source__mutmut_54': x_set_script_source__mutmut_54, 
    'x_set_script_source__mutmut_55': x_set_script_source__mutmut_55, 
    'x_set_script_source__mutmut_56': x_set_script_source__mutmut_56, 
    'x_set_script_source__mutmut_57': x_set_script_source__mutmut_57, 
    'x_set_script_source__mutmut_58': x_set_script_source__mutmut_58, 
    'x_set_script_source__mutmut_59': x_set_script_source__mutmut_59, 
    'x_set_script_source__mutmut_60': x_set_script_source__mutmut_60, 
    'x_set_script_source__mutmut_61': x_set_script_source__mutmut_61, 
    'x_set_script_source__mutmut_62': x_set_script_source__mutmut_62, 
    'x_set_script_source__mutmut_63': x_set_script_source__mutmut_63, 
    'x_set_script_source__mutmut_64': x_set_script_source__mutmut_64, 
    'x_set_script_source__mutmut_65': x_set_script_source__mutmut_65, 
    'x_set_script_source__mutmut_66': x_set_script_source__mutmut_66, 
    'x_set_script_source__mutmut_67': x_set_script_source__mutmut_67, 
    'x_set_script_source__mutmut_68': x_set_script_source__mutmut_68, 
    'x_set_script_source__mutmut_69': x_set_script_source__mutmut_69, 
    'x_set_script_source__mutmut_70': x_set_script_source__mutmut_70, 
    'x_set_script_source__mutmut_71': x_set_script_source__mutmut_71, 
    'x_set_script_source__mutmut_72': x_set_script_source__mutmut_72, 
    'x_set_script_source__mutmut_73': x_set_script_source__mutmut_73, 
    'x_set_script_source__mutmut_74': x_set_script_source__mutmut_74, 
    'x_set_script_source__mutmut_75': x_set_script_source__mutmut_75, 
    'x_set_script_source__mutmut_76': x_set_script_source__mutmut_76, 
    'x_set_script_source__mutmut_77': x_set_script_source__mutmut_77, 
    'x_set_script_source__mutmut_78': x_set_script_source__mutmut_78, 
    'x_set_script_source__mutmut_79': x_set_script_source__mutmut_79, 
    'x_set_script_source__mutmut_80': x_set_script_source__mutmut_80, 
    'x_set_script_source__mutmut_81': x_set_script_source__mutmut_81, 
    'x_set_script_source__mutmut_82': x_set_script_source__mutmut_82, 
    'x_set_script_source__mutmut_83': x_set_script_source__mutmut_83, 
    'x_set_script_source__mutmut_84': x_set_script_source__mutmut_84, 
    'x_set_script_source__mutmut_85': x_set_script_source__mutmut_85, 
    'x_set_script_source__mutmut_86': x_set_script_source__mutmut_86, 
    'x_set_script_source__mutmut_87': x_set_script_source__mutmut_87, 
    'x_set_script_source__mutmut_88': x_set_script_source__mutmut_88, 
    'x_set_script_source__mutmut_89': x_set_script_source__mutmut_89
}

def set_script_source(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_script_source__mutmut_orig, x_set_script_source__mutmut_mutants, args, kwargs)
    return result 

set_script_source.__signature__ = _mutmut_signature(x_set_script_source__mutmut_orig)
x_set_script_source__mutmut_orig.__name__ = 'x_set_script_source'


def x_set_skip_all_pauses__mutmut_orig(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setSkipAllPauses",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_1(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = None
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setSkipAllPauses",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_2(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setSkipAllPauses",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_3(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["XXskipXX"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setSkipAllPauses",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_4(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["SKIP"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setSkipAllPauses",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_5(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["Skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setSkipAllPauses",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_6(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_7(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setSkipAllPauses",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_8(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setSkipAllPauses",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_9(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setSkipAllPauses",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_10(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setSkipAllPausesXX",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_11(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setskipallpauses",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_12(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETSKIPALLPAUSES",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_13(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setskipallpauses",
        "params": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_14(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setSkipAllPauses",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_15(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setSkipAllPauses",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_skip_all_pauses__mutmut_16(
    skip: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).

    :param skip: New value for skip pauses state.
    """
    params: T_JSON_DICT = {}
    params["skip"] = skip
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setSkipAllPauses",
        "Params": params,
    }
    yield cmd_dict

x_set_skip_all_pauses__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_skip_all_pauses__mutmut_1': x_set_skip_all_pauses__mutmut_1, 
    'x_set_skip_all_pauses__mutmut_2': x_set_skip_all_pauses__mutmut_2, 
    'x_set_skip_all_pauses__mutmut_3': x_set_skip_all_pauses__mutmut_3, 
    'x_set_skip_all_pauses__mutmut_4': x_set_skip_all_pauses__mutmut_4, 
    'x_set_skip_all_pauses__mutmut_5': x_set_skip_all_pauses__mutmut_5, 
    'x_set_skip_all_pauses__mutmut_6': x_set_skip_all_pauses__mutmut_6, 
    'x_set_skip_all_pauses__mutmut_7': x_set_skip_all_pauses__mutmut_7, 
    'x_set_skip_all_pauses__mutmut_8': x_set_skip_all_pauses__mutmut_8, 
    'x_set_skip_all_pauses__mutmut_9': x_set_skip_all_pauses__mutmut_9, 
    'x_set_skip_all_pauses__mutmut_10': x_set_skip_all_pauses__mutmut_10, 
    'x_set_skip_all_pauses__mutmut_11': x_set_skip_all_pauses__mutmut_11, 
    'x_set_skip_all_pauses__mutmut_12': x_set_skip_all_pauses__mutmut_12, 
    'x_set_skip_all_pauses__mutmut_13': x_set_skip_all_pauses__mutmut_13, 
    'x_set_skip_all_pauses__mutmut_14': x_set_skip_all_pauses__mutmut_14, 
    'x_set_skip_all_pauses__mutmut_15': x_set_skip_all_pauses__mutmut_15, 
    'x_set_skip_all_pauses__mutmut_16': x_set_skip_all_pauses__mutmut_16
}

def set_skip_all_pauses(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_skip_all_pauses__mutmut_orig, x_set_skip_all_pauses__mutmut_mutants, args, kwargs)
    return result 

set_skip_all_pauses.__signature__ = _mutmut_signature(x_set_skip_all_pauses__mutmut_orig)
x_set_skip_all_pauses__mutmut_orig.__name__ = 'x_set_skip_all_pauses'


def x_set_variable_value__mutmut_orig(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_1(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = None
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_2(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = None
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_3(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["XXscopeNumberXX"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_4(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopenumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_5(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["SCOPENUMBER"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_6(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["Scopenumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_7(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = None
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_8(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["XXvariableNameXX"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_9(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variablename"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_10(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["VARIABLENAME"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_11(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["Variablename"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_12(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = None
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_13(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["XXnewValueXX"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_14(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newvalue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_15(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["NEWVALUE"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_16(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["Newvalue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_17(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_18(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["XXcallFrameIdXX"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_19(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callframeid"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_20(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["CALLFRAMEID"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_21(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["Callframeid"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_22(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_set_variable_value__mutmut_23(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_24(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_25(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.setVariableValue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_26(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.setVariableValueXX",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_27(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.setvariablevalue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_28(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.SETVARIABLEVALUE",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_29(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setvariablevalue",
        "params": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_30(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_31(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "PARAMS": params,
    }
    yield cmd_dict


def x_set_variable_value__mutmut_32(
    scope_number: int,
    variable_name: str,
    new_value: runtime.CallArgument,
    call_frame_id: CallFrameId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually.

    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
    :param variable_name: Variable name.
    :param new_value: New variable value.
    :param call_frame_id: Id of callframe that holds variable.
    """
    params: T_JSON_DICT = {}
    params["scopeNumber"] = scope_number
    params["variableName"] = variable_name
    params["newValue"] = new_value.to_json()
    params["callFrameId"] = call_frame_id.to_json()
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.setVariableValue",
        "Params": params,
    }
    yield cmd_dict

x_set_variable_value__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_variable_value__mutmut_1': x_set_variable_value__mutmut_1, 
    'x_set_variable_value__mutmut_2': x_set_variable_value__mutmut_2, 
    'x_set_variable_value__mutmut_3': x_set_variable_value__mutmut_3, 
    'x_set_variable_value__mutmut_4': x_set_variable_value__mutmut_4, 
    'x_set_variable_value__mutmut_5': x_set_variable_value__mutmut_5, 
    'x_set_variable_value__mutmut_6': x_set_variable_value__mutmut_6, 
    'x_set_variable_value__mutmut_7': x_set_variable_value__mutmut_7, 
    'x_set_variable_value__mutmut_8': x_set_variable_value__mutmut_8, 
    'x_set_variable_value__mutmut_9': x_set_variable_value__mutmut_9, 
    'x_set_variable_value__mutmut_10': x_set_variable_value__mutmut_10, 
    'x_set_variable_value__mutmut_11': x_set_variable_value__mutmut_11, 
    'x_set_variable_value__mutmut_12': x_set_variable_value__mutmut_12, 
    'x_set_variable_value__mutmut_13': x_set_variable_value__mutmut_13, 
    'x_set_variable_value__mutmut_14': x_set_variable_value__mutmut_14, 
    'x_set_variable_value__mutmut_15': x_set_variable_value__mutmut_15, 
    'x_set_variable_value__mutmut_16': x_set_variable_value__mutmut_16, 
    'x_set_variable_value__mutmut_17': x_set_variable_value__mutmut_17, 
    'x_set_variable_value__mutmut_18': x_set_variable_value__mutmut_18, 
    'x_set_variable_value__mutmut_19': x_set_variable_value__mutmut_19, 
    'x_set_variable_value__mutmut_20': x_set_variable_value__mutmut_20, 
    'x_set_variable_value__mutmut_21': x_set_variable_value__mutmut_21, 
    'x_set_variable_value__mutmut_22': x_set_variable_value__mutmut_22, 
    'x_set_variable_value__mutmut_23': x_set_variable_value__mutmut_23, 
    'x_set_variable_value__mutmut_24': x_set_variable_value__mutmut_24, 
    'x_set_variable_value__mutmut_25': x_set_variable_value__mutmut_25, 
    'x_set_variable_value__mutmut_26': x_set_variable_value__mutmut_26, 
    'x_set_variable_value__mutmut_27': x_set_variable_value__mutmut_27, 
    'x_set_variable_value__mutmut_28': x_set_variable_value__mutmut_28, 
    'x_set_variable_value__mutmut_29': x_set_variable_value__mutmut_29, 
    'x_set_variable_value__mutmut_30': x_set_variable_value__mutmut_30, 
    'x_set_variable_value__mutmut_31': x_set_variable_value__mutmut_31, 
    'x_set_variable_value__mutmut_32': x_set_variable_value__mutmut_32
}

def set_variable_value(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_set_variable_value__mutmut_orig, x_set_variable_value__mutmut_mutants, args, kwargs)
    return result 

set_variable_value.__signature__ = _mutmut_signature(x_set_variable_value__mutmut_orig)
x_set_variable_value__mutmut_orig.__name__ = 'x_set_variable_value'


def x_step_into__mutmut_orig(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_1(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = None
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_2(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_3(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = None
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_4(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["XXbreakOnAsyncCallXX"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_5(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakonasynccall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_6(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["BREAKONASYNCCALL"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_7(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["Breakonasynccall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_8(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_9(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_10(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["XXskipListXX"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_11(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skiplist"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_12(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["SKIPLIST"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_13(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["Skiplist"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_14(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_step_into__mutmut_15(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_16(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_17(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.stepInto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_18(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.stepIntoXX",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_19(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.stepinto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_20(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.STEPINTO",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_21(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepinto",
        "params": params,
    }
    yield cmd_dict


def x_step_into__mutmut_22(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_step_into__mutmut_23(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "PARAMS": params,
    }
    yield cmd_dict


def x_step_into__mutmut_24(
    break_on_async_call: bool | None = None,
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps into the function call.

    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause.
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into.
    """
    params: T_JSON_DICT = {}
    if break_on_async_call is not None:
        params["breakOnAsyncCall"] = break_on_async_call
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepInto",
        "Params": params,
    }
    yield cmd_dict

x_step_into__mutmut_mutants : ClassVar[MutantDict] = {
'x_step_into__mutmut_1': x_step_into__mutmut_1, 
    'x_step_into__mutmut_2': x_step_into__mutmut_2, 
    'x_step_into__mutmut_3': x_step_into__mutmut_3, 
    'x_step_into__mutmut_4': x_step_into__mutmut_4, 
    'x_step_into__mutmut_5': x_step_into__mutmut_5, 
    'x_step_into__mutmut_6': x_step_into__mutmut_6, 
    'x_step_into__mutmut_7': x_step_into__mutmut_7, 
    'x_step_into__mutmut_8': x_step_into__mutmut_8, 
    'x_step_into__mutmut_9': x_step_into__mutmut_9, 
    'x_step_into__mutmut_10': x_step_into__mutmut_10, 
    'x_step_into__mutmut_11': x_step_into__mutmut_11, 
    'x_step_into__mutmut_12': x_step_into__mutmut_12, 
    'x_step_into__mutmut_13': x_step_into__mutmut_13, 
    'x_step_into__mutmut_14': x_step_into__mutmut_14, 
    'x_step_into__mutmut_15': x_step_into__mutmut_15, 
    'x_step_into__mutmut_16': x_step_into__mutmut_16, 
    'x_step_into__mutmut_17': x_step_into__mutmut_17, 
    'x_step_into__mutmut_18': x_step_into__mutmut_18, 
    'x_step_into__mutmut_19': x_step_into__mutmut_19, 
    'x_step_into__mutmut_20': x_step_into__mutmut_20, 
    'x_step_into__mutmut_21': x_step_into__mutmut_21, 
    'x_step_into__mutmut_22': x_step_into__mutmut_22, 
    'x_step_into__mutmut_23': x_step_into__mutmut_23, 
    'x_step_into__mutmut_24': x_step_into__mutmut_24
}

def step_into(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_step_into__mutmut_orig, x_step_into__mutmut_mutants, args, kwargs)
    return result 

step_into.__signature__ = _mutmut_signature(x_step_into__mutmut_orig)
x_step_into__mutmut_orig.__name__ = 'x_step_into'


def x_step_out__mutmut_orig() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps out of the function call.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOut",
    }
    yield cmd_dict


def x_step_out__mutmut_1() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps out of the function call.
    """
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_step_out__mutmut_2() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps out of the function call.
    """
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.stepOut",
    }
    yield cmd_dict


def x_step_out__mutmut_3() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps out of the function call.
    """
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.stepOut",
    }
    yield cmd_dict


def x_step_out__mutmut_4() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps out of the function call.
    """
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.stepOut",
    }
    yield cmd_dict


def x_step_out__mutmut_5() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps out of the function call.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.stepOutXX",
    }
    yield cmd_dict


def x_step_out__mutmut_6() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps out of the function call.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.stepout",
    }
    yield cmd_dict


def x_step_out__mutmut_7() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps out of the function call.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.STEPOUT",
    }
    yield cmd_dict


def x_step_out__mutmut_8() -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps out of the function call.
    """
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepout",
    }
    yield cmd_dict

x_step_out__mutmut_mutants : ClassVar[MutantDict] = {
'x_step_out__mutmut_1': x_step_out__mutmut_1, 
    'x_step_out__mutmut_2': x_step_out__mutmut_2, 
    'x_step_out__mutmut_3': x_step_out__mutmut_3, 
    'x_step_out__mutmut_4': x_step_out__mutmut_4, 
    'x_step_out__mutmut_5': x_step_out__mutmut_5, 
    'x_step_out__mutmut_6': x_step_out__mutmut_6, 
    'x_step_out__mutmut_7': x_step_out__mutmut_7, 
    'x_step_out__mutmut_8': x_step_out__mutmut_8
}

def step_out(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_step_out__mutmut_orig, x_step_out__mutmut_mutants, args, kwargs)
    return result 

step_out.__signature__ = _mutmut_signature(x_step_out__mutmut_orig)
x_step_out__mutmut_orig.__name__ = 'x_step_out'


def x_step_over__mutmut_orig(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOver",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_1(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = None
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOver",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_2(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOver",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_3(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = None
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOver",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_4(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["XXskipListXX"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOver",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_5(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skiplist"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOver",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_6(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["SKIPLIST"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOver",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_7(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["Skiplist"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOver",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_8(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = None
    yield cmd_dict


def x_step_over__mutmut_9(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "XXmethodXX": "Debugger.stepOver",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_10(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "METHOD": "Debugger.stepOver",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_11(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "Method": "Debugger.stepOver",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_12(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "XXDebugger.stepOverXX",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_13(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "debugger.stepover",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_14(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "DEBUGGER.STEPOVER",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_15(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepover",
        "params": params,
    }
    yield cmd_dict


def x_step_over__mutmut_16(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOver",
        "XXparamsXX": params,
    }
    yield cmd_dict


def x_step_over__mutmut_17(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOver",
        "PARAMS": params,
    }
    yield cmd_dict


def x_step_over__mutmut_18(
    skip_list: list[LocationRange] | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, None]:
    """
    Steps over the statement.

    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over.
    """
    params: T_JSON_DICT = {}
    if skip_list is not None:
        params["skipList"] = [i.to_json() for i in skip_list]
    cmd_dict: T_JSON_DICT = {
        "method": "Debugger.stepOver",
        "Params": params,
    }
    yield cmd_dict

x_step_over__mutmut_mutants : ClassVar[MutantDict] = {
'x_step_over__mutmut_1': x_step_over__mutmut_1, 
    'x_step_over__mutmut_2': x_step_over__mutmut_2, 
    'x_step_over__mutmut_3': x_step_over__mutmut_3, 
    'x_step_over__mutmut_4': x_step_over__mutmut_4, 
    'x_step_over__mutmut_5': x_step_over__mutmut_5, 
    'x_step_over__mutmut_6': x_step_over__mutmut_6, 
    'x_step_over__mutmut_7': x_step_over__mutmut_7, 
    'x_step_over__mutmut_8': x_step_over__mutmut_8, 
    'x_step_over__mutmut_9': x_step_over__mutmut_9, 
    'x_step_over__mutmut_10': x_step_over__mutmut_10, 
    'x_step_over__mutmut_11': x_step_over__mutmut_11, 
    'x_step_over__mutmut_12': x_step_over__mutmut_12, 
    'x_step_over__mutmut_13': x_step_over__mutmut_13, 
    'x_step_over__mutmut_14': x_step_over__mutmut_14, 
    'x_step_over__mutmut_15': x_step_over__mutmut_15, 
    'x_step_over__mutmut_16': x_step_over__mutmut_16, 
    'x_step_over__mutmut_17': x_step_over__mutmut_17, 
    'x_step_over__mutmut_18': x_step_over__mutmut_18
}

def step_over(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_step_over__mutmut_orig, x_step_over__mutmut_mutants, args, kwargs)
    return result 

step_over.__signature__ = _mutmut_signature(x_step_over__mutmut_orig)
x_step_over__mutmut_orig.__name__ = 'x_step_over'


@event_class("Debugger.breakpointResolved")
@dataclass
class BreakpointResolved:
    """
    Fired when breakpoint is resolved to an actual script and location.
    Deprecated in favor of ``resolvedBreakpoints`` in the ``scriptParsed`` event.
    """
    #: Breakpoint unique identifier.
    breakpoint_id: BreakpointId
    #: Actual breakpoint location.
    location: Location

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BreakpointResolved:
        return cls(
            breakpoint_id=BreakpointId.from_json(json["breakpointId"]),
            location=Location.from_json(json["location"]),
        )


@event_class("Debugger.paused")
@dataclass
class Paused:
    """
    Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    """
    #: Call stack the virtual machine stopped on.
    call_frames: list[CallFrame]
    #: Pause reason.
    reason: str
    #: Object containing break-specific auxiliary properties.
    data: dict | None
    #: Hit breakpoints IDs
    hit_breakpoints: list[str] | None
    #: Async stack trace, if any.
    async_stack_trace: runtime.StackTrace | None
    #: Async stack trace, if any.
    async_stack_trace_id: runtime.StackTraceId | None
    #: Never present, will be removed.
    async_call_stack_trace_id: runtime.StackTraceId | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Paused:
        return cls(
            call_frames=[CallFrame.from_json(i) for i in json["callFrames"]],
            reason=str(json["reason"]),
            data=dict(json["data"]) if "data" in json else None,
            hit_breakpoints=[str(i) for i in json["hitBreakpoints"]] if "hitBreakpoints" in json else None,
            async_stack_trace=runtime.StackTrace.from_json(json["asyncStackTrace"]) if "asyncStackTrace" in json else None,
            async_stack_trace_id=runtime.StackTraceId.from_json(json["asyncStackTraceId"]) if "asyncStackTraceId" in json else None,
            async_call_stack_trace_id=runtime.StackTraceId.from_json(json["asyncCallStackTraceId"]) if "asyncCallStackTraceId" in json else None,
        )


@event_class("Debugger.resumed")
@dataclass
class Resumed:
    """
    Fired when the virtual machine resumed execution.
    """


    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Resumed:
        return cls(

        )


@event_class("Debugger.scriptFailedToParse")
@dataclass
class ScriptFailedToParse:
    """
    Fired when virtual machine fails to parse the script.
    """
    #: Identifier of the script parsed.
    script_id: runtime.ScriptId
    #: URL or name of the script parsed (if any).
    url: str
    #: Line offset of the script within the resource with given URL (for script tags).
    start_line: int
    #: Column offset of the script within the resource with given URL.
    start_column: int
    #: Last line of the script.
    end_line: int
    #: Length of the last line of the script.
    end_column: int
    #: Specifies script creation context.
    execution_context_id: runtime.ExecutionContextId
    #: Content hash of the script, SHA-256.
    hash_: str
    #: For Wasm modules, the content of the ``build_id`` custom section.
    build_id: str
    #: Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'``'isolated'``'worker', frameId: string}
    execution_context_aux_data: dict | None
    #: URL of source map associated with script (if any).
    source_map_url: str | None
    #: True, if this script has sourceURL.
    has_source_url: bool | None
    #: True, if this script is ES6 module.
    is_module: bool | None
    #: This script length.
    length: int | None
    #: JavaScript top stack frame of where the script parsed event was triggered if available.
    stack_trace: runtime.StackTrace | None
    #: If the scriptLanguage is WebAssembly, the code section offset in the module.
    code_offset: int | None
    #: The language of the script.
    script_language: ScriptLanguage | None
    #: The name the embedder supplied for this script.
    embedder_name: str | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScriptFailedToParse:
        return cls(
            script_id=runtime.ScriptId.from_json(json["scriptId"]),
            url=str(json["url"]),
            start_line=int(json["startLine"]),
            start_column=int(json["startColumn"]),
            end_line=int(json["endLine"]),
            end_column=int(json["endColumn"]),
            execution_context_id=runtime.ExecutionContextId.from_json(json["executionContextId"]),
            hash_=str(json["hash"]),
            build_id=str(json["buildId"]),
            execution_context_aux_data=dict(json["executionContextAuxData"]) if "executionContextAuxData" in json else None,
            source_map_url=str(json["sourceMapURL"]) if "sourceMapURL" in json else None,
            has_source_url=bool(json["hasSourceURL"]) if "hasSourceURL" in json else None,
            is_module=bool(json["isModule"]) if "isModule" in json else None,
            length=int(json["length"]) if "length" in json else None,
            stack_trace=runtime.StackTrace.from_json(json["stackTrace"]) if "stackTrace" in json else None,
            code_offset=int(json["codeOffset"]) if "codeOffset" in json else None,
            script_language=ScriptLanguage.from_json(json["scriptLanguage"]) if "scriptLanguage" in json else None,
            embedder_name=str(json["embedderName"]) if "embedderName" in json else None,
        )


@event_class("Debugger.scriptParsed")
@dataclass
class ScriptParsed:
    """
    Fired when virtual machine parses script. This event is also fired for all known and uncollected
    scripts upon enabling debugger.
    """
    #: Identifier of the script parsed.
    script_id: runtime.ScriptId
    #: URL or name of the script parsed (if any).
    url: str
    #: Line offset of the script within the resource with given URL (for script tags).
    start_line: int
    #: Column offset of the script within the resource with given URL.
    start_column: int
    #: Last line of the script.
    end_line: int
    #: Length of the last line of the script.
    end_column: int
    #: Specifies script creation context.
    execution_context_id: runtime.ExecutionContextId
    #: Content hash of the script, SHA-256.
    hash_: str
    #: For Wasm modules, the content of the ``build_id`` custom section.
    build_id: str
    #: Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'``'isolated'``'worker', frameId: string}
    execution_context_aux_data: dict | None
    #: True, if this script is generated as a result of the live edit operation.
    is_live_edit: bool | None
    #: URL of source map associated with script (if any).
    source_map_url: str | None
    #: True, if this script has sourceURL.
    has_source_url: bool | None
    #: True, if this script is ES6 module.
    is_module: bool | None
    #: This script length.
    length: int | None
    #: JavaScript top stack frame of where the script parsed event was triggered if available.
    stack_trace: runtime.StackTrace | None
    #: If the scriptLanguage is WebAssembly, the code section offset in the module.
    code_offset: int | None
    #: The language of the script.
    script_language: ScriptLanguage | None
    #: If the scriptLanguage is WebAssembly, the source of debug symbols for the module.
    debug_symbols: list[DebugSymbols] | None
    #: The name the embedder supplied for this script.
    embedder_name: str | None
    #: The list of set breakpoints in this script if calls to ``setBreakpointByUrl``
    #: matches this script's URL or hash. Clients that use this list can ignore the
    #: ``breakpointResolved`` event. They are equivalent.
    resolved_breakpoints: list[ResolvedBreakpoint] | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScriptParsed:
        return cls(
            script_id=runtime.ScriptId.from_json(json["scriptId"]),
            url=str(json["url"]),
            start_line=int(json["startLine"]),
            start_column=int(json["startColumn"]),
            end_line=int(json["endLine"]),
            end_column=int(json["endColumn"]),
            execution_context_id=runtime.ExecutionContextId.from_json(json["executionContextId"]),
            hash_=str(json["hash"]),
            build_id=str(json["buildId"]),
            execution_context_aux_data=dict(json["executionContextAuxData"]) if "executionContextAuxData" in json else None,
            is_live_edit=bool(json["isLiveEdit"]) if "isLiveEdit" in json else None,
            source_map_url=str(json["sourceMapURL"]) if "sourceMapURL" in json else None,
            has_source_url=bool(json["hasSourceURL"]) if "hasSourceURL" in json else None,
            is_module=bool(json["isModule"]) if "isModule" in json else None,
            length=int(json["length"]) if "length" in json else None,
            stack_trace=runtime.StackTrace.from_json(json["stackTrace"]) if "stackTrace" in json else None,
            code_offset=int(json["codeOffset"]) if "codeOffset" in json else None,
            script_language=ScriptLanguage.from_json(json["scriptLanguage"]) if "scriptLanguage" in json else None,
            debug_symbols=[DebugSymbols.from_json(i) for i in json["debugSymbols"]] if "debugSymbols" in json else None,
            embedder_name=str(json["embedderName"]) if "embedderName" in json else None,
            resolved_breakpoints=[ResolvedBreakpoint.from_json(i) for i in json["resolvedBreakpoints"]] if "resolvedBreakpoints" in json else None,
        )
